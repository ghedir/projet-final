{"ast":null,"code":"// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst rpj = require('read-package-json-fast');\n\nconst binLinks = require('bin-links');\n\nconst runScript = require('@npmcli/run-script');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\n\nconst boolEnv = b => b ? '1' : '';\n\nconst sortNodes = (a, b) => a.depth - b.depth || localeCompare(a.path, b.path);\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _build = Symbol('build');\n\nconst _resetQueues = Symbol('resetQueues');\n\nconst _rebuildBundle = Symbol('rebuildBundle');\n\nconst _ignoreScripts = Symbol('ignoreScripts');\n\nconst _binLinks = Symbol('binLinks');\n\nconst _oldMeta = Symbol('oldMeta');\n\nconst _createBinLinks = Symbol('createBinLinks');\n\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure');\n\nconst _linkAllBins = Symbol('linkAllBins');\n\nconst _runScripts = Symbol('runScripts');\n\nconst _buildQueues = Symbol('buildQueues');\n\nconst _addToBuildSet = Symbol('addToBuildSet');\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _queues = Symbol('queues');\n\nconst _scriptShell = Symbol('scriptShell');\n\nconst _force = Symbol.for('force'); // defined by reify mixin\n\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _trashList = Symbol.for('trashList');\n\nmodule.exports = cls => class Builder extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true\n    } = options;\n    this.scriptsRun = new Set();\n    this[_binLinks] = binLinks;\n    this[_ignoreScripts] = !!ignoreScripts;\n    this[_scriptShell] = scriptShell;\n    this[_rebuildBundle] = !!rebuildBundle;\n\n    this[_resetQueues]();\n\n    this[_oldMeta] = null;\n  }\n\n  async rebuild({\n    nodes,\n    handleOptionalFailure = false\n  } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return;\n    } // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n\n\n    this[_doHandleOptionalFailure] = handleOptionalFailure; // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n\n    if (!nodes) {\n      const tree = await this.loadActual();\n\n      if (this[_workspaces] && this[_workspaces].length) {\n        const filterSet = this.workspaceDependencySet(tree, this[_workspaces]);\n        nodes = tree.inventory.filter(node => filterSet.has(node));\n      } else {\n        nodes = tree.inventory.values();\n      }\n    } // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n\n\n    process.emit('time', 'build');\n    const depNodes = new Set();\n    const linkNodes = new Set();\n\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) {\n        linkNodes.add(node);\n      } else {\n        depNodes.add(node);\n      }\n    }\n\n    await this[_build](depNodes, {});\n\n    if (linkNodes.size) {\n      this[_resetQueues]();\n\n      await this[_build](linkNodes, {\n        type: 'links'\n      });\n    }\n\n    process.emit('timeEnd', 'build');\n  }\n\n  [_resetQueues]() {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: []\n    };\n  }\n\n  async [_build](nodes, {\n    type = 'deps'\n  }) {\n    process.emit('time', `build:${type}`);\n    await this[_buildQueues](nodes);\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall');\n    }\n\n    if (this[_binLinks] && type !== 'links') {\n      await this[_linkAllBins]();\n    } // links should also run prepare scripts and only link bins after that\n\n\n    if (type === 'links') {\n      await this[_runScripts]('prepare');\n\n      if (this[_binLinks]) {\n        await this[_linkAllBins]();\n      }\n    }\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install');\n      await this[_runScripts]('postinstall');\n    }\n\n    process.emit('timeEnd', `build:${type}`);\n  }\n\n  async [_buildQueues](nodes) {\n    process.emit('time', 'build:queue');\n    const set = new Set();\n    const promises = [];\n\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set)); // if it has bundle deps, add those too, if rebuildBundle\n\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies;\n\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle\n          });\n        }\n      }\n    }\n\n    await promiseAllRejectLate(promises); // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n\n    const queue = [...set].sort(sortNodes);\n\n    for (const node of queue) {\n      const {\n        package: {\n          bin,\n          scripts = {}\n        }\n      } = node.target;\n      const {\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      } = scripts;\n      const tests = {\n        bin,\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      };\n\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node);\n        }\n      }\n    }\n\n    process.emit('timeEnd', 'build:queue');\n  }\n\n  async [_checkBins](node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return;\n    }\n\n    const {\n      path,\n      package: pkg\n    } = node;\n    await binLinks.checkBins({\n      pkg,\n      path,\n      top: true,\n      global: true\n    });\n  }\n\n  async [_addToBuildSet](node, set, refreshed = false) {\n    if (set.has(node)) {\n      return;\n    }\n\n    if (this[_oldMeta] === null) {\n      const {\n        root: {\n          meta\n        }\n      } = node;\n      this[_oldMeta] = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    }\n\n    const {\n      package: pkg,\n      hasInstallScript\n    } = node.target;\n    const {\n      gypfile,\n      bin,\n      scripts = {}\n    } = pkg;\n    const {\n      preinstall,\n      install,\n      postinstall,\n      prepare\n    } = scripts;\n    const anyScript = preinstall || install || postinstall || prepare;\n\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node);\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}));\n      set.delete(node);\n      const {\n        scripts = {}\n      } = pkg;\n      node.package.scripts = scripts;\n      return this[_addToBuildSet](node, set, true);\n    } // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n\n\n    const isGyp = gypfile !== false && !install && !preinstall && (await isNodeGypPackage(node.path));\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node);\n      }\n\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript;\n        node.package.scripts = scripts;\n      }\n\n      set.add(node);\n    }\n  }\n\n  async [_runScripts](event) {\n    const queue = this[_queues][event];\n\n    if (!queue.length) {\n      return;\n    }\n\n    process.emit('time', `build:run:${event}`);\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe';\n    const limit = this.options.foregroundScripts ? 1 : undefined;\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location\n      } = node.target; // skip any that we know we'll be deleting\n\n      if (this[_trashList].has(path)) {\n        return;\n      }\n\n      const timer = `build:run:${event}:${location}`;\n      process.emit('time', timer);\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event]);\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)\n      };\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell]\n      };\n      const p = runScript(runOpts).catch(er => {\n        const {\n          code,\n          signal\n        } = er;\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n        throw er;\n      }).then(({\n        args,\n        code,\n        signal,\n        stdout,\n        stderr\n      }) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr\n        });\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n      });\n      await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n      process.emit('timeEnd', timer);\n    }), limit);\n    process.emit('timeEnd', `build:run:${event}`);\n  }\n\n  async [_linkAllBins]() {\n    const queue = this[_queues].bin;\n\n    if (!queue.length) {\n      return;\n    }\n\n    process.emit('time', 'build:link');\n    const promises = []; // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node));\n    }\n\n    await promiseAllRejectLate(promises);\n    process.emit('timeEnd', 'build:link');\n  }\n\n  async [_createBinLinks](node) {\n    if (this[_trashList].has(node.path)) {\n      return;\n    }\n\n    process.emit('time', `build:link:${node.location}`);\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop\n    });\n    await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n    process.emit('timeEnd', `build:link:${node.location}`);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/rebuild.js"],"names":["localeCompare","require","depth","dfwalk","promiseAllRejectLate","rpj","binLinks","runScript","promiseCallLimit","resolve","isNodeGypPackage","defaultGypInstallScript","boolEnv","b","sortNodes","a","path","_workspaces","Symbol","for","_build","_resetQueues","_rebuildBundle","_ignoreScripts","_binLinks","_oldMeta","_createBinLinks","_doHandleOptionalFailure","_linkAllBins","_runScripts","_buildQueues","_addToBuildSet","_checkBins","_queues","_scriptShell","_force","_handleOptionalFailure","_trashList","module","exports","cls","Builder","constructor","options","ignoreScripts","scriptShell","rebuildBundle","scriptsRun","Set","rebuild","nodes","handleOptionalFailure","tree","loadActual","length","filterSet","workspaceDependencySet","inventory","filter","node","has","values","process","emit","depNodes","linkNodes","isLink","add","size","type","preinstall","install","postinstall","prepare","bin","set","promises","push","bd","package","bundleDependencies","leave","getChildren","children","inBundle","queue","sort","scripts","target","tests","key","Object","entries","globalTop","pkg","checkBins","top","global","refreshed","root","meta","loadedFromDisk","originalLockfileVersion","hasInstallScript","gypfile","anyScript","catch","delete","isGyp","event","stdio","foregroundScripts","limit","undefined","map","integrity","resolved","optional","peer","dev","devOptional","location","timer","log","info","_id","env","npm_package_resolved","npm_package_integrity","npm_package_json","npm_package_optional","npm_package_dev","npm_package_peer","npm_package_dev_optional","runOpts","stdioString","p","er","code","signal","then","args","stdout","stderr","cmd","isTop","force"],"mappings":"AAAA;AACA;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,+BAAD,CAAP,CAAyC,IAAzC,CAAtB;;AACA,MAAM;AAACC,EAAAA,KAAK,EAAEC;AAAR,IAAkBF,OAAO,CAAC,WAAD,CAA/B;;AACA,MAAMG,oBAAoB,GAAGH,OAAO,CAAC,yBAAD,CAApC;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,wBAAD,CAAnB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,oBAAD,CAAzB;;AACA,MAAMO,gBAAgB,GAAGP,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAM;AAACQ,EAAAA;AAAD,IAAYR,OAAO,CAAC,MAAD,CAAzB;;AACA,MAAM;AACJS,EAAAA,gBADI;AAEJC,EAAAA;AAFI,IAGFV,OAAO,CAAC,kBAAD,CAHX;;AAKA,MAAMW,OAAO,GAAGC,CAAC,IAAIA,CAAC,GAAG,GAAH,GAAS,EAA/B;;AACA,MAAMC,SAAS,GAAG,CAACC,CAAD,EAAIF,CAAJ,KACfE,CAAC,CAACb,KAAF,GAAUW,CAAC,CAACX,KAAb,IAAuBF,aAAa,CAACe,CAAC,CAACC,IAAH,EAASH,CAAC,CAACG,IAAX,CADtC;;AAGA,MAAMC,WAAW,GAAGC,MAAM,CAACC,GAAP,CAAW,YAAX,CAApB;;AACA,MAAMC,MAAM,GAAGF,MAAM,CAAC,OAAD,CAArB;;AACA,MAAMG,YAAY,GAAGH,MAAM,CAAC,aAAD,CAA3B;;AACA,MAAMI,cAAc,GAAGJ,MAAM,CAAC,eAAD,CAA7B;;AACA,MAAMK,cAAc,GAAGL,MAAM,CAAC,eAAD,CAA7B;;AACA,MAAMM,SAAS,GAAGN,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAMO,QAAQ,GAAGP,MAAM,CAAC,SAAD,CAAvB;;AACA,MAAMQ,eAAe,GAAGR,MAAM,CAAC,gBAAD,CAA9B;;AACA,MAAMS,wBAAwB,GAAGT,MAAM,CAAC,yBAAD,CAAvC;;AACA,MAAMU,YAAY,GAAGV,MAAM,CAAC,aAAD,CAA3B;;AACA,MAAMW,WAAW,GAAGX,MAAM,CAAC,YAAD,CAA1B;;AACA,MAAMY,YAAY,GAAGZ,MAAM,CAAC,aAAD,CAA3B;;AACA,MAAMa,cAAc,GAAGb,MAAM,CAAC,eAAD,CAA7B;;AACA,MAAMc,UAAU,GAAGd,MAAM,CAACC,GAAP,CAAW,WAAX,CAAnB;;AACA,MAAMc,OAAO,GAAGf,MAAM,CAAC,QAAD,CAAtB;;AACA,MAAMgB,YAAY,GAAGhB,MAAM,CAAC,aAAD,CAA3B;;AAEA,MAAMiB,MAAM,GAAGjB,MAAM,CAACC,GAAP,CAAW,OAAX,CAAf,C,CAEA;;;AACA,MAAMiB,sBAAsB,GAAGlB,MAAM,CAACC,GAAP,CAAW,uBAAX,CAA/B;;AACA,MAAMkB,UAAU,GAAGnB,MAAM,CAACC,GAAP,CAAW,WAAX,CAAnB;;AAEAmB,MAAM,CAACC,OAAP,GAAiBC,GAAG,IAAI,MAAMC,OAAN,SAAsBD,GAAtB,CAA0B;AAChDE,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB,UAAMA,OAAN;AAEA,UAAM;AACJC,MAAAA,aAAa,GAAG,KADZ;AAEJC,MAAAA,WAFI;AAGJvC,MAAAA,QAAQ,GAAG,IAHP;AAIJwC,MAAAA,aAAa,GAAG;AAJZ,QAKFH,OALJ;AAOA,SAAKI,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA,SAAKxB,SAAL,IAAkBlB,QAAlB;AACA,SAAKiB,cAAL,IAAuB,CAAC,CAACqB,aAAzB;AACA,SAAKV,YAAL,IAAqBW,WAArB;AACA,SAAKvB,cAAL,IAAuB,CAAC,CAACwB,aAAzB;;AACA,SAAKzB,YAAL;;AACA,SAAKI,QAAL,IAAiB,IAAjB;AACD;;AAEY,QAAPwB,OAAO,CAAE;AAAEC,IAAAA,KAAF;AAASC,IAAAA,qBAAqB,GAAG;AAAjC,MAA2C,EAA7C,EAAiD;AAC5D;AACA,QAAI,KAAK5B,cAAL,KAAwB,CAAC,KAAKC,SAAL,CAA7B,EAA8C;AAC5C;AACD,KAJ2D,CAM5D;AACA;AACA;;;AACA,SAAKG,wBAAL,IAAiCwB,qBAAjC,CAT4D,CAW5D;AACA;;AACA,QAAI,CAACD,KAAL,EAAY;AACV,YAAME,IAAI,GAAG,MAAM,KAAKC,UAAL,EAAnB;;AACA,UAAI,KAAKpC,WAAL,KAAqB,KAAKA,WAAL,EAAkBqC,MAA3C,EAAmD;AACjD,cAAMC,SAAS,GAAG,KAAKC,sBAAL,CAA4BJ,IAA5B,EAAkC,KAAKnC,WAAL,CAAlC,CAAlB;AACAiC,QAAAA,KAAK,GAAGE,IAAI,CAACK,SAAL,CAAeC,MAAf,CAAsBC,IAAI,IAAIJ,SAAS,CAACK,GAAV,CAAcD,IAAd,CAA9B,CAAR;AACD,OAHD,MAGO;AACLT,QAAAA,KAAK,GAAGE,IAAI,CAACK,SAAL,CAAeI,MAAf,EAAR;AACD;AACF,KArB2D,CAuB5D;AACA;;;AACAC,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAqB,OAArB;AACA,UAAMC,QAAQ,GAAG,IAAIhB,GAAJ,EAAjB;AACA,UAAMiB,SAAS,GAAG,IAAIjB,GAAJ,EAAlB;;AACA,SAAK,MAAMW,IAAX,IAAmBT,KAAnB,EAA0B;AACxB;AACA;AACA,UAAIS,IAAI,CAACO,MAAT,EAAiB;AACfD,QAAAA,SAAS,CAACE,GAAV,CAAcR,IAAd;AACD,OAFD,MAEO;AACLK,QAAAA,QAAQ,CAACG,GAAT,CAAaR,IAAb;AACD;AACF;;AAED,UAAM,KAAKvC,MAAL,EAAa4C,QAAb,EAAuB,EAAvB,CAAN;;AAEA,QAAIC,SAAS,CAACG,IAAd,EAAoB;AAClB,WAAK/C,YAAL;;AACA,YAAM,KAAKD,MAAL,EAAa6C,SAAb,EAAwB;AAAEI,QAAAA,IAAI,EAAE;AAAR,OAAxB,CAAN;AACD;;AAEDP,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB,OAAxB;AACD;;AAEY,GAAZ1C,YAAY,IAAK;AAChB,SAAKY,OAAL,IAAgB;AACdqC,MAAAA,UAAU,EAAE,EADE;AAEdC,MAAAA,OAAO,EAAE,EAFK;AAGdC,MAAAA,WAAW,EAAE,EAHC;AAIdC,MAAAA,OAAO,EAAE,EAJK;AAKdC,MAAAA,GAAG,EAAE;AALS,KAAhB;AAOD;;AAEY,SAANtD,MAAM,EAAG8B,KAAH,EAAU;AAAEmB,IAAAA,IAAI,GAAG;AAAT,GAAV,EAA6B;AACxCP,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAsB,SAAQM,IAAK,EAAnC;AAEA,UAAM,KAAKvC,YAAL,EAAmBoB,KAAnB,CAAN;;AACA,QAAI,CAAC,KAAK3B,cAAL,CAAL,EAA2B;AACzB,YAAM,KAAKM,WAAL,EAAkB,YAAlB,CAAN;AACD;;AACD,QAAI,KAAKL,SAAL,KAAmB6C,IAAI,KAAK,OAAhC,EAAyC;AACvC,YAAM,KAAKzC,YAAL,GAAN;AACD,KATuC,CAWxC;;;AACA,QAAIyC,IAAI,KAAK,OAAb,EAAsB;AACpB,YAAM,KAAKxC,WAAL,EAAkB,SAAlB,CAAN;;AAEA,UAAI,KAAKL,SAAL,CAAJ,EAAqB;AACnB,cAAM,KAAKI,YAAL,GAAN;AACD;AACF;;AAED,QAAI,CAAC,KAAKL,cAAL,CAAL,EAA2B;AACzB,YAAM,KAAKM,WAAL,EAAkB,SAAlB,CAAN;AACA,YAAM,KAAKA,WAAL,EAAkB,aAAlB,CAAN;AACD;;AAEDiC,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAyB,SAAQM,IAAK,EAAtC;AACD;;AAEkB,SAAZvC,YAAY,EAAGoB,KAAH,EAAU;AAC3BY,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAqB,aAArB;AACA,UAAMY,GAAG,GAAG,IAAI3B,GAAJ,EAAZ;AAEA,UAAM4B,QAAQ,GAAG,EAAjB;;AACA,SAAK,MAAMjB,IAAX,IAAmBT,KAAnB,EAA0B;AACxB0B,MAAAA,QAAQ,CAACC,IAAT,CAAc,KAAK9C,cAAL,EAAqB4B,IAArB,EAA2BgB,GAA3B,CAAd,EADwB,CAGxB;;AACA,UAAI,KAAKrD,cAAL,MAAyB,KAA7B,EAAoC;AAClC,cAAMwD,EAAE,GAAGnB,IAAI,CAACoB,OAAL,CAAaC,kBAAxB;;AACA,YAAIF,EAAE,IAAIA,EAAE,CAACxB,MAAb,EAAqB;AACnBnD,UAAAA,MAAM,CAAC;AACLiD,YAAAA,IAAI,EAAEO,IADD;AAELsB,YAAAA,KAAK,EAAEtB,IAAI,IAAIiB,QAAQ,CAACC,IAAT,CAAc,KAAK9C,cAAL,EAAqB4B,IAArB,EAA2BgB,GAA3B,CAAd,CAFV;AAGLO,YAAAA,WAAW,EAAEvB,IAAI,IAAI,CAAC,GAAGA,IAAI,CAACwB,QAAL,CAActB,MAAd,EAAJ,CAHhB;AAILH,YAAAA,MAAM,EAAEC,IAAI,IAAIA,IAAI,CAACyB;AAJhB,WAAD,CAAN;AAMD;AACF;AACF;;AACD,UAAMhF,oBAAoB,CAACwE,QAAD,CAA1B,CArB2B,CAuB3B;AACA;AACA;AACA;;AACA,UAAMS,KAAK,GAAG,CAAC,GAAGV,GAAJ,EAASW,IAAT,CAAcxE,SAAd,CAAd;;AAEA,SAAK,MAAM6C,IAAX,IAAmB0B,KAAnB,EAA0B;AACxB,YAAM;AAAEN,QAAAA,OAAO,EAAE;AAAEL,UAAAA,GAAF;AAAOa,UAAAA,OAAO,GAAG;AAAjB;AAAX,UAAqC5B,IAAI,CAAC6B,MAAhD;AACA,YAAM;AAAElB,QAAAA,UAAF;AAAcC,QAAAA,OAAd;AAAuBC,QAAAA,WAAvB;AAAoCC,QAAAA;AAApC,UAAgDc,OAAtD;AACA,YAAME,KAAK,GAAG;AAAEf,QAAAA,GAAF;AAAOJ,QAAAA,UAAP;AAAmBC,QAAAA,OAAnB;AAA4BC,QAAAA,WAA5B;AAAyCC,QAAAA;AAAzC,OAAd;;AACA,WAAK,MAAM,CAACiB,GAAD,EAAM9B,GAAN,CAAX,IAAyB+B,MAAM,CAACC,OAAP,CAAeH,KAAf,CAAzB,EAAgD;AAC9C,YAAI7B,GAAJ,EAAS;AACP,eAAK3B,OAAL,EAAcyD,GAAd,EAAmBb,IAAnB,CAAwBlB,IAAxB;AACD;AACF;AACF;;AACDG,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB,aAAxB;AACD;;AAEgB,SAAV/B,UAAU,EAAG2B,IAAH,EAAS;AACxB;AACA;AACA;AACA;AACA;AACA,QAAI,CAACA,IAAI,CAACkC,SAAN,IAAmB,KAAK1D,MAAL,CAAvB,EAAqC;AACnC;AACD;;AACD,UAAM;AAAEnB,MAAAA,IAAF;AAAQ+D,MAAAA,OAAO,EAAEe;AAAjB,QAAyBnC,IAA/B;AACA,UAAMrD,QAAQ,CAACyF,SAAT,CAAmB;AAAED,MAAAA,GAAF;AAAO9E,MAAAA,IAAP;AAAagF,MAAAA,GAAG,EAAE,IAAlB;AAAwBC,MAAAA,MAAM,EAAE;AAAhC,KAAnB,CAAN;AACD;;AAEoB,SAAdlE,cAAc,EAAG4B,IAAH,EAASgB,GAAT,EAAcuB,SAAS,GAAG,KAA1B,EAAiC;AACpD,QAAIvB,GAAG,CAACf,GAAJ,CAAQD,IAAR,CAAJ,EAAmB;AACjB;AACD;;AAED,QAAI,KAAKlC,QAAL,MAAmB,IAAvB,EAA6B;AAC3B,YAAM;AAAC0E,QAAAA,IAAI,EAAE;AAACC,UAAAA;AAAD;AAAP,UAAiBzC,IAAvB;AACA,WAAKlC,QAAL,IAAiB2E,IAAI,IAAIA,IAAI,CAACC,cAAb,IACf,EAAED,IAAI,CAACE,uBAAL,IAAgC,CAAlC,CADF;AAED;;AAED,UAAM;AAAEvB,MAAAA,OAAO,EAAEe,GAAX;AAAgBS,MAAAA;AAAhB,QAAqC5C,IAAI,CAAC6B,MAAhD;AACA,UAAM;AAAEgB,MAAAA,OAAF;AAAW9B,MAAAA,GAAX;AAAgBa,MAAAA,OAAO,GAAG;AAA1B,QAAiCO,GAAvC;AAEA,UAAM;AAAExB,MAAAA,UAAF;AAAcC,MAAAA,OAAd;AAAuBC,MAAAA,WAAvB;AAAoCC,MAAAA;AAApC,QAAgDc,OAAtD;AACA,UAAMkB,SAAS,GAAGnC,UAAU,IAAIC,OAAd,IAAyBC,WAAzB,IAAwCC,OAA1D;;AACA,QAAI,CAACyB,SAAD,IAAc,CAACO,SAAf,KAA6BF,gBAAgB,IAAI,KAAK9E,QAAL,CAAjD,CAAJ,EAAsE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACAkD,MAAAA,GAAG,CAACR,GAAJ,CAAQR,IAAR;AACA,YAAMmC,GAAG,GAAG,MAAMzF,GAAG,CAACsD,IAAI,CAAC3C,IAAL,GAAY,eAAb,CAAH,CAAiC0F,KAAjC,CAAuC,OAAO,EAAP,CAAvC,CAAlB;AACA/B,MAAAA,GAAG,CAACgC,MAAJ,CAAWhD,IAAX;AAEA,YAAM;AAAC4B,QAAAA,OAAO,GAAG;AAAX,UAAiBO,GAAvB;AACAnC,MAAAA,IAAI,CAACoB,OAAL,CAAaQ,OAAb,GAAuBA,OAAvB;AACA,aAAO,KAAKxD,cAAL,EAAqB4B,IAArB,EAA2BgB,GAA3B,EAAgC,IAAhC,CAAP;AACD,KA/BmD,CAiCpD;AACA;AACA;;;AACA,UAAMiC,KAAK,GAAGJ,OAAO,KAAK,KAAZ,IACZ,CAACjC,OADW,IAEZ,CAACD,UAFW,KAGZ,MAAM5D,gBAAgB,CAACiD,IAAI,CAAC3C,IAAN,CAHV,CAAd;;AAKA,QAAI0D,GAAG,IAAIJ,UAAP,IAAqBC,OAArB,IAAgCC,WAAhC,IAA+CC,OAA/C,IAA0DmC,KAA9D,EAAqE;AACnE,UAAIlC,GAAJ,EAAS;AACP,cAAM,KAAK1C,UAAL,EAAiB2B,IAAjB,CAAN;AACD;;AACD,UAAIiD,KAAJ,EAAW;AACTrB,QAAAA,OAAO,CAAChB,OAAR,GAAkB5D,uBAAlB;AACAgD,QAAAA,IAAI,CAACoB,OAAL,CAAaQ,OAAb,GAAuBA,OAAvB;AACD;;AACDZ,MAAAA,GAAG,CAACR,GAAJ,CAAQR,IAAR;AACD;AACF;;AAEiB,SAAX9B,WAAW,EAAGgF,KAAH,EAAU;AAC1B,UAAMxB,KAAK,GAAG,KAAKpD,OAAL,EAAc4E,KAAd,CAAd;;AAEA,QAAI,CAACxB,KAAK,CAAC/B,MAAX,EAAmB;AACjB;AACD;;AAEDQ,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAsB,aAAY8C,KAAM,EAAxC;AACA,UAAMC,KAAK,GAAG,KAAKnE,OAAL,CAAaoE,iBAAb,GAAiC,SAAjC,GAA6C,MAA3D;AACA,UAAMC,KAAK,GAAG,KAAKrE,OAAL,CAAaoE,iBAAb,GAAiC,CAAjC,GAAqCE,SAAnD;AACA,UAAMzG,gBAAgB,CAAC6E,KAAK,CAAC6B,GAAN,CAAUvD,IAAI,IAAI,YAAY;AACnD,YAAM;AACJ3C,QAAAA,IADI;AAEJmG,QAAAA,SAFI;AAGJC,QAAAA,QAHI;AAIJC,QAAAA,QAJI;AAKJC,QAAAA,IALI;AAMJC,QAAAA,GANI;AAOJC,QAAAA,WAPI;AAQJzC,QAAAA,OAAO,EAAEe,GARL;AASJ2B,QAAAA;AATI,UAUF9D,IAAI,CAAC6B,MAVT,CADmD,CAanD;;AACA,UAAI,KAAKnD,UAAL,EAAiBuB,GAAjB,CAAqB5C,IAArB,CAAJ,EAAgC;AAC9B;AACD;;AAED,YAAM0G,KAAK,GAAI,aAAYb,KAAM,IAAGY,QAAS,EAA7C;AACA3D,MAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAqB2D,KAArB;AACA,WAAKC,GAAL,CAASC,IAAT,CAAc,KAAd,EAAqB9B,GAAG,CAAC+B,GAAzB,EAA8BhB,KAA9B,EAAqCY,QAArC,EAA+C3B,GAAG,CAACP,OAAJ,CAAYsB,KAAZ,CAA/C;AACA,YAAMiB,GAAG,GAAG;AACVC,QAAAA,oBAAoB,EAAEX,QADZ;AAEVY,QAAAA,qBAAqB,EAAEb,SAFb;AAGVc,QAAAA,gBAAgB,EAAExH,OAAO,CAACO,IAAD,EAAO,cAAP,CAHf;AAIVkH,QAAAA,oBAAoB,EAAEtH,OAAO,CAACyG,QAAD,CAJnB;AAKVc,QAAAA,eAAe,EAAEvH,OAAO,CAAC2G,GAAD,CALd;AAMVa,QAAAA,gBAAgB,EAAExH,OAAO,CAAC0G,IAAD,CANf;AAOVe,QAAAA,wBAAwB,EACtBzH,OAAO,CAAC4G,WAAW,IAAI,CAACD,GAAhB,IAAuB,CAACF,QAAzB;AARC,OAAZ;AAUA,YAAMiB,OAAO,GAAG;AACdzB,QAAAA,KADc;AAEd7F,QAAAA,IAFc;AAGd8E,QAAAA,GAHc;AAIdyC,QAAAA,WAAW,EAAE,IAJC;AAKdzB,QAAAA,KALc;AAMdgB,QAAAA,GANc;AAOdjF,QAAAA,WAAW,EAAE,KAAKX,YAAL;AAPC,OAAhB;AASA,YAAMsG,CAAC,GAAGjI,SAAS,CAAC+H,OAAD,CAAT,CAAmB5B,KAAnB,CAAyB+B,EAAE,IAAI;AACvC,cAAM;AAAEC,UAAAA,IAAF;AAAQC,UAAAA;AAAR,YAAmBF,EAAzB;AACA,aAAKd,GAAL,CAASC,IAAT,CAAc,KAAd,EAAqB9B,GAAG,CAAC+B,GAAzB,EAA8BhB,KAA9B,EAAqC;AAAC6B,UAAAA,IAAD;AAAOC,UAAAA;AAAP,SAArC;AACA,cAAMF,EAAN;AACD,OAJS,EAIPG,IAJO,CAIF,CAAC;AAACC,QAAAA,IAAD;AAAOH,QAAAA,IAAP;AAAaC,QAAAA,MAAb;AAAqBG,QAAAA,MAArB;AAA6BC,QAAAA;AAA7B,OAAD,KAA0C;AAChD,aAAKhG,UAAL,CAAgBoB,GAAhB,CAAoB;AAClB2B,UAAAA,GADkB;AAElB9E,UAAAA,IAFkB;AAGlB6F,UAAAA,KAHkB;AAIlBmC,UAAAA,GAAG,EAAEH,IAAI,IAAIA,IAAI,CAACA,IAAI,CAACvF,MAAL,GAAc,CAAf,CAJC;AAKlBwE,UAAAA,GALkB;AAMlBY,UAAAA,IANkB;AAOlBC,UAAAA,MAPkB;AAQlBG,UAAAA,MARkB;AASlBC,UAAAA;AATkB,SAApB;AAWA,aAAKpB,GAAL,CAASC,IAAT,CAAc,KAAd,EAAqB9B,GAAG,CAAC+B,GAAzB,EAA8BhB,KAA9B,EAAqC;AAAC6B,UAAAA,IAAD;AAAOC,UAAAA;AAAP,SAArC;AACD,OAjBS,CAAV;AAmBA,aAAO,KAAKhH,wBAAL,IACH,KAAKS,sBAAL,EAA6BuB,IAA7B,EAAmC6E,CAAnC,CADG,GAEHA,CAFJ;AAIA1E,MAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB2D,KAAxB;AACD,KAhEsB,CAAD,EAgElBV,KAhEkB,CAAtB;AAiEAlD,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAyB,aAAY8C,KAAM,EAA3C;AACD;;AAEkB,SAAZjF,YAAY,IAAK;AACtB,UAAMyD,KAAK,GAAG,KAAKpD,OAAL,EAAcyC,GAA5B;;AACA,QAAI,CAACW,KAAK,CAAC/B,MAAX,EAAmB;AACjB;AACD;;AAEDQ,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAqB,YAArB;AACA,UAAMa,QAAQ,GAAG,EAAjB,CAPsB,CAQtB;AACA;;AACA,SAAK,MAAMjB,IAAX,IAAmB0B,KAAK,CAACC,IAAN,CAAWxE,SAAX,CAAnB,EAA0C;AACxC8D,MAAAA,QAAQ,CAACC,IAAT,CAAc,KAAKnD,eAAL,EAAsBiC,IAAtB,CAAd;AACD;;AAED,UAAMvD,oBAAoB,CAACwE,QAAD,CAA1B;AACAd,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwB,YAAxB;AACD;;AAEqB,SAAfrC,eAAe,EAAGiC,IAAH,EAAS;AAC7B,QAAI,KAAKtB,UAAL,EAAiBuB,GAAjB,CAAqBD,IAAI,CAAC3C,IAA1B,CAAJ,EAAqC;AACnC;AACD;;AAED8C,IAAAA,OAAO,CAACC,IAAR,CAAa,MAAb,EAAsB,cAAaJ,IAAI,CAAC8D,QAAS,EAAjD;AAEA,UAAMe,CAAC,GAAGlI,QAAQ,CAAC;AACjBwF,MAAAA,GAAG,EAAEnC,IAAI,CAACoB,OADO;AAEjB/D,MAAAA,IAAI,EAAE2C,IAAI,CAAC3C,IAFM;AAGjBgF,MAAAA,GAAG,EAAE,CAAC,EAAErC,IAAI,CAACsF,KAAL,IAActF,IAAI,CAACkC,SAArB,CAHW;AAIjBqD,MAAAA,KAAK,EAAE,KAAK/G,MAAL,CAJU;AAKjB8D,MAAAA,MAAM,EAAE,CAAC,CAACtC,IAAI,CAACkC;AALE,KAAD,CAAlB;AAQA,WAAO,KAAKlE,wBAAL,IACH,KAAKS,sBAAL,EAA6BuB,IAA7B,EAAmC6E,CAAnC,CADG,GAEHA,CAFJ;AAIA1E,IAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAyB,cAAaJ,IAAI,CAAC8D,QAAS,EAApD;AACD;;AA1U+C,CAAlD","sourcesContent":["// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst {depth: dfwalk} = require('treeverse')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst rpj = require('read-package-json-fast')\nconst binLinks = require('bin-links')\nconst runScript = require('@npmcli/run-script')\nconst promiseCallLimit = require('promise-call-limit')\nconst {resolve} = require('path')\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript,\n} = require('@npmcli/node-gyp')\n\nconst boolEnv = b => b ? '1' : ''\nconst sortNodes = (a, b) =>\n  (a.depth - b.depth) || localeCompare(a.path, b.path)\n\nconst _workspaces = Symbol.for('workspaces')\nconst _build = Symbol('build')\nconst _resetQueues = Symbol('resetQueues')\nconst _rebuildBundle = Symbol('rebuildBundle')\nconst _ignoreScripts = Symbol('ignoreScripts')\nconst _binLinks = Symbol('binLinks')\nconst _oldMeta = Symbol('oldMeta')\nconst _createBinLinks = Symbol('createBinLinks')\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure')\nconst _linkAllBins = Symbol('linkAllBins')\nconst _runScripts = Symbol('runScripts')\nconst _buildQueues = Symbol('buildQueues')\nconst _addToBuildSet = Symbol('addToBuildSet')\nconst _checkBins = Symbol.for('checkBins')\nconst _queues = Symbol('queues')\nconst _scriptShell = Symbol('scriptShell')\n\nconst _force = Symbol.for('force')\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _trashList = Symbol.for('trashList')\n\nmodule.exports = cls => class Builder extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true,\n    } = options\n\n    this.scriptsRun = new Set()\n    this[_binLinks] = binLinks\n    this[_ignoreScripts] = !!ignoreScripts\n    this[_scriptShell] = scriptShell\n    this[_rebuildBundle] = !!rebuildBundle\n    this[_resetQueues]()\n    this[_oldMeta] = null\n  }\n\n  async rebuild ({ nodes, handleOptionalFailure = false } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return\n    }\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure\n\n    // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n    if (!nodes) {\n      const tree = await this.loadActual()\n      if (this[_workspaces] && this[_workspaces].length) {\n        const filterSet = this.workspaceDependencySet(tree, this[_workspaces])\n        nodes = tree.inventory.filter(node => filterSet.has(node))\n      } else {\n        nodes = tree.inventory.values()\n      }\n    }\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build')\n    const depNodes = new Set()\n    const linkNodes = new Set()\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) {\n        linkNodes.add(node)\n      } else {\n        depNodes.add(node)\n      }\n    }\n\n    await this[_build](depNodes, {})\n\n    if (linkNodes.size) {\n      this[_resetQueues]()\n      await this[_build](linkNodes, { type: 'links' })\n    }\n\n    process.emit('timeEnd', 'build')\n  }\n\n  [_resetQueues] () {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: [],\n    }\n  }\n\n  async [_build] (nodes, { type = 'deps' }) {\n    process.emit('time', `build:${type}`)\n\n    await this[_buildQueues](nodes)\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('preinstall')\n    }\n    if (this[_binLinks] && type !== 'links') {\n      await this[_linkAllBins]()\n    }\n\n    // links should also run prepare scripts and only link bins after that\n    if (type === 'links') {\n      await this[_runScripts]('prepare')\n\n      if (this[_binLinks]) {\n        await this[_linkAllBins]()\n      }\n    }\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install')\n      await this[_runScripts]('postinstall')\n    }\n\n    process.emit('timeEnd', `build:${type}`)\n  }\n\n  async [_buildQueues] (nodes) {\n    process.emit('time', 'build:queue')\n    const set = new Set()\n\n    const promises = []\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set))\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle,\n          })\n        }\n      }\n    }\n    await promiseAllRejectLate(promises)\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes)\n\n    for (const node of queue) {\n      const { package: { bin, scripts = {} } } = node.target\n      const { preinstall, install, postinstall, prepare } = scripts\n      const tests = { bin, preinstall, install, postinstall, prepare }\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node)\n        }\n      }\n    }\n    process.emit('timeEnd', 'build:queue')\n  }\n\n  async [_checkBins] (node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return\n    }\n    const { path, package: pkg } = node\n    await binLinks.checkBins({ pkg, path, top: true, global: true })\n  }\n\n  async [_addToBuildSet] (node, set, refreshed = false) {\n    if (set.has(node)) {\n      return\n    }\n\n    if (this[_oldMeta] === null) {\n      const {root: {meta}} = node\n      this[_oldMeta] = meta && meta.loadedFromDisk &&\n        !(meta.originalLockfileVersion >= 2)\n    }\n\n    const { package: pkg, hasInstallScript } = node.target\n    const { gypfile, bin, scripts = {} } = pkg\n\n    const { preinstall, install, postinstall, prepare } = scripts\n    const anyScript = preinstall || install || postinstall || prepare\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node)\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}))\n      set.delete(node)\n\n      const {scripts = {}} = pkg\n      node.package.scripts = scripts\n      return this[_addToBuildSet](node, set, true)\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false &&\n      !install &&\n      !preinstall &&\n      await isNodeGypPackage(node.path)\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node)\n      }\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript\n        node.package.scripts = scripts\n      }\n      set.add(node)\n    }\n  }\n\n  async [_runScripts] (event) {\n    const queue = this[_queues][event]\n\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', `build:run:${event}`)\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n    const limit = this.options.foregroundScripts ? 1 : undefined\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location,\n      } = node.target\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path)) {\n        return\n      }\n\n      const timer = `build:run:${event}:${location}`\n      process.emit('time', timer)\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event])\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional:\n          boolEnv(devOptional && !dev && !optional),\n      }\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell],\n      }\n      const p = runScript(runOpts).catch(er => {\n        const { code, signal } = er\n        this.log.info('run', pkg._id, event, {code, signal})\n        throw er\n      }).then(({args, code, signal, stdout, stderr}) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr,\n        })\n        this.log.info('run', pkg._id, event, {code, signal})\n      })\n\n      await (this[_doHandleOptionalFailure]\n        ? this[_handleOptionalFailure](node, p)\n        : p)\n\n      process.emit('timeEnd', timer)\n    }), limit)\n    process.emit('timeEnd', `build:run:${event}`)\n  }\n\n  async [_linkAllBins] () {\n    const queue = this[_queues].bin\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', 'build:link')\n    const promises = []\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node))\n    }\n\n    await promiseAllRejectLate(promises)\n    process.emit('timeEnd', 'build:link')\n  }\n\n  async [_createBinLinks] (node) {\n    if (this[_trashList].has(node.path)) {\n      return\n    }\n\n    process.emit('time', `build:link:${node.location}`)\n\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop,\n    })\n\n    await (this[_doHandleOptionalFailure]\n      ? this[_handleOptionalFailure](node, p)\n      : p)\n\n    process.emit('timeEnd', `build:link:${node.location}`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}