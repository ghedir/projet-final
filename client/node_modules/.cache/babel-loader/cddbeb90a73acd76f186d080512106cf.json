{"ast":null,"code":"// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js');\n\nconst envReplace = require('./env-replace.js');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  parse: umaskParse\n} = require('./umask.js');\n\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f)) return f;\n  const {\n    platform,\n    types,\n    log,\n    home,\n    env\n  } = opts; // type can be array or a single thing.  coerce to array.\n\n  const typeList = new Set([].concat(types[key]));\n  const isPath = typeList.has(typeDefs.path.type);\n  const isBool = typeList.has(typeDefs.Boolean.type);\n  const isString = isPath || typeList.has(typeDefs.String.type);\n  const isUmask = typeList.has(typeDefs.Umask.type);\n  const isNumber = typeList.has(typeDefs.Number.type);\n  const isList = !listElement && typeList.has(Array);\n  if (Array.isArray(f)) return !isList ? f : f.map(field => parseField(field, key, opts, true)); // now we know it's a string\n\n  f = f.trim(); // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n\n  if (isList) return parseField(f.split('\\n\\n'), key, opts); // --foo is like --foo=true for boolean types\n\n  if (isBool && !isString && f === '') return true; // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true':\n        return true;\n\n      case 'false':\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  f = envReplace(f, env);\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//;\n    if (homePattern.test(f) && home) f = resolve(home, f.substr(2));else f = resolve(f);\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f);\n    } catch (er) {\n      // let it warn later when we validate\n      return f;\n    }\n  }\n\n  if (isNumber && !isNaN(f)) f = +f;\n  return f;\n};\n\nmodule.exports = parseField;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/config/lib/parse-field.js"],"names":["typeDefs","require","envReplace","resolve","parse","umaskParse","parseField","f","key","opts","listElement","Array","isArray","platform","types","log","home","env","typeList","Set","concat","isPath","has","path","type","isBool","Boolean","isString","String","isUmask","Umask","isNumber","Number","isList","map","field","trim","split","undefined","homePattern","test","substr","er","isNaN","module","exports"],"mappings":"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","sourcesContent":["// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js')\nconst envReplace = require('./env-replace.js')\nconst { resolve } = require('path')\n\nconst { parse: umaskParse } = require('./umask.js')\n\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f))\n    return f\n\n  const { platform, types, log, home, env } = opts\n\n  // type can be array or a single thing.  coerce to array.\n  const typeList = new Set([].concat(types[key]))\n  const isPath = typeList.has(typeDefs.path.type)\n  const isBool = typeList.has(typeDefs.Boolean.type)\n  const isString = isPath || typeList.has(typeDefs.String.type)\n  const isUmask = typeList.has(typeDefs.Umask.type)\n  const isNumber = typeList.has(typeDefs.Number.type)\n  const isList = !listElement && typeList.has(Array)\n\n  if (Array.isArray(f))\n    return !isList ? f : f.map(field => parseField(field, key, opts, true))\n\n  // now we know it's a string\n  f = f.trim()\n\n  // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n  if (isList)\n    return parseField(f.split('\\n\\n'), key, opts)\n\n  // --foo is like --foo=true for boolean types\n  if (isBool && !isString && f === '')\n    return true\n\n  // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true': return true\n      case 'false': return false\n      case 'null': return null\n      case 'undefined': return undefined\n    }\n  }\n\n  f = envReplace(f, env)\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n    if (homePattern.test(f) && home)\n      f = resolve(home, f.substr(2))\n    else\n      f = resolve(f)\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f)\n    } catch (er) {\n      // let it warn later when we validate\n      return f\n    }\n  }\n\n  if (isNumber && !isNaN(f))\n    f = +f\n\n  return f\n}\n\nmodule.exports = parseField\n"]},"metadata":{},"sourceType":"script"}