{"ast":null,"code":"// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst semver = require('semver');\n\nconst debug = require('./debug.js');\n\nconst peerEntrySets = require('./peer-entry-sets.js');\n\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\n\nconst CONFLICT = Symbol('CONFLICT');\nconst OK = Symbol('OK');\nconst REPLACE = Symbol('REPLACE');\nconst KEEP = Symbol('KEEP');\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor(options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false\n    } = options;\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep');\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep');\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep');\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, {\n        packageName,\n        version,\n        resolved\n      }]) => {\n        return [loc, packageName, version, resolved];\n      }).sort(([a], [b]) => localeCompare(a, b)));\n    }); // the result of whether we can place it or not\n\n    this.canPlace = null; // if peers conflict, but this one doesn't, then that is useful info\n\n    this.canPlaceSelf = null;\n    this.dep = dep;\n    this.target = target;\n    this.edge = edge;\n    this.explicitRequest = explicitRequest; // preventing cycles when we check peer sets\n\n    this.peerPath = peerPath; // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n\n    this.preferDedupe = !!preferDedupe || edge.peer;\n    this.parent = parent;\n    this.children = [];\n    this.isSource = target === this.peerSetSource;\n    this.name = edge.name;\n    this.current = target.children.get(this.name);\n    this.targetEdge = target.edgesOut.get(this.name);\n    this.conflicts = new Map(); // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n\n    this.edgeOverride = !dep.satisfies(edge);\n    this.canPlace = this.checkCanPlace();\n\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace;\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()].map(([loc, {\n        packageName,\n        version,\n        resolved\n      }]) => {\n        return [loc, packageName, version, resolved];\n      }).sort(([a], [b]) => localeCompare(a, b)));\n      /* istanbul ignore if */\n\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot\n        });\n      }\n    });\n  }\n\n  checkCanPlace() {\n    const {\n      target,\n      targetEdge,\n      current,\n      dep\n    } = this; // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n\n    if (dep.errors.length) {\n      return current ? REPLACE : OK;\n    } // cannot place peers inside their dependents, except for tops\n\n\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT;\n    }\n\n    if (targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {\n      return CONFLICT;\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent();\n  } // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n\n\n  checkCanPlaceCurrent() {\n    const {\n      preferDedupe,\n      explicitRequest,\n      current,\n      target,\n      edge,\n      dep\n    } = this;\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP;\n      }\n    }\n\n    const {\n      version: curVer\n    } = current;\n    const {\n      version: newVer\n    } = dep;\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer);\n\n    if (tryReplace && dep.canReplace(current)) {\n      /* XXX-istanbul ignore else - It's extremely rare that a replaceable\n       * node would be a conflict, if the current one wasn't a conflict,\n       * but it is theoretically possible if peer deps are pinned.  In\n       * that case we treat it like any other conflict, and keep trying */\n      const cpp = this.canPlacePeers(REPLACE);\n\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    } // ok, can't replace the current with new one, but maybe current is ok?\n\n\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP;\n    } // if we prefer deduping, then try replacing newer with older\n\n\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE);\n\n      if (cpp !== CONFLICT) {\n        return cpp;\n      }\n    } // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n\n\n    const myDeepest = this.deepestNestingTarget; // ok, i COULD be placed deeper, so leave the current one alone.\n\n    if (target !== myDeepest) {\n      return CONFLICT;\n    } // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n\n\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE);\n    } // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n\n    /* istanbul ignore if - allegedly impossible */\n\n\n    if (!this.parent && !edge.peer) {\n      return CONFLICT;\n    } // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n\n\n    let canReplace = true;\n\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue;\n      } // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n\n\n      const entryNode = entryEdge.to;\n      const entryRep = dep.parent.children.get(entryNode.name);\n\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue;\n        }\n      }\n\n      let canClobber = !entryRep;\n\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode]);\n\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue;\n            }\n\n            const rep = dep.parent.children.get(edge.name);\n\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to);\n              }\n\n              continue;\n            }\n\n            if (!rep.satisfies(edge)) {\n              canClobber = false;\n              break OUTER;\n            }\n          }\n        }\n      }\n\n      if (canClobber) {\n        continue;\n      } // ok, we can't replace, but maybe we can nest the current set deeper?\n\n\n      let canNestCurrent = true;\n\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break;\n        } // still possible to nest this peerSet\n\n\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name);\n\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false;\n          canReplace = false;\n        }\n\n        if (canNestCurrent) {\n          continue;\n        }\n      }\n    } // if we can nest or replace all the current peer groups, we can replace.\n\n\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE);\n    }\n\n    return CONFLICT;\n  }\n\n  checkCanPlaceNoCurrent() {\n    const {\n      target,\n      peerEntryEdge,\n      dep,\n      name\n    } = this; // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n\n    const current = target !== peerEntryEdge.from && target.resolve(name);\n\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT;\n          }\n        }\n      }\n    } // no objections, so this is fine as long as peers are ok here.\n\n\n    return this.canPlacePeers(OK);\n  }\n\n  get deepestNestingTarget() {\n    const start = this.parent ? this.parent.deepestNestingTarget : this.edge.from;\n    return deepestNestingTarget(start, this.name);\n  }\n\n  get conflictChildren() {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT);\n  }\n\n  get allChildren() {\n    const set = new Set(this.children);\n\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n\n    return [...set];\n  }\n\n  get top() {\n    return this.parent ? this.parent.top : this;\n  } // check if peers can go here.  returns state or CONFLICT\n\n\n  canPlacePeers(state) {\n    this.canPlaceSelf = state;\n\n    if (this._canPlacePeers) {\n      return this._canPlacePeers;\n    } // TODO: represent peerPath in ERESOLVE error somehow?\n\n\n    const peerPath = [...this.peerPath, this.dep];\n    let sawConflict = false;\n\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue;\n      }\n\n      const peer = peerEdge.to; // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n\n      const target = deepestNestingTarget(this.target, peer.name);\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true\n      });\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly');\n        }\n      });\n      this.children.push(cpp);\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true;\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state;\n    return this._canPlacePeers;\n  } // what is the node that is causing this peerSet to be placed?\n\n\n  get peerSetSource() {\n    return this.parent ? this.parent.peerSetSource : this.edge.from;\n  }\n\n  get peerEntryEdge() {\n    return this.top.edge;\n  }\n\n  static get CONFLICT() {\n    return CONFLICT;\n  }\n\n  static get OK() {\n    return OK;\n  }\n\n  static get REPLACE() {\n    return REPLACE;\n  }\n\n  static get KEEP() {\n    return KEEP;\n  }\n\n  get description() {\n    const {\n      canPlace\n    } = this;\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */\n    canPlace;\n  }\n\n}\n\nmodule.exports = CanPlaceDep;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/can-place-dep.js"],"names":["localeCompare","require","semver","debug","peerEntrySets","deepestNestingTarget","CONFLICT","Symbol","OK","REPLACE","KEEP","CanPlaceDep","constructor","options","dep","target","edge","preferDedupe","parent","peerPath","explicitRequest","Error","_treeSnapshot","JSON","stringify","root","inventory","entries","map","loc","packageName","version","resolved","sort","a","b","canPlace","canPlaceSelf","peer","children","isSource","peerSetSource","name","current","get","targetEdge","edgesOut","conflicts","Map","edgeOverride","satisfies","checkCanPlace","treeSnapshot","Object","assign","expect","actual","errors","length","isTop","checkCanPlaceCurrent","checkCanPlaceNoCurrent","matches","curVer","newVer","tryReplace","gte","canReplace","cpp","canPlacePeers","myDeepest","from","entryEdge","currentPeers","peerEntryEdge","entryNode","to","entryRep","keys","canClobber","peerReplacementWalk","Set","OUTER","currentPeer","values","valid","rep","add","canNestCurrent","curDeep","isDescendantOf","resolve","edgesIn","start","conflictChildren","allChildren","filter","c","set","child","grandchild","top","state","_canPlacePeers","sawConflict","peerEdge","includes","some","push","description","module","exports"],"mappings":"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","sourcesContent":["// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst semver = require('semver')\nconst debug = require('./debug.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\n\nconst CONFLICT = Symbol('CONFLICT')\nconst OK = Symbol('OK')\nconst REPLACE = Symbol('REPLACE')\nconst KEEP = Symbol('KEEP')\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor (options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false,\n    } = options\n\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep')\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep')\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep')\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, {packageName, version, resolved}]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n    })\n\n    // the result of whether we can place it or not\n    this.canPlace = null\n    // if peers conflict, but this one doesn't, then that is useful info\n    this.canPlaceSelf = null\n\n    this.dep = dep\n    this.target = target\n    this.edge = edge\n    this.explicitRequest = explicitRequest\n\n    // preventing cycles when we check peer sets\n    this.peerPath = peerPath\n    // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n    this.preferDedupe = !!preferDedupe || edge.peer\n    this.parent = parent\n    this.children = []\n\n    this.isSource = target === this.peerSetSource\n    this.name = edge.name\n    this.current = target.children.get(this.name)\n    this.targetEdge = target.edgesOut.get(this.name)\n    this.conflicts = new Map()\n\n    // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n    this.edgeOverride = !dep.satisfies(edge)\n\n    this.canPlace = this.checkCanPlace()\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, {packageName, version, resolved}]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n      /* istanbul ignore if */\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot,\n        })\n      }\n    })\n  }\n\n  checkCanPlace () {\n    const { target, targetEdge, current, dep } = this\n\n    // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n    if (dep.errors.length) {\n      return current ? REPLACE : OK\n    }\n\n    // cannot place peers inside their dependents, except for tops\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT\n    }\n\n    if (targetEdge && !dep.satisfies(targetEdge) && targetEdge !== this.edge) {\n      return CONFLICT\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent()\n  }\n\n  // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n  checkCanPlaceCurrent () {\n    const { preferDedupe, explicitRequest, current, target, edge, dep } = this\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP\n      }\n    }\n\n    const { version: curVer } = current\n    const { version: newVer } = dep\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n    if (tryReplace && dep.canReplace(current)) {\n      /* XXX-istanbul ignore else - It's extremely rare that a replaceable\n       * node would be a conflict, if the current one wasn't a conflict,\n       * but it is theoretically possible if peer deps are pinned.  In\n       * that case we treat it like any other conflict, and keep trying */\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // ok, can't replace the current with new one, but maybe current is ok?\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP\n    }\n\n    // if we prefer deduping, then try replacing newer with older\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n    const myDeepest = this.deepestNestingTarget\n\n    // ok, i COULD be placed deeper, so leave the current one alone.\n    if (target !== myDeepest) {\n      return CONFLICT\n    }\n\n    // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n    /* istanbul ignore if - allegedly impossible */\n    if (!this.parent && !edge.peer) {\n      return CONFLICT\n    }\n\n    // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n    let canReplace = true\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue\n      }\n\n      // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n      const entryNode = entryEdge.to\n      const entryRep = dep.parent.children.get(entryNode.name)\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue\n        }\n      }\n\n      let canClobber = !entryRep\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode])\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue\n            }\n            const rep = dep.parent.children.get(edge.name)\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to)\n              }\n              continue\n            }\n            if (!rep.satisfies(edge)) {\n              canClobber = false\n              break OUTER\n            }\n          }\n        }\n      }\n      if (canClobber) {\n        continue\n      }\n\n      // ok, we can't replace, but maybe we can nest the current set deeper?\n      let canNestCurrent = true\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break\n        }\n\n        // still possible to nest this peerSet\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name)\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false\n          canReplace = false\n        }\n        if (canNestCurrent) {\n          continue\n        }\n      }\n    }\n\n    // if we can nest or replace all the current peer groups, we can replace.\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    return CONFLICT\n  }\n\n  checkCanPlaceNoCurrent () {\n    const { target, peerEntryEdge, dep, name } = this\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n    const current = target !== peerEntryEdge.from && target.resolve(name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT\n          }\n        }\n      }\n    }\n\n    // no objections, so this is fine as long as peers are ok here.\n    return this.canPlacePeers(OK)\n  }\n\n  get deepestNestingTarget () {\n    const start = this.parent ? this.parent.deepestNestingTarget\n      : this.edge.from\n    return deepestNestingTarget(start, this.name)\n  }\n\n  get conflictChildren () {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  // check if peers can go here.  returns state or CONFLICT\n  canPlacePeers (state) {\n    this.canPlaceSelf = state\n    if (this._canPlacePeers) {\n      return this._canPlacePeers\n    }\n\n    // TODO: represent peerPath in ERESOLVE error somehow?\n    const peerPath = [...this.peerPath, this.dep]\n    let sawConflict = false\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue\n      }\n      const peer = peerEdge.to\n      // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n      const target = deepestNestingTarget(this.target, peer.name)\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true,\n      })\n      /* istanbul ignore next */\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly')\n        }\n      })\n      this.children.push(cpp)\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state\n    return this._canPlacePeers\n  }\n\n  // what is the node that is causing this peerSet to be placed?\n  get peerSetSource () {\n    return this.parent ? this.parent.peerSetSource : this.edge.from\n  }\n\n  get peerEntryEdge () {\n    return this.top.edge\n  }\n\n  static get CONFLICT () {\n    return CONFLICT\n  }\n\n  static get OK () {\n    return OK\n  }\n\n  static get REPLACE () {\n    return REPLACE\n  }\n\n  static get KEEP () {\n    return KEEP\n  }\n\n  get description () {\n    const { canPlace } = this\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */ canPlace\n  }\n}\n\nmodule.exports = CanPlaceDep\n"]},"metadata":{},"sourceType":"script"}