{"ast":null,"code":"// Given a set of nodes in a tree, and a filter function to test\n// incoming edges to the dep set that should be ignored otherwise.\n//\n// find the set of deps that are only depended upon by nodes in the set, or\n// their dependencies, or edges that are ignored.\n//\n// Used when figuring out what to prune when replacing a node with a newer\n// version, or when an optional dep fails to install.\nconst gatherDepSet = (set, edgeFilter) => {\n  const deps = new Set(set); // add the full set of dependencies.  note that this loop will continue\n  // as the deps set increases in size.\n\n  for (const node of deps) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.to && edgeFilter(edge)) {\n        deps.add(edge.to);\n      }\n    }\n  } // now remove all nodes in the set that have a dependant outside the set\n  // if any change is made, then re-check\n  // continue until no changes made, or deps set evaporates fully.\n\n\n  let changed = true;\n\n  while (changed === true && deps.size > 0) {\n    changed = false;\n\n    for (const dep of deps) {\n      for (const edge of dep.edgesIn) {\n        if (!deps.has(edge.from) && edgeFilter(edge)) {\n          changed = true;\n          deps.delete(dep);\n          break;\n        }\n      }\n    }\n  }\n\n  return deps;\n};\n\nmodule.exports = gatherDepSet;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/gather-dep-set.js"],"names":["gatherDepSet","set","edgeFilter","deps","Set","node","edge","edgesOut","values","to","add","changed","size","dep","edgesIn","has","from","delete","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,YAAY,GAAG,CAACC,GAAD,EAAMC,UAAN,KAAqB;AACxC,QAAMC,IAAI,GAAG,IAAIC,GAAJ,CAAQH,GAAR,CAAb,CADwC,CAGxC;AACA;;AACA,OAAK,MAAMI,IAAX,IAAmBF,IAAnB,EAAyB;AACvB,SAAK,MAAMG,IAAX,IAAmBD,IAAI,CAACE,QAAL,CAAcC,MAAd,EAAnB,EAA2C;AACzC,UAAIF,IAAI,CAACG,EAAL,IAAWP,UAAU,CAACI,IAAD,CAAzB,EAAiC;AAC/BH,QAAAA,IAAI,CAACO,GAAL,CAASJ,IAAI,CAACG,EAAd;AACD;AACF;AACF,GAXuC,CAaxC;AACA;AACA;;;AACA,MAAIE,OAAO,GAAG,IAAd;;AACA,SAAOA,OAAO,KAAK,IAAZ,IAAoBR,IAAI,CAACS,IAAL,GAAY,CAAvC,EAA0C;AACxCD,IAAAA,OAAO,GAAG,KAAV;;AACA,SAAK,MAAME,GAAX,IAAkBV,IAAlB,EAAwB;AACtB,WAAK,MAAMG,IAAX,IAAmBO,GAAG,CAACC,OAAvB,EAAgC;AAC9B,YAAI,CAACX,IAAI,CAACY,GAAL,CAAST,IAAI,CAACU,IAAd,CAAD,IAAwBd,UAAU,CAACI,IAAD,CAAtC,EAA8C;AAC5CK,UAAAA,OAAO,GAAG,IAAV;AACAR,UAAAA,IAAI,CAACc,MAAL,CAAYJ,GAAZ;AACA;AACD;AACF;AACF;AACF;;AAED,SAAOV,IAAP;AACD,CA/BD;;AAiCAe,MAAM,CAACC,OAAP,GAAiBnB,YAAjB","sourcesContent":["// Given a set of nodes in a tree, and a filter function to test\n// incoming edges to the dep set that should be ignored otherwise.\n//\n// find the set of deps that are only depended upon by nodes in the set, or\n// their dependencies, or edges that are ignored.\n//\n// Used when figuring out what to prune when replacing a node with a newer\n// version, or when an optional dep fails to install.\n\nconst gatherDepSet = (set, edgeFilter) => {\n  const deps = new Set(set)\n\n  // add the full set of dependencies.  note that this loop will continue\n  // as the deps set increases in size.\n  for (const node of deps) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.to && edgeFilter(edge)) {\n        deps.add(edge.to)\n      }\n    }\n  }\n\n  // now remove all nodes in the set that have a dependant outside the set\n  // if any change is made, then re-check\n  // continue until no changes made, or deps set evaporates fully.\n  let changed = true\n  while (changed === true && deps.size > 0) {\n    changed = false\n    for (const dep of deps) {\n      for (const edge of dep.edgesIn) {\n        if (!deps.has(edge.from) && edgeFilter(edge)) {\n          changed = true\n          deps.delete(dep)\n          break\n        }\n      }\n    }\n  }\n\n  return deps\n}\n\nmodule.exports = gatherDepSet\n"]},"metadata":{},"sourceType":"script"}