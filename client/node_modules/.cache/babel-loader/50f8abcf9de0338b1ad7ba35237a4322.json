{"ast":null,"code":"// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\nconst semver = require('semver');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst Edge = require('./edge.js');\n\nconst Inventory = require('./inventory.js');\n\nconst {\n  normalize\n} = require('read-package-json-fast');\n\nconst {\n  getPaths: getBinPaths\n} = require('bin-links');\n\nconst npa = require('npm-package-arg');\n\nconst debug = require('./debug.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst treeCheck = require('./tree-check.js');\n\nconst walkUp = require('walk-up-path');\n\nconst {\n  resolve,\n  relative,\n  dirname,\n  basename\n} = require('path');\n\nconst util = require('util');\n\nconst _package = Symbol('_package');\n\nconst _parent = Symbol('_parent');\n\nconst _target = Symbol.for('_target');\n\nconst _fsParent = Symbol('_fsParent');\n\nconst _loadDepType = Symbol('_loadDepType');\n\nconst _loadWorkspaces = Symbol('_loadWorkspaces');\n\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges'); // overridden by Link class\n\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _root = Symbol('_root');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nconst _changePath = Symbol.for('_changePath'); // used by Link class as well\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _global = Symbol.for('global');\n\nconst _workspaces = Symbol('_workspaces');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst _meta = Symbol('_meta');\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst printableTree = require('./printable.js');\n\nconst CaseInsensitiveMap = require('./case-insensitive-map.js');\n\nclass Node {\n  constructor(options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null\n    } = options; // true if part of a global install\n\n    this[_global] = global;\n    this[_workspaces] = null;\n    this.errors = error ? [error] : []; // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n\n    this.sourceReference = sourceReference;\n    const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});\n    this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null; // should be equal if not a link\n\n    this.path = path ? resolve(path) : null;\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package');\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath);\n    this.resolved = resolved || null;\n\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved);\n\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved;\n      }\n    }\n\n    this.integrity = integrity || pkg._integrity || null;\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this.children = new CaseInsensitiveMap();\n    this.fsChildren = new Set();\n    this.inventory = new Inventory({});\n    this.tops = new Set();\n    this.linksIn = new Set(linksIn || []); // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n\n    if (!dummy) {\n      this.dev = dev;\n      this.optional = optional;\n      this.devOptional = devOptional;\n      this.peer = peer;\n      this.extraneous = extraneous;\n      this.dummy = false;\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true;\n      this.dev = false;\n      this.optional = false;\n      this.devOptional = false;\n      this.peer = false;\n      this.extraneous = false;\n    }\n\n    this.edgesIn = new Set();\n    this.edgesOut = new CaseInsensitiveMap(); // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}; // only relevant for the root and top nodes\n\n    this.meta = meta; // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n    // will also assign root if present on the parent\n\n    this[_parent] = null;\n    this.parent = parent || null;\n    this[_fsParent] = null;\n    this.fsParent = fsParent || null; // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n\n    if (!parent && !fsParent) {\n      this.root = root || null;\n    } // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n\n\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c,\n          parent: this\n        });\n      }\n    }\n\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c,\n          fsParent: this\n        });\n      }\n    } // now load all the dep edges\n\n\n    this[_loadDeps]();\n  }\n\n  get meta() {\n    return this[_meta];\n  }\n\n  set meta(meta) {\n    this[_meta] = meta;\n\n    if (meta) {\n      meta.add(this);\n    }\n  }\n\n  get global() {\n    return this.root[_global];\n  } // true for packages installed directly in the global node_modules folder\n\n\n  get globalTop() {\n    return this.global && this.parent && this.parent.isProjectRoot;\n  }\n\n  get workspaces() {\n    return this[_workspaces];\n  }\n\n  set workspaces(workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach();\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps]();\n  }\n\n  get binPaths() {\n    if (!this.parent) {\n      return [];\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop\n    });\n  }\n\n  get hasInstallScript() {\n    const {\n      hasInstallScript,\n      scripts\n    } = this.package;\n    const {\n      install,\n      preinstall,\n      postinstall\n    } = scripts || {};\n    return !!(hasInstallScript || install || preinstall || postinstall);\n  }\n\n  get version() {\n    return this[_package].version || '';\n  }\n\n  get packageName() {\n    return this[_package].name || null;\n  }\n\n  get pkgid() {\n    const {\n      name = '',\n      version = ''\n    } = this.package; // root package will prefer package name over folder name,\n    // and never be called an alias.\n\n    const {\n      isProjectRoot\n    } = this;\n    const myname = isProjectRoot ? name || this.name : this.name;\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : '';\n    return `${myname}@${alias}${version}`;\n  }\n\n  get package() {\n    return this[_package];\n  }\n\n  set package(pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach();\n    }\n\n    this[_explanation] = null;\n    /* istanbul ignore next - should be impossible */\n\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object');\n      });\n      pkg = {};\n    }\n\n    this[_package] = pkg;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps](); // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n\n\n    this.edgesIn.forEach(edge => edge.reload(true));\n  } // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n\n\n  explain(edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation];\n    }\n\n    return this[_explanation] = this[_explain](edge, seen);\n  }\n\n  [_explain](edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path\n      };\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version\n    };\n\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [new Error('invalid package: lacks name and/or version')];\n      why.package = this.package;\n    }\n\n    if (this.root.sourceReference) {\n      const {\n        name,\n        version\n      } = this.root.package;\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path\n      };\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen);\n    }\n\n    if (seen.includes(this)) {\n      return why;\n    }\n\n    why.location = this.location;\n    why.isWorkspace = this.isWorkspace; // make a new list each time.  we can revisit, but not loop.\n\n    seen = seen.concat(this);\n    why.dependents = [];\n\n    if (edge) {\n      why.dependents.push(edge.explain(seen));\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = [];\n\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue;\n        }\n\n        edges.push(edge);\n      }\n\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen));\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen));\n    }\n\n    return why;\n  }\n\n  isDescendantOf(node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getBundler(path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null;\n    }\n\n    path.push(this);\n    const parent = this[_parent];\n\n    if (!parent) {\n      return null;\n    }\n\n    const pBundler = parent.getBundler(path);\n\n    if (pBundler) {\n      return pBundler;\n    }\n\n    const ppkg = parent.package;\n    const bd = ppkg && ppkg.bundleDependencies; // explicit bundling\n\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent;\n    } // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n\n\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path);\n\n      if (!eBundler) {\n        continue;\n      }\n\n      if (eBundler === parent) {\n        return eBundler;\n      }\n    }\n\n    return null;\n  }\n\n  get inBundle() {\n    return !!this.getBundler();\n  } // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n\n\n  get inDepBundle() {\n    const bundler = this.getBundler();\n    return !!bundler && bundler !== this.root;\n  }\n\n  get isWorkspace() {\n    if (this.isProjectRoot) {\n      return false;\n    }\n\n    const {\n      root\n    } = this;\n    const {\n      type,\n      to\n    } = root.edgesOut.get(this.packageName) || {};\n    return type === 'workspace' && to && (to.target === this || to === this);\n  }\n\n  get isRoot() {\n    return this === this.root;\n  }\n\n  get isProjectRoot() {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target;\n  }\n\n  *ancestry() {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc;\n    }\n  }\n\n  set root(root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root;\n    }\n\n    root = root || this; // delete from current root inventory\n\n    this[_delistFromMeta](); // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n\n\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root;\n    } // temporarily become a root node\n\n\n    this[_root] = this; // break all linksIn, we're going to re-set them if needed later\n\n    for (const link of this.linksIn) {\n      link[_target] = null;\n      this.linksIn.delete(link);\n    } // temporarily break this link as well, we'll re-set if possible later\n\n\n    const {\n      target\n    } = this;\n\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this);\n\n        if (target.root === this) {\n          target[_delistFromMeta]();\n        }\n      }\n\n      this[_target] = null;\n    } // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n\n\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    if (root === this) {\n      this[_refreshLocation]();\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path);\n      const current = root.inventory.get(loc); // clobber whatever is there now\n\n      if (current) {\n        current.root = null;\n      }\n\n      this[_root] = root; // set this.location and add to inventory\n\n      this[_refreshLocation](); // try to find our parent/fsParent in the new root inventory\n\n\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue;\n        }\n\n        const ploc = relpath(root.realpath, p);\n        const parent = root.inventory.get(ploc);\n\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath\n              });\n            });\n            continue;\n          }\n\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`;\n          const isParent = this.location === childLoc;\n\n          if (isParent) {\n            const oldChild = parent.children.get(this.name);\n\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null;\n            }\n\n            if (this.parent) {\n              this.parent.children.delete(this.name);\n\n              this.parent[_reloadNamedEdges](this.name);\n            }\n\n            parent.children.set(this.name, this);\n            this[_parent] = parent; // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name);\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this);\n            }\n\n            parent.fsChildren.add(this);\n            this[_fsParent] = parent;\n          }\n\n          break;\n        }\n      } // if it doesn't have a parent, it's a top node\n\n\n      if (!this.parent) {\n        root.tops.add(this);\n      } else {\n        root.tops.delete(this);\n      } // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n\n\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`;\n\n      const isChild = n => n.location === nmloc + n.name; // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n\n\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path));\n      };\n\n      const isKid = n => isChild(n) || isFsChild(n); // only walk top nodes, since anything else already has a parent.\n\n\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue;\n        } // set up the internal parentage links\n\n\n        if (this.isLink) {\n          child.root = null;\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child);\n          }\n\n          child[_fsParent] = null;\n\n          if (isChild(child)) {\n            this.children.set(child.name, child);\n            child[_parent] = this;\n            root.tops.delete(child);\n          } else {\n            this.fsChildren.add(child);\n            child[_fsParent] = this;\n          }\n        }\n      } // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n\n\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue;\n        }\n        /* istanbul ignore next - should be impossible */\n\n\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root');\n          }\n        });\n\n        if (this.isLink) {\n          const target = node.target;\n          this[_target] = target;\n          this[_package] = target.package;\n          target.linksIn.add(this); // reload edges here, because now we have a target\n\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name);\n          }\n\n          break;\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this;\n            node[_package] = this.package;\n            this.linksIn.add(node);\n\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name);\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath\n              });\n            });\n          }\n        }\n      }\n    } // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n\n\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload();\n      }\n    } // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n\n\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload();\n      }\n    } // now make sure our family comes along for the ride!\n\n\n    const family = new Set([...this.fsChildren, ...this.children.values(), ...this.inventory.values()].filter(n => n !== this));\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]();\n\n        child[_parent] = null;\n        this.children.delete(child.name);\n        child[_fsParent] = null;\n        this.fsChildren.delete(child);\n\n        for (const l of child.linksIn) {\n          l[_target] = null;\n          child.linksIn.delete(l);\n        }\n      }\n    }\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root;\n      }\n    } // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n\n\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root;\n    } // tree should always be valid upon root setter completion.\n\n\n    treeCheck(this);\n    treeCheck(root);\n  }\n\n  get root() {\n    return this[_root] || this;\n  }\n\n  [_loadWorkspaces]() {\n    if (!this[_workspaces]) {\n      return;\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({\n        from: this,\n        name,\n        spec: `file:${path}`,\n        type: 'workspace'\n      });\n    }\n  }\n\n  [_loadDeps]() {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies;\n\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {};\n      const peerDependencies = {};\n      const peerOptional = {};\n\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep;\n        } else {\n          peerDependencies[name] = dep;\n        }\n      }\n\n      this[_loadDepType](peerDependencies, 'peer');\n\n      this[_loadDepType](peerOptional, 'peerOptional');\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod');\n\n    this[_loadDepType](this.package.optionalDependencies, 'optional');\n\n    const {\n      globalTop,\n      isTop,\n      path,\n      sourceReference\n    } = this;\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath\n    } = sourceReference || {};\n    const thisDev = isTop && !globalTop && path;\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath;\n\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev');\n    }\n  }\n\n  [_loadDepType](deps, type) {\n    const ad = this.package.acceptDependencies || {}; // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name);\n\n      if (!current || current.type !== 'workspace') {\n        new Edge({\n          from: this,\n          name,\n          spec,\n          accept: ad[name],\n          type\n        });\n      }\n    }\n  }\n\n  get fsParent() {\n    const parent = this[_fsParent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent');\n      }\n    });\n    return parent;\n  }\n\n  set fsParent(fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null;\n      }\n\n      return;\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent');\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path');\n      } // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n\n\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath\n          }\n        });\n      }\n    });\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target;\n    } // setting a thing to its own fsParent is not normal, but no-op for safety\n\n\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return;\n    } // nothing to do\n\n\n    if (this[_fsParent] === fsParent) {\n      return;\n    }\n\n    const oldFsParent = this[_fsParent];\n    const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name); // this is actually the parent, set that instead\n\n    if (newPath === nmPath) {\n      this.parent = fsParent;\n      return;\n    }\n\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    const oldParent = this.parent;\n    const oldName = this.name;\n\n    if (this.parent) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) {\n      this[_changePath](newPath);\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName);\n    } // clobbers anything at that path, resets all appropriate references\n\n\n    this.root = fsParent.root;\n  } // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n\n\n  canReplaceWith(node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false;\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false;\n    }\n\n    ignorePeers = new Set(ignorePeers); // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid);\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop && edge.from.parent === this.parent && edge.peer && ignorePeers.has(edge.from.name);\n\n      if (ignored) {\n        continue;\n      } // only care about edges that don't originate from this node\n\n\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canReplace(node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers);\n  } // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n\n\n  canDedupe(preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false;\n    } // it's a top level pkg, or a dep of one\n\n\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false;\n    } // no one wants it, remove it\n\n\n    if (this.edgesIn.size === 0) {\n      return true;\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name); // nothing else, need this one\n\n    if (!other) {\n      return false;\n    } // if it's the same thing, then always fine to remove\n\n\n    if (other.matches(this)) {\n      return true;\n    } // if the other thing can't replace this, then skip it\n\n\n    if (!other.canReplace(this)) {\n      return false;\n    } // if we prefer dedupe, or if the version is greater/equal, take the other\n\n\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  satisfies(requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this);\n    }\n\n    const parsed = npa(requested);\n    const {\n      name = this.name,\n      rawSpec: spec\n    } = parsed;\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({\n        path: this.root.realpath\n      }),\n      type: 'prod',\n      name,\n      spec\n    }));\n  }\n\n  matches(node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true;\n    } // if the names don't match, they're different things, even if\n    // the package contents are identical.\n\n\n    if (node.name !== this.name) {\n      return false;\n    } // if they're links, they match if the targets match\n\n\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target);\n    } // if they're two project root nodes, they're different if the paths differ\n\n\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path;\n    } // if the integrity matches, then they're the same.\n\n\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity;\n    } // if no integrity, check resolved\n\n\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved;\n    } // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n\n\n    return this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version;\n  } // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n\n\n  replaceWith(node) {\n    node.replace(this);\n  }\n\n  replace(node) {\n    this[_delistFromMeta](); // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n\n\n    const nameMatch = node.parent && node.parent.children.get(this.name) === node;\n\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name);\n    } else {\n      this.path = node.path;\n      this.name = node.name;\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path;\n    }\n\n    this[_refreshLocation](); // keep children when a node replaces another\n\n\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this;\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root;\n    }\n\n    treeCheck(this);\n  }\n\n  get inShrinkwrap() {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);\n  }\n\n  get parent() {\n    const parent = this[_parent];\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent');\n      }\n    });\n    return parent;\n  } // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n\n\n  set parent(parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null;\n      }\n\n      return;\n    }\n\n    if (parent.isLink) {\n      parent = parent.target;\n    } // setting a thing to its own parent is not normal, but no-op for safety\n\n\n    if (this === parent) {\n      return;\n    }\n\n    const oldParent = this[_parent]; // nothing to do\n\n    if (oldParent === parent) {\n      return;\n    } // ok now we know something is actually changing, and parent is not a link\n\n\n    const newPath = resolve(parent.path, 'node_modules', this.name);\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    if (oldParent) {\n      oldParent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) {\n      this[_changePath](newPath);\n    } // clobbers anything at that path, resets all appropriate references\n\n\n    this.root = parent.root;\n  } // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n\n\n  [_delistFromMeta]() {\n    const root = this.root;\n\n    if (!root.realpath || !this.path) {\n      return;\n    }\n\n    root.inventory.delete(this);\n    root.tops.delete(this);\n\n    if (root.meta) {\n      root.meta.delete(this.path);\n    }\n    /* istanbul ignore next - should be impossible */\n\n\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist');\n      }\n    });\n  } // update this.path/realpath and the paths of all children/fsChildren\n\n\n  [_changePath](newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]();\n\n    const oldPath = this.path;\n    this.path = newPath;\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/;\n    const nameChange = newPath.match(namePattern);\n\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/');\n    } // if we move a link target, update link realpaths\n\n\n    if (!this.isLink) {\n      this.realpath = newPath;\n\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]();\n\n        link.realpath = newPath;\n\n        link[_refreshLocation]();\n      }\n    } // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n\n\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)));\n    }\n\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name));\n    }\n\n    this[_refreshLocation]();\n  } // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n\n\n  [_refreshLocation]() {\n    const root = this.root;\n    const loc = relpath(root.realpath, this.path);\n    this.location = loc;\n    root.inventory.add(this);\n\n    if (root.meta) {\n      root.meta.add(this);\n    }\n  }\n\n  addEdgeOut(edge) {\n    this.edgesOut.set(edge.name, edge);\n  }\n\n  addEdgeIn(edge) {\n    this.edgesIn.add(edge); // try to get metadata from the yarn.lock file\n\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge);\n    }\n  }\n\n  [_reloadNamedEdges](name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name); // if we don't have an edge, do nothing, but keep descending\n\n    const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;\n    const sameResolved = edge && this.resolve(name) === edge.to;\n    const recheck = rootLocResolved || !sameResolved;\n\n    if (edge && recheck) {\n      edge.reload(true);\n    }\n\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc);\n    }\n  }\n\n  get isLink() {\n    return false;\n  }\n\n  get target() {\n    return this;\n  }\n\n  set target(n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path\n      });\n    });\n  }\n\n  get depth() {\n    return this.isTop ? 0 : this.parent.depth + 1;\n  }\n\n  get isTop() {\n    return !this.parent || this.globalTop;\n  }\n\n  get top() {\n    return this.isTop ? this : this.parent.top;\n  }\n\n  get isFsTop() {\n    return !this.fsParent;\n  }\n\n  get fsTop() {\n    return this.isFsTop ? this : this.fsParent.fsTop;\n  }\n\n  get resolveParent() {\n    return this.parent || this.fsParent;\n  }\n\n  resolve(name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve');\n      }\n    });\n    const mine = this.children.get(name);\n\n    if (mine) {\n      return mine;\n    }\n\n    const resolveParent = this.resolveParent;\n\n    if (resolveParent) {\n      return resolveParent.resolve(name);\n    }\n\n    return null;\n  }\n\n  inNodeModules() {\n    const rp = this.realpath;\n    const name = this.name;\n    const scoped = name.charAt(0) === '@';\n    const d = dirname(rp);\n    const nm = scoped ? dirname(d) : d;\n    const dir = dirname(nm);\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);\n    return base === name && basename(nm) === 'node_modules' ? dir : false;\n  }\n\n  toJSON() {\n    return printableTree(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Node;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js"],"names":["semver","require","nameFromFolder","Edge","Inventory","normalize","getPaths","getBinPaths","npa","debug","gatherDepSet","treeCheck","walkUp","resolve","relative","dirname","basename","util","_package","Symbol","_parent","_target","for","_fsParent","_loadDepType","_loadWorkspaces","_reloadNamedEdges","_loadDeps","_root","_refreshLocation","_changePath","_delistFromMeta","_global","_workspaces","_explain","_explanation","_meta","relpath","consistentResolve","printableTree","CaseInsensitiveMap","Node","constructor","options","root","path","realpath","parent","error","meta","fsParent","resolved","integrity","name","children","fsChildren","legacyPeerDeps","linksIn","hasShrinkwrap","extraneous","dev","optional","devOptional","peer","global","dummy","sourceReference","errors","pkg","package","TypeError","isLink","_resolved","test","_where","_integrity","_hasShrinkwrap","Set","inventory","tops","edgesIn","edgesOut","c","add","globalTop","isProjectRoot","workspaces","keys","has","get","detach","binPaths","top","hasInstallScript","scripts","install","preinstall","postinstall","version","packageName","pkgid","myname","alias","edge","values","Error","forEach","reload","explain","seen","location","why","isTop","length","whileInstalling","includes","isWorkspace","concat","dependents","push","edges","valid","from","size","map","link","isDescendantOf","node","p","resolveParent","getBundler","pBundler","ppkg","bd","bundleDependencies","Array","isArray","eBundler","inBundle","inDepBundle","bundler","type","to","target","isRoot","ancestry","anc","delete","loc","current","ploc","Object","assign","parentReal","childLoc","isParent","oldChild","set","nmloc","isChild","n","isFsChild","startsWith","isKid","child","query","family","filter","l","entries","spec","pd","peerDependencies","pm","peerDependenciesMeta","peerOptional","dep","dependencies","optionalDependencies","srcGlobalTop","srcTop","srcPath","thisDev","srcDev","devDependencies","deps","ad","acceptDependencies","accept","indexOf","oldFsParent","newPath","nmPath","pathChange","oldParent","oldName","canReplaceWith","ignorePeers","depSet","e","ignored","satisfiedBy","canReplace","canDedupe","preferDedupe","inShrinkwrap","other","matches","gte","satisfies","requested","parsed","rawSpec","replaceWith","replace","nameMatch","kid","oldPath","namePattern","nameChange","match","addEdgeOut","addEdgeIn","addEdge","rootLoc","rootLocResolved","sameResolved","recheck","depth","isFsTop","fsTop","mine","inNodeModules","rp","scoped","charAt","d","nm","dir","base","toJSON","inspect","custom","module","exports"],"mappings":"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","sourcesContent":["// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver')\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst {normalize} = require('read-package-json-fast')\nconst {getPaths: getBinPaths} = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst {resolve, relative, dirname, basename} = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\nconst CaseInsensitiveMap = require('./case-insensitive-map.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package')\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved\n      }\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new CaseInsensitiveMap()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new CaseInsensitiveMap()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent) {\n      this.root = root || null\n    }\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c, parent: this })\n      }\n    }\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c, fsParent: this })\n      }\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta) {\n      meta.add(this)\n    }\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach()\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent) {\n      return []\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const {hasInstallScript, scripts} = this.package\n    const {install, preinstall, postinstall} = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get packageName () {\n    return this[_package].name || null\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach()\n    }\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const {name, version} = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen)\n    }\n\n    if (seen.includes(this)) {\n      return why\n    }\n\n    why.location = this.location\n    why.isWorkspace = this.isWorkspace\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge) {\n      why.dependents.push(edge.explain(seen))\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue\n        }\n\n        edges.push(edge)\n      }\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen))\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen))\n    }\n\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true\n      }\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null\n    }\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent) {\n      return null\n    }\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler) {\n      return pBundler\n    }\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent\n    }\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler) {\n        continue\n      }\n\n      if (eBundler === parent) {\n        return eBundler\n      }\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot) {\n      return false\n    }\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.packageName) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target\n  }\n\n  * ancestry () {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc\n    }\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root\n    }\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root\n    }\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this) {\n          target[_delistFromMeta]()\n        }\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this) {\n      this[_refreshLocation]()\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current) {\n        current.root = null\n      }\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue\n        }\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null\n            }\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name)\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this)\n            }\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent) {\n        root.tops.add(this)\n      } else {\n        root.tops.delete(this)\n      }\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) &&\n          n !== this &&\n          !n.parent &&\n          (!n.fsParent ||\n            n.fsParent === this ||\n            dirname(this.path).startsWith(n.fsParent.path))\n      }\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue\n        }\n\n        // set up the internal parentage links\n        if (this.isLink) {\n          child.root = null\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child)\n          }\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue\n        }\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root')\n          }\n        })\n\n        if (this.isLink) {\n          const target = node.target\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name)\n          }\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name)\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload()\n      }\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload()\n      }\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root\n      }\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root\n    }\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces]) {\n      return\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({ from: this, name, spec: `file:${path}`, type: 'workspace' })\n    }\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep\n        } else {\n          peerDependencies[name] = dep\n        }\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    const { globalTop, isTop, path, sourceReference } = this\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath,\n    } = sourceReference || {}\n    const thisDev = isTop && !globalTop && path\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev')\n    }\n  }\n\n  [_loadDepType] (deps, type) {\n    const ad = this.package.acceptDependencies || {}\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name)\n      if (!current || current.type !== 'workspace') {\n        new Edge({ from: this, name, spec, accept: ad[name], type })\n      }\n    }\n  }\n\n  get fsParent () {\n    const parent = this[_fsParent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent')\n      }\n    })\n    return parent\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null\n      }\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent')\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path')\n      }\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target\n    }\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return\n    }\n\n    // nothing to do\n    if (this[_fsParent] === fsParent) {\n      return\n    }\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false\n    }\n\n    ignorePeers = new Set(ignorePeers)\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop &&\n        edge.from.parent === this.parent &&\n        edge.peer &&\n        ignorePeers.has(edge.from.name)\n      if (ignored) {\n        continue\n      }\n\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  canReplace (node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers)\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe (preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false\n    }\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false\n    }\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0) {\n      return true\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name)\n\n    // nothing else, need this one\n    if (!other) {\n      return false\n    }\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this)) {\n      return true\n    }\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this)) {\n      return false\n    }\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true\n    }\n\n    return false\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this)\n    }\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true\n    }\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name) {\n      return false\n    }\n\n    // if they're links, they match if the targets match\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target)\n    }\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path\n    }\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity\n    }\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved\n    }\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName &&\n      this.packageName === node.packageName &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n\n    // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n    const nameMatch = node.parent &&\n      node.parent.children.get(this.name) === node\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name)\n    } else {\n      this.path = node.path\n      this.name = node.name\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path\n    }\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root\n    }\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent &&\n      (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    const parent = this[_parent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent')\n      }\n    })\n    return parent\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null\n      }\n      return\n    }\n\n    if (parent.isLink) {\n      parent = parent.target\n    }\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent) {\n      return\n    }\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent) {\n      return\n    }\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path) {\n      return\n    }\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta) {\n      root.meta.delete(this.path)\n    }\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist')\n      }\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n    }\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    }\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name))\n    }\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta) {\n      root.meta.add(this)\n    }\n  }\n\n  addEdgeOut (edge) {\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge)\n    }\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck) {\n      edge.reload(true)\n    }\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return this\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent || this.globalTop\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get isFsTop () {\n    return !this.fsParent\n  }\n\n  get fsTop () {\n    return this.isFsTop ? this : this.fsParent.fsTop\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve')\n      }\n    })\n    const mine = this.children.get(name)\n    if (mine) {\n      return mine\n    }\n    const resolveParent = this.resolveParent\n    if (resolveParent) {\n      return resolveParent.resolve(name)\n    }\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n"]},"metadata":{},"sourceType":"script"}