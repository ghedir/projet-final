{"ast":null,"code":"const {\n  resolve,\n  relative,\n  sep\n} = require('path');\n\nconst relativePrefix = `.${sep}`;\n\nconst {\n  EOL\n} = require('os');\n\nconst archy = require('archy');\n\nconst chalk = require('chalk');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst {\n  breadth\n} = require('treeverse');\n\nconst npa = require('npm-package-arg');\n\nconst completion = require('./utils/completion/installed-deep.js');\n\nconst _depth = Symbol('depth');\n\nconst _dedupe = Symbol('dedupe');\n\nconst _filteredBy = Symbol('filteredBy');\n\nconst _include = Symbol('include');\n\nconst _invalid = Symbol('invalid');\n\nconst _name = Symbol('name');\n\nconst _missing = Symbol('missing');\n\nconst _parent = Symbol('parent');\n\nconst _problems = Symbol('problems');\n\nconst _required = Symbol('required');\n\nconst _type = Symbol('type');\n\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nclass LS extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'List installed packages';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'ls';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[[<@scope>/]<pkg> ...]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['all', 'json', 'long', 'parseable', 'global', 'depth', 'omit', 'link', 'package-lock-only', 'unicode', ...super.params];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n\n  exec(args, cb) {\n    this.ls(args).then(() => cb()).catch(cb);\n  }\n\n  async ls(args) {\n    const all = this.npm.config.get('all');\n    const color = this.npm.color;\n    const depth = this.npm.config.get('depth');\n    const dev = this.npm.config.get('dev');\n    const development = this.npm.config.get('development');\n    const global = this.npm.config.get('global');\n    const json = this.npm.config.get('json');\n    const link = this.npm.config.get('link');\n    const long = this.npm.config.get('long');\n    const only = this.npm.config.get('only');\n    const parseable = this.npm.config.get('parseable');\n    const prod = this.npm.config.get('prod');\n    const production = this.npm.config.get('production');\n    const unicode = this.npm.config.get('unicode');\n    const packageLockOnly = this.npm.config.get('package-lock-only');\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix;\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path\n    });\n    const tree = await this.initTree({\n      arb,\n      args,\n      packageLockOnly\n    }); // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n\n    let wsNodes;\n    if (this.workspaceNames && this.workspaceNames.length) wsNodes = arb.workspaceNodes(tree, this.workspaceNames);\n\n    const filterBySelectedWorkspaces = edge => {\n      if (!wsNodes || !wsNodes.length) return true;\n\n      if (edge.from.isProjectRoot) {\n        return edge.to && edge.to.isWorkspace & wsNodes.includes(edge.to.target);\n      }\n\n      return true;\n    };\n\n    const seenItems = new Set();\n    const seenNodes = new Map();\n    const problems = new Set(); // defines special handling of printed depth when filtering with args\n\n    const filterDefaultDepth = depth === null ? Infinity : depth;\n    const depthToPrint = all || args.length ? filterDefaultDepth : depth || 0; // add root node of tree to list of seenNodes\n\n    seenNodes.set(tree.path, tree); // tree traversal happens here, using treeverse.breadth\n\n    const result = await breadth({\n      tree,\n\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren(node, nodeResult) {\n        const seenPaths = new Set();\n        const workspace = node.isWorkspace;\n        const currentDepth = workspace ? 0 : node[_depth];\n        const shouldSkipChildren = !(node instanceof Arborist.Node) || currentDepth > depthToPrint;\n        return shouldSkipChildren ? [] : [...node.target.edgesOut.values()].filter(filterBySelectedWorkspaces).filter(filterByEdgesTypes({\n          currentDepth,\n          dev,\n          development,\n          link,\n          prod,\n          production,\n          only\n        })).map(mapEdgesToNodes({\n          seenPaths\n        })).concat(appendExtraneousChildren({\n          node,\n          seenPaths\n        })).sort(sortAlphabetically).map(augmentNodesWithMetadata({\n          args,\n          currentDepth,\n          nodeResult,\n          seenNodes\n        }));\n      },\n\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit(node) {\n        node[_problems] = getProblems(node, {\n          global\n        });\n        const item = json ? getJsonOutputItem(node, {\n          global,\n          long\n        }) : parseable ? null : getHumanOutputItem(node, {\n          args,\n          color,\n          global,\n          long\n        }); // loop through list of node problems to add them to global list\n\n        if (node[_include]) {\n          for (const problem of node[_problems]) problems.add(problem);\n        }\n\n        seenItems.add(item); // return a promise so we don't blow the stack\n\n        return Promise.resolve(item);\n      }\n\n    }); // handle the special case of a broken package.json in the root folder\n\n    const [rootError] = tree.errors.filter(e => e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'));\n    this.npm.output(json ? jsonOutput({\n      path,\n      problems,\n      result,\n      rootError,\n      seenItems\n    }) : parseable ? parseableOutput({\n      seenNodes,\n      global,\n      long\n    }) : humanOutput({\n      color,\n      result,\n      seenItems,\n      unicode\n    })); // if filtering items, should exit with error code on no results\n\n    if (result && !result[_include] && args.length) process.exitCode = 1;\n\n    if (rootError) {\n      throw Object.assign(new Error('Failed to parse root package.json'), {\n        code: 'EJSONPARSE'\n      });\n    }\n\n    const shouldThrow = problems.size && ![...problems].every(problem => problem.startsWith('extraneous:'));\n\n    if (shouldThrow) {\n      throw Object.assign(new Error([...problems].join(EOL)), {\n        code: 'ELSPROBLEMS'\n      });\n    }\n  }\n\n  async initTree({\n    arb,\n    args,\n    packageLockOnly\n  }) {\n    const tree = await (packageLockOnly ? arb.loadVirtual() : arb.loadActual());\n    tree[_include] = args.length === 0;\n    tree[_depth] = 0;\n    return tree;\n  }\n\n}\n\nmodule.exports = LS;\n\nconst isGitNode = node => {\n  if (!node.resolved) return;\n\n  try {\n    const {\n      type\n    } = npa(node.resolved);\n    return type === 'git' || type === 'hosted';\n  } catch (err) {\n    return false;\n  }\n};\n\nconst isOptional = node => node[_type] === 'optional' || node[_type] === 'peerOptional';\n\nconst isExtraneous = (node, {\n  global\n}) => node.extraneous && !global;\n\nconst getProblems = (node, {\n  global\n}) => {\n  const problems = new Set();\n  if (node[_missing] && !isOptional(node)) problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`);\n  if (node[_invalid]) problems.add(`invalid: ${node.pkgid} ${node.path}`);\n  if (isExtraneous(node, {\n    global\n  })) problems.add(`extraneous: ${node.pkgid} ${node.path}`);\n  return problems;\n}; // annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\n\n\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent];\n  item[_include] = node[_include]; // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent];\n\n    while (p) {\n      p[_include] = true;\n      p = p[_parent];\n    }\n  }\n\n  return item;\n};\n\nconst getHumanOutputItem = (node, {\n  args,\n  color,\n  global,\n  long\n}) => {\n  const {\n    pkgid,\n    path\n  } = node;\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid;\n  let printable = node.isWorkspace ? workspacePkgId : pkgid; // special formatting for top-level package name\n\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length;\n    if (hasNoPackageJson || global) printable = path;else printable += `${long ? EOL : ' '}${path}`;\n  }\n\n  const highlightDepName = color && args.length && node[_filteredBy];\n  const missingColor = isOptional(node) ? chalk.yellow.bgBlack : chalk.red.bgBlack;\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`;\n  const targetLocation = node.root ? relative(node.root.realpath, node.realpath) : node.targetLocation;\n  const invalid = node[_invalid] ? `invalid: ${node[_invalid]}` : '';\n  const label = (node[_missing] ? (color ? missingColor(missingMsg) : missingMsg) + ' ' : '') + `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` + (node[_dedupe] ? ' ' + (color ? chalk.gray('deduped') : 'deduped') : '') + (invalid ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid) : '') + (isExtraneous(node, {\n    global\n  }) ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous') : '') + (isGitNode(node) ? ` (${node.resolved})` : '') + (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') + (long ? `${EOL}${node.package.description || ''}` : '');\n  return augmentItemWithIncludeMetadata(node, {\n    label,\n    nodes: []\n  });\n};\n\nconst getJsonOutputItem = (node, {\n  global,\n  long\n}) => {\n  const item = {};\n  if (node.version) item.version = node.version;\n  if (node.resolved) item.resolved = node.resolved;\n  item[_name] = node.name; // special formatting for top-level package name\n\n  const hasPackageJson = node && node.package && Object.keys(node.package).length;\n  if (node.isRoot && hasPackageJson) item.name = node.package.name || node.name;\n\n  if (long && !node[_missing]) {\n    item.name = item[_name];\n    const {\n      dependencies,\n      ...packageInfo\n    } = node.package;\n    Object.assign(item, packageInfo);\n    item.extraneous = false;\n    item.path = node.path;\n    item._dependencies = { ...node.package.dependencies,\n      ...node.package.optionalDependencies\n    };\n    item.devDependencies = node.package.devDependencies || {};\n    item.peerDependencies = node.package.peerDependencies || {};\n  } // augment json output items with extra metadata\n\n\n  if (isExtraneous(node, {\n    global\n  })) item.extraneous = true;\n  if (node[_invalid]) item.invalid = node[_invalid];\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required];\n    item.missing = true;\n  }\n\n  if (node[_include] && node[_problems] && node[_problems].size) item.problems = [...node[_problems]];\n  return augmentItemWithIncludeMetadata(node, item);\n};\n\nconst filterByEdgesTypes = ({\n  currentDepth,\n  dev,\n  development,\n  link,\n  prod,\n  production,\n  only\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = currentDepth === 0 && (dev || development || /^dev(elopment)?$/.test(only));\n  const filterProd = currentDepth === 0 && (prod || production || /^prod(uction)?$/.test(only));\n  const filterLink = currentDepth === 0 && link;\n  return edge => (filterDev ? edge.dev : true) && (filterProd ? !edge.dev && !edge.peer && !edge.peerOptional : true) && (filterLink ? edge.to && edge.to.isLink : true);\n};\n\nconst appendExtraneousChildren = ({\n  node,\n  seenPaths\n}) => // extraneous children are not represented\n// in edges out, so here we add them to the list:\n[...node.children.values()].filter(i => !seenPaths.has(i.path) && i.extraneous);\n\nconst mapEdgesToNodes = ({\n  seenPaths\n}) => edge => {\n  let node = edge.to; // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n\n  if (edge.missing || edge.optional && !node) {\n    const {\n      name,\n      spec\n    } = edge;\n    const pkgid = `${name}@${spec}`;\n    node = {\n      name,\n      pkgid,\n      [_missing]: edge.from.pkgid\n    };\n  } // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n\n\n  if (node.path) seenPaths.add(node.path);\n  node[_required] = edge.spec || '*';\n  node[_type] = edge.type;\n\n  if (edge.invalid) {\n    const spec = JSON.stringify(node[_required]);\n    const from = edge.from.location || 'the root project';\n    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') + `${spec} from ${from}`;\n  }\n\n  return node;\n};\n\nconst filterByPositionalArgs = (args, {\n  node\n}) => args.length > 0 ? args.some(spec => node.satisfies && node.satisfies(spec)) : true;\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes\n}) => node => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    const {\n      realpath,\n      root\n    } = node;\n    const targetLocation = root ? relative(root.realpath, realpath) : node.targetLocation;\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      targetLocation,\n      [_type]: node[_type],\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      // if it's missing, it's not deduped, it's just missing\n      [_dedupe]: !node[_missing]\n    };\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node);\n  } // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n\n\n  node[_parent] = nodeResult; // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n\n  node[_filteredBy] = node[_include] = filterByPositionalArgs(args, {\n    node: seenNodes.get(node.path)\n  }); // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n\n  node[_depth] = currentDepth + 1;\n  return node;\n};\n\nconst sortAlphabetically = ({\n  pkgid: a\n}, {\n  pkgid: b\n}) => localeCompare(a, b);\n\nconst humanOutput = ({\n  color,\n  result,\n  seenItems,\n  unicode\n}) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent]) item[_parent].nodes.push(item);\n  }\n\n  if (!result.nodes.length) result.nodes = ['(empty)'];\n  const archyOutput = archy(result, '', {\n    unicode\n  });\n  return color ? chalk.reset(archyOutput) : archyOutput;\n};\n\nconst jsonOutput = ({\n  path,\n  problems,\n  result,\n  rootError,\n  seenItems\n}) => {\n  if (problems.size) result.problems = [...problems];\n\n  if (rootError) {\n    result.problems = [...(result.problems || []), ...[`error in ${path}: Failed to parse root package.json`]];\n    result.invalid = true;\n  } // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n\n\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies) item[_parent].dependencies = {};\n      item[_parent].dependencies[item[_name]] = item;\n    }\n  }\n\n  return JSON.stringify(result, null, 2);\n};\n\nconst parseableOutput = ({\n  global,\n  long,\n  seenNodes\n}) => {\n  let out = '';\n\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path;\n\n      if (long) {\n        out += `:${node.pkgid}`;\n        out += node.path !== node.realpath ? `:${node.realpath}` : '';\n        out += isExtraneous(node, {\n          global\n        }) ? ':EXTRANEOUS' : '';\n        out += node[_invalid] ? ':INVALID' : '';\n      }\n\n      out += EOL;\n    }\n  }\n\n  return out.trim();\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/ls.js"],"names":["resolve","relative","sep","require","relativePrefix","EOL","archy","chalk","Arborist","breadth","npa","completion","_depth","Symbol","_dedupe","_filteredBy","_include","_invalid","_name","_missing","_parent","_problems","_required","_type","ArboristWorkspaceCmd","localeCompare","LS","description","name","usage","params","opts","npm","exec","args","cb","ls","then","catch","all","config","get","color","depth","dev","development","global","json","link","long","only","parseable","prod","production","unicode","packageLockOnly","path","globalDir","prefix","arb","flatOptions","legacyPeerDeps","tree","initTree","wsNodes","workspaceNames","length","workspaceNodes","filterBySelectedWorkspaces","edge","from","isProjectRoot","to","isWorkspace","includes","target","seenItems","Set","seenNodes","Map","problems","filterDefaultDepth","Infinity","depthToPrint","set","result","getChildren","node","nodeResult","seenPaths","workspace","currentDepth","shouldSkipChildren","Node","edgesOut","values","filter","filterByEdgesTypes","map","mapEdgesToNodes","concat","appendExtraneousChildren","sort","sortAlphabetically","augmentNodesWithMetadata","visit","getProblems","item","getJsonOutputItem","getHumanOutputItem","problem","add","Promise","rootError","errors","e","code","output","jsonOutput","parseableOutput","humanOutput","process","exitCode","Object","assign","Error","shouldThrow","size","every","startsWith","join","loadVirtual","loadActual","module","exports","isGitNode","resolved","type","err","isOptional","isExtraneous","extraneous","pkgid","augmentItemWithIncludeMetadata","p","workspacePkgId","green","printable","isRoot","hasNoPackageJson","keys","package","highlightDepName","missingColor","yellow","bgBlack","red","missingMsg","targetLocation","root","realpath","invalid","label","gray","isLink","nodes","version","hasPackageJson","dependencies","packageInfo","_dependencies","optionalDependencies","devDependencies","peerDependencies","required","missing","filterDev","test","filterProd","filterLink","peer","peerOptional","children","i","has","optional","spec","JSON","stringify","location","filterByPositionalArgs","some","satisfies","a","b","push","archyOutput","reset","out","trim"],"mappings":"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","sourcesContent":["const { resolve, relative, sep } = require('path')\nconst relativePrefix = `.${sep}`\nconst { EOL } = require('os')\n\nconst archy = require('archy')\nconst chalk = require('chalk')\nconst Arborist = require('@npmcli/arborist')\nconst { breadth } = require('treeverse')\nconst npa = require('npm-package-arg')\n\nconst completion = require('./utils/completion/installed-deep.js')\n\nconst _depth = Symbol('depth')\nconst _dedupe = Symbol('dedupe')\nconst _filteredBy = Symbol('filteredBy')\nconst _include = Symbol('include')\nconst _invalid = Symbol('invalid')\nconst _name = Symbol('name')\nconst _missing = Symbol('missing')\nconst _parent = Symbol('parent')\nconst _problems = Symbol('problems')\nconst _required = Symbol('required')\nconst _type = Symbol('type')\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nclass LS extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'List installed packages'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'ls'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[[<@scope>/]<pkg> ...]']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'all',\n      'json',\n      'long',\n      'parseable',\n      'global',\n      'depth',\n      'omit',\n      'link',\n      'package-lock-only',\n      'unicode',\n      ...super.params,\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.ls(args).then(() => cb()).catch(cb)\n  }\n\n  async ls (args) {\n    const all = this.npm.config.get('all')\n    const color = this.npm.color\n    const depth = this.npm.config.get('depth')\n    const dev = this.npm.config.get('dev')\n    const development = this.npm.config.get('development')\n    const global = this.npm.config.get('global')\n    const json = this.npm.config.get('json')\n    const link = this.npm.config.get('link')\n    const long = this.npm.config.get('long')\n    const only = this.npm.config.get('only')\n    const parseable = this.npm.config.get('parseable')\n    const prod = this.npm.config.get('prod')\n    const production = this.npm.config.get('production')\n    const unicode = this.npm.config.get('unicode')\n    const packageLockOnly = this.npm.config.get('package-lock-only')\n\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix\n\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path,\n    })\n    const tree = await this.initTree({arb, args, packageLockOnly })\n\n    // filters by workspaces nodes when using -w <workspace-name>\n    // We only have to filter the first layer of edges, so we don't\n    // explore anything that isn't part of the selected workspace set.\n    let wsNodes\n    if (this.workspaceNames && this.workspaceNames.length)\n      wsNodes = arb.workspaceNodes(tree, this.workspaceNames)\n    const filterBySelectedWorkspaces = edge => {\n      if (!wsNodes || !wsNodes.length)\n        return true\n\n      if (edge.from.isProjectRoot) {\n        return edge.to &&\n          edge.to.isWorkspace &\n          wsNodes.includes(edge.to.target)\n      }\n\n      return true\n    }\n\n    const seenItems = new Set()\n    const seenNodes = new Map()\n    const problems = new Set()\n\n    // defines special handling of printed depth when filtering with args\n    const filterDefaultDepth = depth === null ? Infinity : depth\n    const depthToPrint = (all || args.length)\n      ? filterDefaultDepth\n      : (depth || 0)\n\n    // add root node of tree to list of seenNodes\n    seenNodes.set(tree.path, tree)\n\n    // tree traversal happens here, using treeverse.breadth\n    const result = await breadth({\n      tree,\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren (node, nodeResult) {\n        const seenPaths = new Set()\n        const workspace = node.isWorkspace\n        const currentDepth = workspace ? 0 : node[_depth]\n        const shouldSkipChildren =\n          !(node instanceof Arborist.Node) || (currentDepth > depthToPrint)\n        return (shouldSkipChildren)\n          ? []\n          : [...(node.target).edgesOut.values()]\n            .filter(filterBySelectedWorkspaces)\n            .filter(filterByEdgesTypes({\n              currentDepth,\n              dev,\n              development,\n              link,\n              prod,\n              production,\n              only,\n            }))\n            .map(mapEdgesToNodes({ seenPaths }))\n            .concat(appendExtraneousChildren({ node, seenPaths }))\n            .sort(sortAlphabetically)\n            .map(augmentNodesWithMetadata({\n              args,\n              currentDepth,\n              nodeResult,\n              seenNodes,\n            }))\n      },\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit (node) {\n        node[_problems] = getProblems(node, { global })\n\n        const item = json\n          ? getJsonOutputItem(node, { global, long })\n          : parseable\n            ? null\n            : getHumanOutputItem(node, { args, color, global, long })\n\n        // loop through list of node problems to add them to global list\n        if (node[_include]) {\n          for (const problem of node[_problems])\n            problems.add(problem)\n        }\n\n        seenItems.add(item)\n\n        // return a promise so we don't blow the stack\n        return Promise.resolve(item)\n      },\n    })\n\n    // handle the special case of a broken package.json in the root folder\n    const [rootError] = tree.errors.filter(e =>\n      e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'))\n\n    this.npm.output(\n      json\n        ? jsonOutput({ path, problems, result, rootError, seenItems })\n        : parseable\n          ? parseableOutput({ seenNodes, global, long })\n          : humanOutput({ color, result, seenItems, unicode })\n    )\n\n    // if filtering items, should exit with error code on no results\n    if (result && !result[_include] && args.length)\n      process.exitCode = 1\n\n    if (rootError) {\n      throw Object.assign(\n        new Error('Failed to parse root package.json'),\n        { code: 'EJSONPARSE' }\n      )\n    }\n\n    const shouldThrow = problems.size &&\n      ![...problems].every(problem => problem.startsWith('extraneous:'))\n\n    if (shouldThrow) {\n      throw Object.assign(\n        new Error([...problems].join(EOL)),\n        { code: 'ELSPROBLEMS' }\n      )\n    }\n  }\n\n  async initTree ({ arb, args, packageLockOnly }) {\n    const tree = await (\n      packageLockOnly\n        ? arb.loadVirtual()\n        : arb.loadActual()\n    )\n\n    tree[_include] = args.length === 0\n    tree[_depth] = 0\n\n    return tree\n  }\n}\nmodule.exports = LS\n\nconst isGitNode = (node) => {\n  if (!node.resolved)\n    return\n\n  try {\n    const { type } = npa(node.resolved)\n    return type === 'git' || type === 'hosted'\n  } catch (err) {\n    return false\n  }\n}\n\nconst isOptional = (node) =>\n  node[_type] === 'optional' || node[_type] === 'peerOptional'\n\nconst isExtraneous = (node, { global }) =>\n  node.extraneous && !global\n\nconst getProblems = (node, { global }) => {\n  const problems = new Set()\n\n  if (node[_missing] && !isOptional(node))\n    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`)\n\n  if (node[_invalid])\n    problems.add(`invalid: ${node.pkgid} ${node.path}`)\n\n  if (isExtraneous(node, { global }))\n    problems.add(`extraneous: ${node.pkgid} ${node.path}`)\n\n  return problems\n}\n\n// annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent]\n  item[_include] = node[_include]\n\n  // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent]\n    while (p) {\n      p[_include] = true\n      p = p[_parent]\n    }\n  }\n\n  return item\n}\n\nconst getHumanOutputItem = (node, { args, color, global, long }) => {\n  const { pkgid, path } = node\n  const workspacePkgId = color ? chalk.green(pkgid) : pkgid\n  let printable = node.isWorkspace ? workspacePkgId : pkgid\n\n  // special formatting for top-level package name\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length\n    if (hasNoPackageJson || global)\n      printable = path\n    else\n      printable += `${long ? EOL : ' '}${path}`\n  }\n\n  const highlightDepName =\n    color && args.length && node[_filteredBy]\n  const missingColor = isOptional(node)\n    ? chalk.yellow.bgBlack\n    : chalk.red.bgBlack\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`\n  const targetLocation = node.root\n    ? relative(node.root.realpath, node.realpath)\n    : node.targetLocation\n  const invalid = node[_invalid]\n    ? `invalid: ${node[_invalid]}`\n    : ''\n  const label =\n    (\n      node[_missing]\n        ? (color ? missingColor(missingMsg) : missingMsg) + ' '\n        : ''\n    ) +\n    `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` +\n    (\n      node[_dedupe]\n        ? ' ' + (color ? chalk.gray('deduped') : 'deduped')\n        : ''\n    ) +\n    (\n      invalid\n        ? ' ' + (color ? chalk.red.bgBlack(invalid) : invalid)\n        : ''\n    ) +\n    (\n      isExtraneous(node, { global })\n        ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous')\n        : ''\n    ) +\n    (isGitNode(node) ? ` (${node.resolved})` : '') +\n    (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : '') +\n    (long ? `${EOL}${node.package.description || ''}` : '')\n\n  return augmentItemWithIncludeMetadata(node, { label, nodes: [] })\n}\n\nconst getJsonOutputItem = (node, { global, long }) => {\n  const item = {}\n\n  if (node.version)\n    item.version = node.version\n\n  if (node.resolved)\n    item.resolved = node.resolved\n\n  item[_name] = node.name\n\n  // special formatting for top-level package name\n  const hasPackageJson =\n    node && node.package && Object.keys(node.package).length\n  if (node.isRoot && hasPackageJson)\n    item.name = node.package.name || node.name\n\n  if (long && !node[_missing]) {\n    item.name = item[_name]\n    const { dependencies, ...packageInfo } = node.package\n    Object.assign(item, packageInfo)\n    item.extraneous = false\n    item.path = node.path\n    item._dependencies = {\n      ...node.package.dependencies,\n      ...node.package.optionalDependencies,\n    }\n    item.devDependencies = node.package.devDependencies || {}\n    item.peerDependencies = node.package.peerDependencies || {}\n  }\n\n  // augment json output items with extra metadata\n  if (isExtraneous(node, { global }))\n    item.extraneous = true\n\n  if (node[_invalid])\n    item.invalid = node[_invalid]\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required]\n    item.missing = true\n  }\n  if (node[_include] && node[_problems] && node[_problems].size)\n    item.problems = [...node[_problems]]\n\n  return augmentItemWithIncludeMetadata(node, item)\n}\n\nconst filterByEdgesTypes = ({\n  currentDepth,\n  dev,\n  development,\n  link,\n  prod,\n  production,\n  only,\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = currentDepth === 0 &&\n    (dev || development || /^dev(elopment)?$/.test(only))\n  const filterProd = currentDepth === 0 &&\n    (prod || production || /^prod(uction)?$/.test(only))\n  const filterLink = currentDepth === 0 && link\n\n  return (edge) =>\n    (filterDev ? edge.dev : true) &&\n    (filterProd ? (!edge.dev && !edge.peer && !edge.peerOptional) : true) &&\n    (filterLink ? (edge.to && edge.to.isLink) : true)\n}\n\nconst appendExtraneousChildren = ({ node, seenPaths }) =>\n  // extraneous children are not represented\n  // in edges out, so here we add them to the list:\n  [...node.children.values()]\n    .filter(i => !seenPaths.has(i.path) && i.extraneous)\n\nconst mapEdgesToNodes = ({ seenPaths }) => (edge) => {\n  let node = edge.to\n\n  // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n  if (edge.missing || (edge.optional && !node)) {\n    const { name, spec } = edge\n    const pkgid = `${name}@${spec}`\n    node = { name, pkgid, [_missing]: edge.from.pkgid }\n  }\n\n  // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n  if (node.path)\n    seenPaths.add(node.path)\n\n  node[_required] = edge.spec || '*'\n  node[_type] = edge.type\n\n  if (edge.invalid) {\n    const spec = JSON.stringify(node[_required])\n    const from = edge.from.location || 'the root project'\n    node[_invalid] = (node[_invalid] ? node[_invalid] + ', ' : '') +\n      (`${spec} from ${from}`)\n  }\n\n  return node\n}\n\nconst filterByPositionalArgs = (args, { node }) =>\n  args.length > 0 ? args.some(\n    (spec) => (node.satisfies && node.satisfies(spec))\n  ) : true\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes,\n}) => (node) => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    const { realpath, root } = node\n    const targetLocation = root ? relative(root.realpath, realpath)\n      : node.targetLocation\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      targetLocation,\n      [_type]: node[_type],\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      // if it's missing, it's not deduped, it's just missing\n      [_dedupe]: !node[_missing],\n    }\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node)\n  }\n\n  // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n  node[_parent] = nodeResult\n  // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n  node[_filteredBy] = node[_include] =\n    filterByPositionalArgs(args, { node: seenNodes.get(node.path) })\n  // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n  node[_depth] = currentDepth + 1\n\n  return node\n}\n\nconst sortAlphabetically = ({ pkgid: a }, { pkgid: b }) => localeCompare(a, b)\n\nconst humanOutput = ({ color, result, seenItems, unicode }) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent])\n      item[_parent].nodes.push(item)\n  }\n\n  if (!result.nodes.length)\n    result.nodes = ['(empty)']\n\n  const archyOutput = archy(result, '', { unicode })\n  return color ? chalk.reset(archyOutput) : archyOutput\n}\n\nconst jsonOutput = ({ path, problems, result, rootError, seenItems }) => {\n  if (problems.size)\n    result.problems = [...problems]\n\n  if (rootError) {\n    result.problems = [\n      ...(result.problems || []),\n      ...[`error in ${path}: Failed to parse root package.json`],\n    ]\n    result.invalid = true\n  }\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies)\n        item[_parent].dependencies = {}\n\n      item[_parent].dependencies[item[_name]] = item\n    }\n  }\n\n  return JSON.stringify(result, null, 2)\n}\n\nconst parseableOutput = ({ global, long, seenNodes }) => {\n  let out = ''\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path\n      if (long) {\n        out += `:${node.pkgid}`\n        out += node.path !== node.realpath ? `:${node.realpath}` : ''\n        out += isExtraneous(node, { global }) ? ':EXTRANEOUS' : ''\n        out += node[_invalid] ? ':INVALID' : ''\n      }\n      out += EOL\n    }\n  }\n  return out.trim()\n}\n"]},"metadata":{},"sourceType":"script"}