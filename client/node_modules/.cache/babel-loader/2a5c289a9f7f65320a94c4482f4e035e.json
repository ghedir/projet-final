{"ast":null,"code":"const {\n  URL,\n  domainToUnicode\n} = require('url');\n\nconst CHAR_LOWERCASE_A = 97;\nconst CHAR_LOWERCASE_Z = 122;\nconst isWindows = process.platform === 'win32';\n\nclass ERR_INVALID_FILE_URL_HOST extends TypeError {\n  constructor(platform) {\n    super(`File URL host must be \"localhost\" or empty on ${platform}`);\n    this.code = 'ERR_INVALID_FILE_URL_HOST';\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n}\n\nclass ERR_INVALID_FILE_URL_PATH extends TypeError {\n  constructor(msg) {\n    super(`File URL path ${msg}`);\n    this.code = 'ERR_INVALID_FILE_URL_PATH';\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, actual) {\n    super(`The \"${name}\" argument must be one of type string or an instance of URL. Received type ${typeof actual} ${actual}`);\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n}\n\nclass ERR_INVALID_URL_SCHEME extends TypeError {\n  constructor(expected) {\n    super(`The URL must be of scheme ${expected}`);\n    this.code = 'ERR_INVALID_URL_SCHEME';\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n}\n\nconst isURLInstance = input => {\n  return input != null && input.href && input.origin;\n};\n\nconst getPathFromURLWin32 = url => {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n\n      if (pathname[n + 1] === '2' && third === 102 || pathname[n + 1] === '5' && third === 99) {\n        throw new ERR_INVALID_FILE_URL_PATH('must not include encoded \\\\ or / characters');\n      }\n    }\n  }\n\n  pathname = pathname.replace(/\\//g, '\\\\');\n  pathname = decodeURIComponent(pathname);\n\n  if (hostname !== '') {\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || sep !== ':') {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n\n  return pathname.slice(1);\n};\n\nconst getPathFromURLPosix = url => {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(process.platform);\n  }\n\n  const pathname = url.pathname;\n\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH('must not include encoded / characters');\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname);\n};\n\nconst fileURLToPath = path => {\n  if (typeof path === 'string') {\n    path = new URL(path);\n  } else if (!isURLInstance(path)) {\n    throw new ERR_INVALID_ARG_TYPE('path', ['string', 'URL'], path);\n  }\n\n  if (path.protocol !== 'file:') {\n    throw new ERR_INVALID_URL_SCHEME('file');\n  }\n\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n};\n\nmodule.exports = fileURLToPath;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/fs/lib/common/file-url-to-path/polyfill.js"],"names":["URL","domainToUnicode","require","CHAR_LOWERCASE_A","CHAR_LOWERCASE_Z","isWindows","process","platform","ERR_INVALID_FILE_URL_HOST","TypeError","constructor","code","toString","name","message","ERR_INVALID_FILE_URL_PATH","msg","ERR_INVALID_ARG_TYPE","actual","ERR_INVALID_URL_SCHEME","expected","isURLInstance","input","href","origin","getPathFromURLWin32","url","hostname","pathname","n","length","third","codePointAt","replace","decodeURIComponent","letter","sep","slice","getPathFromURLPosix","fileURLToPath","path","protocol","module","exports"],"mappings":"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","sourcesContent":["const { URL, domainToUnicode } = require('url')\n\nconst CHAR_LOWERCASE_A = 97\nconst CHAR_LOWERCASE_Z = 122\n\nconst isWindows = process.platform === 'win32'\n\nclass ERR_INVALID_FILE_URL_HOST extends TypeError {\n  constructor (platform) {\n    super(`File URL host must be \"localhost\" or empty on ${platform}`)\n    this.code = 'ERR_INVALID_FILE_URL_HOST'\n  }\n\n  toString () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n\nclass ERR_INVALID_FILE_URL_PATH extends TypeError {\n  constructor (msg) {\n    super(`File URL path ${msg}`)\n    this.code = 'ERR_INVALID_FILE_URL_PATH'\n  }\n\n  toString () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n\nclass ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor (name, actual) {\n    super(`The \"${name}\" argument must be one of type string or an instance of URL. Received type ${typeof actual} ${actual}`)\n    this.code = 'ERR_INVALID_ARG_TYPE'\n  }\n\n  toString () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n\nclass ERR_INVALID_URL_SCHEME extends TypeError {\n  constructor (expected) {\n    super(`The URL must be of scheme ${expected}`)\n    this.code = 'ERR_INVALID_URL_SCHEME'\n  }\n\n  toString () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n\nconst isURLInstance = (input) => {\n  return input != null && input.href && input.origin\n}\n\nconst getPathFromURLWin32 = (url) => {\n  const hostname = url.hostname\n  let pathname = url.pathname\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20\n      if ((pathname[n + 1] === '2' && third === 102) ||\n        (pathname[n + 1] === '5' && third === 99)) {\n        throw new ERR_INVALID_FILE_URL_PATH('must not include encoded \\\\ or / characters')\n      }\n    }\n  }\n\n  pathname = pathname.replace(/\\//g, '\\\\')\n  pathname = decodeURIComponent(pathname)\n  if (hostname !== '') {\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`\n  }\n\n  const letter = pathname.codePointAt(1) | 0x20\n  const sep = pathname[2]\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||\n    (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute')\n  }\n\n  return pathname.slice(1)\n}\n\nconst getPathFromURLPosix = (url) => {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(process.platform)\n  }\n\n  const pathname = url.pathname\n\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH('must not include encoded / characters')\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nconst fileURLToPath = (path) => {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isURLInstance(path)) {\n    throw new ERR_INVALID_ARG_TYPE('path', ['string', 'URL'], path)\n  }\n\n  if (path.protocol !== 'file:') {\n    throw new ERR_INVALID_URL_SCHEME('file')\n  }\n\n  return isWindows\n    ? getPathFromURLWin32(path)\n    : getPathFromURLPosix(path)\n}\n\nmodule.exports = fileURLToPath\n"]},"metadata":{},"sourceType":"script"}