{"ast":null,"code":"const fs = require('fs');\n\nconst promisify = require('util').promisify;\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\nconst {\n  resolve\n} = require('path');\n\nconst updateDeps = require('./update-dependencies.js');\n\nconst updateScripts = require('./update-scripts.js');\n\nconst updateWorkspaces = require('./update-workspaces.js');\n\nconst parseJSON = require('json-parse-even-better-errors');\n\nconst _filename = Symbol('filename');\n\nconst _manifest = Symbol('manifest');\n\nconst _readFileContent = Symbol('readFileContent'); // a list of handy specialized helper functions that take\n// care of special cases that are handled by the npm cli\n\n\nconst knownSteps = new Set([updateDeps, updateScripts, updateWorkspaces]); // list of all keys that are handled by \"knownSteps\" helpers\n\nconst knownKeys = new Set([...updateDeps.knownKeys, 'scripts', 'workspaces']);\n\nclass PackageJson {\n  static async load(path) {\n    return await new PackageJson(path).load();\n  }\n\n  constructor(path) {\n    this[_filename] = resolve(path, 'package.json');\n    this[_manifest] = {};\n    this[_readFileContent] = '';\n  }\n\n  async load() {\n    try {\n      this[_readFileContent] = await readFile(this[_filename], 'utf8');\n    } catch (err) {\n      throw new Error('package.json not found');\n    }\n\n    try {\n      this[_manifest] = parseJSON(this[_readFileContent]);\n    } catch (err) {\n      throw new Error(`Invalid package.json: ${err}`);\n    }\n\n    return this;\n  }\n\n  get content() {\n    return this[_manifest];\n  }\n\n  update(content) {\n    // validates both current manifest and content param\n    const invalidContent = typeof this[_manifest] !== 'object' || typeof content !== 'object';\n\n    if (invalidContent) {\n      throw Object.assign(new Error(`Can't update invalid package.json data`), {\n        code: 'EPACKAGEJSONUPDATE'\n      });\n    }\n\n    for (const step of knownSteps) this[_manifest] = step({\n      content,\n      originalContent: this[_manifest]\n    }); // unknown properties will just be overwitten\n\n\n    for (const [key, value] of Object.entries(content)) {\n      if (!knownKeys.has(key)) this[_manifest][key] = value;\n    }\n\n    return this;\n  }\n\n  async save() {\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline\n    } = this[_manifest];\n    const format = indent === undefined ? '  ' : indent;\n    const eol = newline === undefined ? '\\n' : newline;\n    const fileContent = `${JSON.stringify(this[_manifest], null, format)}\\n`.replace(/\\n/g, eol);\n    if (fileContent.trim() !== this[_readFileContent].trim()) return await writeFile(this[_filename], fileContent);\n  }\n\n}\n\nmodule.exports = PackageJson;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/package-json/lib/index.js"],"names":["fs","require","promisify","readFile","writeFile","resolve","updateDeps","updateScripts","updateWorkspaces","parseJSON","_filename","Symbol","_manifest","_readFileContent","knownSteps","Set","knownKeys","PackageJson","load","path","constructor","err","Error","content","update","invalidContent","Object","assign","code","step","originalContent","key","value","entries","has","save","for","indent","newline","format","undefined","eol","fileContent","JSON","stringify","replace","trim","module","exports"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,MAAD,CAAP,CAAgBC,SAAlC;;AACA,MAAMC,QAAQ,GAAGD,SAAS,CAACF,EAAE,CAACG,QAAJ,CAA1B;AACA,MAAMC,SAAS,GAAGF,SAAS,CAACF,EAAE,CAACI,SAAJ,CAA3B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAcJ,OAAO,CAAC,MAAD,CAA3B;;AACA,MAAMK,UAAU,GAAGL,OAAO,CAAC,0BAAD,CAA1B;;AACA,MAAMM,aAAa,GAAGN,OAAO,CAAC,qBAAD,CAA7B;;AACA,MAAMO,gBAAgB,GAAGP,OAAO,CAAC,wBAAD,CAAhC;;AAEA,MAAMQ,SAAS,GAAGR,OAAO,CAAC,+BAAD,CAAzB;;AAEA,MAAMS,SAAS,GAAGC,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAME,gBAAgB,GAAGF,MAAM,CAAC,iBAAD,CAA/B,C,CAEA;AACA;;;AACA,MAAMG,UAAU,GAAG,IAAIC,GAAJ,CAAQ,CACzBT,UADyB,EAEzBC,aAFyB,EAGzBC,gBAHyB,CAAR,CAAnB,C,CAMA;;AACA,MAAMQ,SAAS,GAAG,IAAID,GAAJ,CAAQ,CACxB,GAAGT,UAAU,CAACU,SADU,EAExB,SAFwB,EAGxB,YAHwB,CAAR,CAAlB;;AAMA,MAAMC,WAAN,CAAkB;AACC,eAAJC,IAAI,CAAEC,IAAF,EAAQ;AACvB,WAAO,MAAM,IAAIF,WAAJ,CAAgBE,IAAhB,EAAsBD,IAAtB,EAAb;AACD;;AAEDE,EAAAA,WAAW,CAAED,IAAF,EAAQ;AACjB,SAAKT,SAAL,IAAkBL,OAAO,CAACc,IAAD,EAAO,cAAP,CAAzB;AACA,SAAKP,SAAL,IAAkB,EAAlB;AACA,SAAKC,gBAAL,IAAyB,EAAzB;AACD;;AAES,QAAJK,IAAI,GAAI;AACZ,QAAI;AACF,WAAKL,gBAAL,IACE,MAAMV,QAAQ,CAAC,KAAKO,SAAL,CAAD,EAAkB,MAAlB,CADhB;AAED,KAHD,CAGE,OAAOW,GAAP,EAAY;AACZ,YAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,QAAI;AACF,WAAKV,SAAL,IACEH,SAAS,CAAC,KAAKI,gBAAL,CAAD,CADX;AAED,KAHD,CAGE,OAAOQ,GAAP,EAAY;AACZ,YAAM,IAAIC,KAAJ,CAAW,yBAAwBD,GAAI,EAAvC,CAAN;AACD;;AAED,WAAO,IAAP;AACD;;AAEU,MAAPE,OAAO,GAAI;AACb,WAAO,KAAKX,SAAL,CAAP;AACD;;AAEDY,EAAAA,MAAM,CAAED,OAAF,EAAW;AACf;AACA,UAAME,cAAc,GAClB,OAAO,KAAKb,SAAL,CAAP,KAA2B,QAA3B,IACK,OAAOW,OAAP,KAAmB,QAF1B;;AAGA,QAAIE,cAAJ,EAAoB;AAClB,YAAMC,MAAM,CAACC,MAAP,CACJ,IAAIL,KAAJ,CAAW,wCAAX,CADI,EAEJ;AAAEM,QAAAA,IAAI,EAAE;AAAR,OAFI,CAAN;AAID;;AAED,SAAK,MAAMC,IAAX,IAAmBf,UAAnB,EACE,KAAKF,SAAL,IAAkBiB,IAAI,CAAC;AAAEN,MAAAA,OAAF;AAAWO,MAAAA,eAAe,EAAE,KAAKlB,SAAL;AAA5B,KAAD,CAAtB,CAba,CAef;;;AACA,SAAK,MAAM,CAACmB,GAAD,EAAMC,KAAN,CAAX,IAA2BN,MAAM,CAACO,OAAP,CAAeV,OAAf,CAA3B,EAAoD;AAClD,UAAI,CAACP,SAAS,CAACkB,GAAV,CAAcH,GAAd,CAAL,EACE,KAAKnB,SAAL,EAAgBmB,GAAhB,IAAuBC,KAAvB;AACH;;AAED,WAAO,IAAP;AACD;;AAES,QAAJG,IAAI,GAAI;AACZ,UAAM;AACJ,OAACxB,MAAM,CAACyB,GAAP,CAAW,QAAX,CAAD,GAAwBC,MADpB;AAEJ,OAAC1B,MAAM,CAACyB,GAAP,CAAW,SAAX,CAAD,GAAyBE;AAFrB,QAGF,KAAK1B,SAAL,CAHJ;AAKA,UAAM2B,MAAM,GAAGF,MAAM,KAAKG,SAAX,GAAuB,IAAvB,GAA8BH,MAA7C;AACA,UAAMI,GAAG,GAAGH,OAAO,KAAKE,SAAZ,GAAwB,IAAxB,GAA+BF,OAA3C;AACA,UAAMI,WAAW,GAAI,GACnBC,IAAI,CAACC,SAAL,CAAe,KAAKhC,SAAL,CAAf,EAAgC,IAAhC,EAAsC2B,MAAtC,CACD,IAFmB,CAGjBM,OAHiB,CAGT,KAHS,EAGFJ,GAHE,CAApB;AAKA,QAAIC,WAAW,CAACI,IAAZ,OAAuB,KAAKjC,gBAAL,EAAuBiC,IAAvB,EAA3B,EACE,OAAO,MAAM1C,SAAS,CAAC,KAAKM,SAAL,CAAD,EAAkBgC,WAAlB,CAAtB;AACH;;AAxEe;;AA2ElBK,MAAM,CAACC,OAAP,GAAiB/B,WAAjB","sourcesContent":["const fs = require('fs')\nconst promisify = require('util').promisify\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst { resolve } = require('path')\nconst updateDeps = require('./update-dependencies.js')\nconst updateScripts = require('./update-scripts.js')\nconst updateWorkspaces = require('./update-workspaces.js')\n\nconst parseJSON = require('json-parse-even-better-errors')\n\nconst _filename = Symbol('filename')\nconst _manifest = Symbol('manifest')\nconst _readFileContent = Symbol('readFileContent')\n\n// a list of handy specialized helper functions that take\n// care of special cases that are handled by the npm cli\nconst knownSteps = new Set([\n  updateDeps,\n  updateScripts,\n  updateWorkspaces,\n])\n\n// list of all keys that are handled by \"knownSteps\" helpers\nconst knownKeys = new Set([\n  ...updateDeps.knownKeys,\n  'scripts',\n  'workspaces',\n])\n\nclass PackageJson {\n  static async load (path) {\n    return await new PackageJson(path).load()\n  }\n\n  constructor (path) {\n    this[_filename] = resolve(path, 'package.json')\n    this[_manifest] = {}\n    this[_readFileContent] = ''\n  }\n\n  async load () {\n    try {\n      this[_readFileContent] =\n        await readFile(this[_filename], 'utf8')\n    } catch (err) {\n      throw new Error('package.json not found')\n    }\n\n    try {\n      this[_manifest] =\n        parseJSON(this[_readFileContent])\n    } catch (err) {\n      throw new Error(`Invalid package.json: ${err}`)\n    }\n\n    return this\n  }\n\n  get content () {\n    return this[_manifest]\n  }\n\n  update (content) {\n    // validates both current manifest and content param\n    const invalidContent =\n      typeof this[_manifest] !== 'object'\n        || typeof content !== 'object'\n    if (invalidContent) {\n      throw Object.assign(\n        new Error(`Can't update invalid package.json data`),\n        { code: 'EPACKAGEJSONUPDATE' }\n      )\n    }\n\n    for (const step of knownSteps)\n      this[_manifest] = step({ content, originalContent: this[_manifest] })\n\n    // unknown properties will just be overwitten\n    for (const [key, value] of Object.entries(content)) {\n      if (!knownKeys.has(key))\n        this[_manifest][key] = value\n    }\n\n    return this\n  }\n\n  async save () {\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline,\n    } = this[_manifest]\n\n    const format = indent === undefined ? '  ' : indent\n    const eol = newline === undefined ? '\\n' : newline\n    const fileContent = `${\n      JSON.stringify(this[_manifest], null, format)\n    }\\n`\n      .replace(/\\n/g, eol)\n\n    if (fileContent.trim() !== this[_readFileContent].trim())\n      return await writeFile(this[_filename], fileContent)\n  }\n}\n\nmodule.exports = PackageJson\n"]},"metadata":{},"sourceType":"script"}