{"ast":null,"code":"// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst lockfileVersion = 2; // for comparing nodes to yarn.lock entries\n\nconst mismatch = (a, b) => a && b && a !== b; // this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\n\nconst procLog = require('proc-log');\n\nconst YarnLock = require('./yarn-lock.js');\n\nconst {\n  promisify\n} = require('util');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst stat = promisify(fs.stat);\nconst readdir_ = promisify(fs.readdir);\nconst readlink = promisify(fs.readlink); // XXX remove when drop support for node v10\n\nconst lstat = promisify(fs.lstat);\n/* istanbul ignore next - version specific polyfill */\n\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt);\n  }\n\n  const ents = await readdir_(path, opt);\n\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), {\n        name: ent\n      });\n    }));\n  }\n\n  return ents;\n};\n\nconst {\n  resolve,\n  basename\n} = require('path');\n\nconst specFromLock = require('./spec-from-lock.js');\n\nconst versionFromTgz = require('./version-from-tgz.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst parseJSON = require('parse-conflict-json');\n\nconst stringify = require('json-stringify-nice');\n\nconst swKeyOrder = ['name', 'version', 'lockfileVersion', 'resolved', 'integrity', 'requires', 'packages', 'dependencies']; // used to rewrite from yarn registry to npm registry\n\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//;\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//; // sometimes resolved: is weird or broken, or something npa can't handle\n\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved);\n  } catch (er) {\n    return {};\n  }\n};\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return '';\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null;\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst pkgMetaKeys = [// note: name is included if necessary, for alias packages\n'version', 'dependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies', 'acceptDependencies', 'funding', 'engines', 'os', 'cpu', '_integrity', 'license', '_hasShrinkwrap', 'hasInstallScript', 'bin', 'deprecated', 'workspaces'];\nconst nodeMetaKeys = ['integrity', 'inBundle', 'hasShrinkwrap', 'hasInstallScript'];\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]; // get the license type, not an object\n\n  return key === 'license' && val && typeof val === 'object' && val.type ? val.type // skip empty objects and falsey values\n  : val && !(typeof val === 'object' && !Object.keys(val).length) ? val : null;\n}; // check to make sure that there are no packages newer than the hidden lockfile\n\n\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir);\n  const isNM = dir !== path && base === 'node_modules';\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@';\n  const isParent = dir === path || isNM || isScope;\n  const rel = relpath(path, dir);\n\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime;\n\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel;\n    }\n\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel;\n    }\n\n    seen.add(rel);\n  } else {\n    seen = new Set([rel]);\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules');\n  const children = dir === path ? Promise.resolve([{\n    name: 'node_modules',\n    isDirectory: () => true\n  }]) : readdir(parent, {\n    withFileTypes: true\n  });\n  return children.catch(() => []).then(ents => Promise.all(ents.map(async ent => {\n    const child = resolve(parent, ent.name);\n\n    if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n      await assertNoNewer(path, data, lockTime, child, seen);\n    } else if (ent.isSymbolicLink()) {\n      const target = resolve(parent, await readlink(child));\n      const tstat = await stat(target).catch(\n      /* istanbul ignore next - windows */\n      () => null);\n      seen.add(relpath(path, child));\n      /* istanbul ignore next - windows cannot do this */\n\n      if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n        await assertNoNewer(path, data, lockTime, target, seen);\n      }\n    }\n  }))).then(() => {\n    if (dir !== path) {\n      return;\n    } // assert that all the entries in the lockfile were seen\n\n\n    for (const loc of new Set(Object.keys(data.packages))) {\n      if (!seen.has(loc)) {\n        throw 'missing from node_modules: ' + loc;\n      }\n    }\n  });\n};\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate');\n\nconst _updateWaitingNode = Symbol('_updateWaitingNode');\n\nconst _lockFromLoc = Symbol('_lockFromLoc');\n\nconst _pathToLoc = Symbol('_pathToLoc');\n\nconst _loadAll = Symbol('_loadAll');\n\nconst _metaFromLock = Symbol('_metaFromLock');\n\nconst _resolveMetaNode = Symbol('_resolveMetaNode');\n\nconst _fixDependencies = Symbol('_fixDependencies');\n\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile');\n\nconst _filenameSet = Symbol('_filenameSet');\n\nconst _maybeRead = Symbol('_maybeRead');\n\nconst _maybeStat = Symbol('_maybeStat');\n\nclass Shrinkwrap {\n  static load(options) {\n    return new Shrinkwrap(options).load();\n  }\n\n  static get keyOrder() {\n    return swKeyOrder;\n  }\n\n  static reset(options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options);\n    s.reset();\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path, (s.hiddenLockfile ? 'node_modules/.package-lock' : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      s.loadedFromDisk = !!(sw || lock);\n      s.type = basename(s.filename);\n      return s;\n    });\n  }\n\n  static metaFromNode(node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true\n      };\n    }\n\n    const meta = {};\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key);\n\n      if (val) {\n        meta[key.replace(/^_/, '')] = val;\n      }\n    }); // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n\n    const pname = node.packageName;\n\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname;\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies;\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key];\n      }\n    });\n    const resolved = consistentResolve(node.resolved, node.path, path, true);\n\n    if (resolved) {\n      meta.resolved = resolved;\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true;\n    } else {\n      if (node.peer) {\n        meta.peer = true;\n      }\n\n      if (node.dev) {\n        meta.dev = true;\n      }\n\n      if (node.optional) {\n        meta.optional = true;\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true;\n      }\n    }\n\n    return meta;\n  }\n\n  constructor(options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog\n    } = options;\n    this.log = log;\n    this[_awaitingUpdate] = new Map();\n    this.tree = null;\n    this.path = resolve(path || '.');\n    this.filename = null;\n    this.data = null;\n    this.indent = indent;\n    this.newline = newline;\n    this.loadedFromDisk = false;\n    this.type = null;\n    this.yarnLock = null;\n    this.hiddenLockfile = hiddenLockfile;\n    this.loadingError = null; // only load npm-shrinkwrap.json in dep trees, not package-lock\n\n    this.shrinkwrapOnly = shrinkwrapOnly;\n  } // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n\n\n  checkYarnLock(spec, options = {}) {\n    spec = npa(spec);\n    const {\n      yarnLock,\n      loadedFromDisk\n    } = this;\n    const useYarnLock = yarnLock && !loadedFromDisk;\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw);\n\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {\n        resolved,\n        version,\n        integrity\n      } = fromYarn;\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved);\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved);\n      const isReg = isnpmReg || isYarnReg; // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {};\n      const yspec = tgz.name === spec.name && tgz.version === version ? version : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}` : resolved;\n\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n        options.integrity = integrity;\n        return npa(`${spec.name}@${yspec}`);\n      }\n    }\n\n    return spec;\n  } // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n\n\n  reset() {\n    this.tree = null;\n    this[_awaitingUpdate] = new Map();\n    this.originalLockfileVersion = lockfileVersion;\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {}\n    };\n  }\n\n  [_filenameSet]() {\n    return this.shrinkwrapOnly ? [this.path + '/npm-shrinkwrap.json'] : this.hiddenLockfile ? [null, this.path + '/node_modules/.package-lock.json'] : [this.path + '/npm-shrinkwrap.json', this.path + '/package-lock.json', this.path + '/yarn.lock'];\n  }\n\n  [_maybeRead]() {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)));\n  }\n\n  [_maybeStat]() {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2).map(fn => fn && maybeStatFile(fn)));\n  }\n\n  load() {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''; // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n\n      this.filename = resolve(this.path, (this.hiddenLockfile ? 'node_modules/.package-lock' : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      this.type = basename(this.filename);\n      this.loadedFromDisk = !!data;\n\n      if (yarn) {\n        this.yarnLock = new YarnLock(); // ignore invalid yarn data.  we'll likely clobber it later anyway.\n\n        try {\n          this.yarnLock.parse(yarn);\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {};\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline\n      } = data;\n      this.indent = indent !== undefined ? indent : this.indent;\n      this.newline = newline !== undefined ? newline : this.newline;\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data;\n      } // add a few ms just to account for jitter\n\n\n      const lockTime = +(await stat(this.filename)).mtime + 10;\n      await assertNoNewer(this.path, data, lockTime); // all good!  hidden lockfile is the newest thing in here.\n\n      return data;\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename);\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er);\n      this.loadingError = er;\n      this.loadedFromDisk = false;\n      this.ancientLockfile = false;\n      return {};\n    }).then(lock => {\n      this.data = { ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {\n          dependencies: lock.dependencies || {}\n        })\n      };\n      this.originalLockfileVersion = lock.lockfileVersion;\n      this.ancientLockfile = this.loadedFromDisk && !(lock.lockfileVersion >= 2) && !lock.requires; // load old lockfile deps into the packages listing\n\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({})).then(pkg => {\n          this[_loadAll]('', null, this.data);\n\n          this[_fixDependencies](pkg);\n        });\n      }\n    }).then(() => this);\n  }\n\n  [_loadAll](location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock); // dependencies nested under a link are actually under the link target\n\n\n    if (meta.link) {\n      location = meta.resolved;\n    }\n\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name;\n\n        this[_loadAll](loc, name, dep);\n      }\n    }\n  } // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n\n\n  [_fixDependencies](pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages[''];\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key);\n      const k = key.replace(/^_/, '');\n\n      if (val) {\n        root[k] = val;\n      }\n    });\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue;\n      } // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n\n\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name); // this overwrites the false value set above\n\n\n        const depType = dep && dep.optional && !meta.optional ? 'optionalDependencies' :\n        /* istanbul ignore next - dev deps are only for the root level */\n        dep && dep.dev && !meta.dev ? 'devDependencies' // also land here if the dep just isn't in the tree, which maybe\n        // should be an error, since it means that the shrinkwrap is\n        // invalid, but we can't do much better without any info.\n        : 'dependencies';\n        meta[depType] = meta[depType] || {};\n        meta[depType][name] = spec;\n      }\n\n      delete meta.requires;\n    }\n  }\n\n  [_resolveMetaNode](loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`;\n\n      if (this.data.packages[check]) {\n        return this.data.packages[check];\n      }\n\n      if (!path) {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n  [_lockFromLoc](lock, path, i = 0) {\n    if (!lock) {\n      return null;\n    }\n\n    if (path[i] === '') {\n      i++;\n    }\n\n    if (i >= path.length) {\n      return lock;\n    }\n\n    if (!lock.dependencies) {\n      return null;\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1);\n  } // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n\n\n  [_pathToLoc](path) {\n    return relpath(this.path, resolve(this.path, path));\n  }\n\n  delete(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    const location = this[_pathToLoc](nodePath);\n\n    this[_awaitingUpdate].delete(location);\n\n    delete this.data.packages[location];\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path.pop();\n\n    const pLock = this[_lockFromLoc](this.data, path);\n\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name];\n    }\n  }\n\n  get(nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    }\n\n    const location = this[_pathToLoc](nodePath);\n\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location);\n    } // first try to get from the newer spot, which we know has\n    // all the things we need.\n\n\n    if (this.data.packages[location]) {\n      return this.data.packages[location];\n    } // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n\n\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path[path.length - 1];\n\n    const lock = this[_lockFromLoc](this.data, path);\n\n    return this[_metaFromLock](location, name, lock);\n  }\n\n  [_metaFromLock](location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {};\n    } // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n\n\n    const spec = specFromLock(name, lock, this.path);\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec);\n      this.data.packages[location] = {\n        link: true,\n        resolved: target\n      }; // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock,\n          version: null\n        });\n      }\n\n      return this.data.packages[location];\n    }\n\n    const meta = {}; // when calling loadAll we'll change these into proper dep objects\n\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires;\n    }\n\n    if (lock.optional) {\n      meta.optional = true;\n    }\n\n    if (lock.dev) {\n      meta.dev = true;\n    } // the root will typically have a name from the root project's\n    // package.json file.\n\n\n    if (location === '') {\n      meta.name = lock.name;\n    } // if we have integrity, save it now.\n\n\n    if (lock.integrity) {\n      meta.integrity = lock.integrity;\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path); // return early because there is nothing else we can do with this\n\n        return this.data.packages[location] = meta;\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version;\n      } // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n\n    } // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n\n\n    if (lock.resolved || spec.type && !spec.registry) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved;\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true);\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec;\n      }\n    } // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n\n\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);\n\n        if (fromTgz) {\n          meta.version = fromTgz.version;\n\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name;\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name;\n        meta.version = spec.subSpec.fetchSpec;\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec;\n      } // ok, I did my best!  good luck!\n\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true;\n    } // save it for next time\n\n\n    return this.data.packages[location] = meta;\n  }\n\n  add(node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data');\n    } // will be actually updated on read\n\n\n    const loc = relpath(this.path, node.path);\n\n    if (node.path === this.path) {\n      this.tree = node;\n    } // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n\n\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version\n      } = this.get(node.path);\n      const pathFixed = !resolved ? null : !/^file:/.test(resolved) ? resolved // resolve onto the metadata path\n      : `file:${resolve(this.path, resolved.substr(5))}`; // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n\n      const resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed;\n      const integrityOk = !integrity || !node.integrity || node.integrity === integrity;\n      const versionOk = !version || !node.version || version === node.version;\n      const allOk = (resolved || integrity || version) && resolvedOk && integrityOk && versionOk;\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap\n        } = Shrinkwrap.metaFromNode(node, this.path);\n        node.resolved = node.resolved || resolved || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      }\n    }\n\n    this[_awaitingUpdate].set(loc, node);\n  }\n\n  addEdge(edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return;\n    }\n\n    const {\n      to: node\n    } = edge; // if it's already set up, nothing to do\n\n    if (node.resolved !== null && node.integrity !== null) {\n      return;\n    } // if the yarn lock is empty, nothing to do\n\n\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return;\n    } // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n\n\n    const pathFixed = !node.resolved ? null : !/file:/.test(node.resolved) ? node.resolved : consistentResolve(node.resolved, node.path, this.path, true);\n    const spec = npa(`${node.name}@${edge.spec}`);\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);\n\n    if (!entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved)) {\n      return;\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n    }\n\n    node.integrity = node.integrity || entry.integrity || null;\n    node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null;\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node);\n  }\n\n  [_updateWaitingNode](loc) {\n    const node = this[_awaitingUpdate].get(loc);\n\n    this[_awaitingUpdate].delete(loc);\n\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n  }\n\n  commit() {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree);\n      }\n\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path);\n      this.data.packages = {};\n\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root;\n      }\n\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue;\n        }\n\n        const loc = relpath(this.path, node.path);\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc);\n      }\n    } // hidden lockfiles don't include legacy metadata or a root entry\n\n\n    if (this.hiddenLockfile) {\n      delete this.data.packages[''];\n      delete this.data.dependencies;\n    } else if (this.tree) {\n      this[_buildLegacyLockfile](this.tree, this.data);\n    }\n\n    return this.data;\n  }\n\n  [_buildLegacyLockfile](node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name;\n\n      if (node.version) {\n        lock.version = node.version;\n      }\n    } // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n\n\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules');\n      const bloc = b.from.location.split('node_modules');\n      /* istanbul ignore next - sort calling order is indeterminate */\n\n      return aloc.length > bloc.length ? 1 : bloc.length > aloc.length ? -1 : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1]);\n    })[0];\n    const res = consistentResolve(node.resolved, this.path, this.path, true);\n    const rSpec = specFromResolved(res); // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n\n    const spec = !edge ? rSpec : npa.resolve(node.name, edge.spec, edge.from.realpath);\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath)}`;\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec;\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved;\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n\n      if (spec.raw) {\n        lock.from = spec.raw;\n      }\n    } else if (!node.isRoot && node.package && node.packageName && node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`;\n    } else if (node.package && node.version) {\n      lock.version = node.version;\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true;\n    } // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n\n\n    if (node.resolved && !node.isLink && rSpec.type !== 'git' && rSpec.type !== 'file' && rSpec.type !== 'directory' && spec.type !== 'directory' && spec.type !== 'git' && spec.type !== 'file' && spec.type !== 'remote') {\n      lock.resolved = node.resolved;\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity;\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true;\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true;\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true;\n      }\n\n      if (node.dev) {\n        lock.dev = true;\n      }\n\n      if (node.optional) {\n        lock.optional = true;\n      }\n    }\n\n    const depender = node.target;\n\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()];\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const {\n            spec,\n            peer\n          } = v;\n\n          if (peer) {\n            return set;\n          }\n\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length));\n            set[k] = `file:${relpath(node.realpath, p)}`;\n          } else {\n            set[k] = spec;\n          }\n\n          return set;\n        }, {});\n      } else {\n        lock.requires = true;\n      }\n    } // now we walk the children, putting them in the 'dependencies' object\n\n\n    const {\n      children\n    } = node.target;\n\n    if (!children.size) {\n      delete lock.dependencies;\n    } else {\n      const kidPath = [...path, node.realpath];\n      const dependencies = {}; // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n\n      let found = false;\n\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue;\n        }\n\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath);\n        found = true;\n      }\n\n      if (found) {\n        lock.dependencies = dependencies;\n      }\n    }\n\n    return lock;\n  }\n\n  save(options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data');\n    }\n\n    const {\n      format = true\n    } = options;\n    const defaultIndent = this.indent || 2;\n    const indent = format === true ? defaultIndent : format || 0;\n    const eol = format ? this.newline || '\\n' : '';\n    const data = this.commit();\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol);\n    return Promise.all([writeFile(this.filename, json).catch(er => {\n      if (this.hiddenLockfile) {\n        // well, we did our best.\n        // if we reify, and there's nothing there, then it might be lacking\n        // a node_modules folder, but then the lockfile is not important.\n        // Remove the file, so that in case there WERE deps, but we just\n        // failed to update the file for some reason, it's not out of sync.\n        return rimraf(this.filename);\n      }\n\n      throw er;\n    }), this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + '/yarn.lock', this.yarnLock.toString())]);\n  }\n\n}\n\nmodule.exports = Shrinkwrap;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/shrinkwrap.js"],"names":["localeCompare","require","lockfileVersion","mismatch","a","b","procLog","YarnLock","promisify","rimraf","fs","readFile","writeFile","stat","readdir_","readdir","readlink","lstat","path","opt","withFileTypes","ents","Promise","all","map","ent","Object","assign","name","resolve","basename","specFromLock","versionFromTgz","npa","rpj","parseJSON","stringify","swKeyOrder","yarnRegRe","npmRegRe","specFromResolved","resolved","er","relpath","consistentResolve","maybeReadFile","file","then","d","code","maybeStatFile","st","isFile","pkgMetaKeys","nodeMetaKeys","metaFieldFromPkg","pkg","key","val","type","keys","length","assertNoNewer","data","lockTime","dir","seen","base","isNM","isScope","charAt","isParent","rel","dirTime","mtime","packages","add","Set","parent","children","isDirectory","catch","child","test","isSymbolicLink","target","tstat","has","loc","_awaitingUpdate","Symbol","_updateWaitingNode","_lockFromLoc","_pathToLoc","_loadAll","_metaFromLock","_resolveMetaNode","_fixDependencies","_buildLegacyLockfile","_filenameSet","_maybeRead","_maybeStat","Shrinkwrap","load","options","keyOrder","reset","s","sw","lock","filename","hiddenLockfile","shrinkwrapOnly","loadedFromDisk","metaFromNode","node","isLink","realpath","link","meta","forEach","package","replace","pname","packageName","root","isTop","devDependencies","extraneous","peer","dev","optional","devOptional","constructor","indent","newline","log","Map","tree","yarnLock","loadingError","checkYarnLock","spec","useYarnLock","fromYarn","entries","get","raw","version","integrity","isYarnReg","registry","isnpmReg","isReg","tgz","yspec","originalLockfileVersion","requires","dependencies","fn","slice","yarn","parse","_","for","undefined","verbose","ancientLockfile","location","dep","k","depType","check","i","delete","nodePath","Error","split","pop","pLock","fetchSpec","fromTgz","subSpec","bundled","inBundle","hasShrinkwrap","pathFixed","substr","resolvedOk","integrityOk","versionOk","allOk","set","addEdge","edge","valid","to","size","entry","commit","fromTree","inventory","values","isRoot","edgesIn","filter","e","sort","aloc","from","bloc","res","rSpec","saveSpec","inDepBundle","depender","edgesOut","reduce","v","startsWith","p","kidPath","found","kid","includes","save","format","defaultIndent","eol","json","toString","module","exports"],"mappings":"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","sourcesContent":["// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst lockfileVersion = 2\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst procLog = require('proc-log')\nconst YarnLock = require('./yarn-lock.js')\nconst {promisify} = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst stat = promisify(fs.stat)\nconst readdir_ = promisify(fs.readdir)\nconst readlink = promisify(fs.readlink)\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat)\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt)\n  }\n  const ents = await readdir_(path, opt)\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), { name: ent })\n    }))\n  }\n  return ents\n}\n\nconst { resolve, basename } = require('path')\nconst specFromLock = require('./spec-from-lock.js')\nconst versionFromTgz = require('./version-from-tgz.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst parseJSON = require('parse-conflict-json')\n\nconst stringify = require('json-stringify-nice')\nconst swKeyOrder = [\n  'name',\n  'version',\n  'lockfileVersion',\n  'resolved',\n  'integrity',\n  'requires',\n  'packages',\n  'dependencies',\n]\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved)\n  } catch (er) {\n    return {}\n  }\n}\n\nconst relpath = require('./relpath.js')\n\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return ''\n    } else {\n      throw er\n    }\n  })\n}\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null\n    } else {\n      throw er\n    }\n  })\n}\n\nconst pkgMetaKeys = [\n  // note: name is included if necessary, for alias packages\n  'version',\n  'dependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n  'acceptDependencies',\n  'funding',\n  'engines',\n  'os',\n  'cpu',\n  '_integrity',\n  'license',\n  '_hasShrinkwrap',\n  'hasInstallScript',\n  'bin',\n  'deprecated',\n  'workspaces',\n]\n\nconst nodeMetaKeys = [\n  'integrity',\n  'inBundle',\n  'hasShrinkwrap',\n  'hasInstallScript',\n]\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]\n  // get the license type, not an object\n  return (key === 'license' && val && typeof val === 'object' && val.type)\n    ? val.type\n    // skip empty objects and falsey values\n    : (val && !(typeof val === 'object' && !Object.keys(val).length)) ? val\n    : null\n}\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir)\n  const isNM = dir !== path && base === 'node_modules'\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@'\n  const isParent = dir === path || isNM || isScope\n\n  const rel = relpath(path, dir)\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel\n    }\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel\n    }\n    seen.add(rel)\n  } else {\n    seen = new Set([rel])\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules')\n  const children = dir === path\n    ? Promise.resolve([{name: 'node_modules', isDirectory: () => true }])\n    : readdir(parent, { withFileTypes: true })\n\n  return children.catch(() => [])\n    .then(ents => Promise.all(ents.map(async ent => {\n      const child = resolve(parent, ent.name)\n      if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n        await assertNoNewer(path, data, lockTime, child, seen)\n      } else if (ent.isSymbolicLink()) {\n        const target = resolve(parent, await readlink(child))\n        const tstat = await stat(target).catch(\n          /* istanbul ignore next - windows */ () => null)\n        seen.add(relpath(path, child))\n        /* istanbul ignore next - windows cannot do this */\n        if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n          await assertNoNewer(path, data, lockTime, target, seen)\n        }\n      }\n    })))\n    .then(() => {\n      if (dir !== path) {\n        return\n      }\n\n      // assert that all the entries in the lockfile were seen\n      for (const loc of new Set(Object.keys(data.packages))) {\n        if (!seen.has(loc)) {\n          throw 'missing from node_modules: ' + loc\n        }\n      }\n    })\n}\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate')\nconst _updateWaitingNode = Symbol('_updateWaitingNode')\nconst _lockFromLoc = Symbol('_lockFromLoc')\nconst _pathToLoc = Symbol('_pathToLoc')\nconst _loadAll = Symbol('_loadAll')\nconst _metaFromLock = Symbol('_metaFromLock')\nconst _resolveMetaNode = Symbol('_resolveMetaNode')\nconst _fixDependencies = Symbol('_fixDependencies')\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile')\nconst _filenameSet = Symbol('_filenameSet')\nconst _maybeRead = Symbol('_maybeRead')\nconst _maybeStat = Symbol('_maybeStat')\nclass Shrinkwrap {\n  static load (options) {\n    return new Shrinkwrap(options).load()\n  }\n\n  static get keyOrder () {\n    return swKeyOrder\n  }\n\n  static reset (options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options)\n    s.reset()\n\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path,\n        (s.hiddenLockfile ? 'node_modules/.package-lock'\n        : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n      s.loadedFromDisk = !!(sw || lock)\n      s.type = basename(s.filename)\n      return s\n    })\n  }\n\n  static metaFromNode (node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true,\n      }\n    }\n\n    const meta = {}\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key)\n      if (val) {\n        meta[key.replace(/^_/, '')] = val\n      }\n    })\n    // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n    const pname = node.packageName\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key]\n      }\n    })\n\n    const resolved = consistentResolve(node.resolved, node.path, path, true)\n    if (resolved) {\n      meta.resolved = resolved\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true\n    } else {\n      if (node.peer) {\n        meta.peer = true\n      }\n      if (node.dev) {\n        meta.dev = true\n      }\n      if (node.optional) {\n        meta.optional = true\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true\n      }\n    }\n    return meta\n  }\n\n  constructor (options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog,\n    } = options\n\n    this.log = log\n    this[_awaitingUpdate] = new Map()\n    this.tree = null\n    this.path = resolve(path || '.')\n    this.filename = null\n    this.data = null\n    this.indent = indent\n    this.newline = newline\n    this.loadedFromDisk = false\n    this.type = null\n    this.yarnLock = null\n    this.hiddenLockfile = hiddenLockfile\n    this.loadingError = null\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock (spec, options = {}) {\n    spec = npa(spec)\n    const { yarnLock, loadedFromDisk } = this\n    const useYarnLock = yarnLock && !loadedFromDisk\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw)\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {resolved, version, integrity} = fromYarn\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved)\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved)\n      const isReg = isnpmReg || isYarnReg\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {}\n      const yspec = tgz.name === spec.name && tgz.version === version ? version\n        : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}`\n        : resolved\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n        options.integrity = integrity\n        return npa(`${spec.name}@${yspec}`)\n      }\n    }\n    return spec\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset () {\n    this.tree = null\n    this[_awaitingUpdate] = new Map()\n    this.originalLockfileVersion = lockfileVersion\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {},\n    }\n  }\n\n  [_filenameSet] () {\n    return this.shrinkwrapOnly ? [\n      this.path + '/npm-shrinkwrap.json',\n    ] : this.hiddenLockfile ? [\n      null,\n      this.path + '/node_modules/.package-lock.json',\n    ] : [\n      this.path + '/npm-shrinkwrap.json',\n      this.path + '/package-lock.json',\n      this.path + '/yarn.lock',\n    ]\n  }\n\n  [_maybeRead] () {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)))\n  }\n\n  [_maybeStat] () {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2)\n      .map(fn => fn && maybeStatFile(fn)))\n  }\n\n  load () {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path,\n        (this.hiddenLockfile ? 'node_modules/.package-lock'\n        : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n\n      this.type = basename(this.filename)\n      this.loadedFromDisk = !!data\n\n      if (yarn) {\n        this.yarnLock = new YarnLock()\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn)\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {}\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline,\n      } = data\n      this.indent = indent !== undefined ? indent : this.indent\n      this.newline = newline !== undefined ? newline : this.newline\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data\n      }\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10\n      await assertNoNewer(this.path, data, lockTime)\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename)\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er)\n      this.loadingError = er\n      this.loadedFromDisk = false\n      this.ancientLockfile = false\n      return {}\n    }).then(lock => {\n      this.data = {\n        ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {dependencies: lock.dependencies || {}}),\n      }\n      this.originalLockfileVersion = lock.lockfileVersion\n      this.ancientLockfile = this.loadedFromDisk &&\n        !(lock.lockfileVersion >= 2) && !lock.requires\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({}))\n          .then(pkg => {\n            this[_loadAll]('', null, this.data)\n            this[_fixDependencies](pkg)\n          })\n      }\n    })\n      .then(() => this)\n  }\n\n  [_loadAll] (location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock)\n    // dependencies nested under a link are actually under the link target\n    if (meta.link) {\n      location = meta.resolved\n    }\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name\n        this[_loadAll](loc, name, dep)\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies] (pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages['']\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key)\n      const k = key.replace(/^_/, '')\n      if (val) {\n        root[k] = val\n      }\n    })\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue\n      }\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name)\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional\n          ? 'optionalDependencies'\n          : /* istanbul ignore next - dev deps are only for the root level */\n          dep && dep.dev && !meta.dev ? 'devDependencies'\n          // also land here if the dep just isn't in the tree, which maybe\n          // should be an error, since it means that the shrinkwrap is\n          // invalid, but we can't do much better without any info.\n          : 'dependencies'\n        meta[depType] = meta[depType] || {}\n        meta[depType][name] = spec\n      }\n      delete meta.requires\n    }\n  }\n\n  [_resolveMetaNode] (loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`\n      if (this.data.packages[check]) {\n        return this.data.packages[check]\n      }\n\n      if (!path) {\n        break\n      }\n    }\n    return null\n  }\n\n  [_lockFromLoc] (lock, path, i = 0) {\n    if (!lock) {\n      return null\n    }\n\n    if (path[i] === '') {\n      i++\n    }\n\n    if (i >= path.length) {\n      return lock\n    }\n\n    if (!lock.dependencies) {\n      return null\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1)\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc] (path) {\n    return relpath(this.path, resolve(this.path, path))\n  }\n\n  delete (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n    const location = this[_pathToLoc](nodePath)\n    this[_awaitingUpdate].delete(location)\n\n    delete this.data.packages[location]\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path.pop()\n    const pLock = this[_lockFromLoc](this.data, path)\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name]\n    }\n  }\n\n  get (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    const location = this[_pathToLoc](nodePath)\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location)\n    }\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location]) {\n      return this.data.packages[location]\n    }\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path[path.length - 1]\n    const lock = this[_lockFromLoc](this.data, path)\n\n    return this[_metaFromLock](location, name, lock)\n  }\n\n  [_metaFromLock] (location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {}\n    }\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path)\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec)\n      this.data.packages[location] = {\n        link: true,\n        resolved: target,\n      }\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock, version: null })\n      }\n      return this.data.packages[location]\n    }\n\n    const meta = {}\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires\n    }\n\n    if (lock.optional) {\n      meta.optional = true\n    }\n    if (lock.dev) {\n      meta.dev = true\n    }\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '') {\n      meta.name = lock.name\n    }\n\n    // if we have integrity, save it now.\n    if (lock.integrity) {\n      meta.integrity = lock.integrity\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path)\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || (spec.type && !spec.registry)) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true)\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec\n      }\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) ||\n          versionFromTgz(spec.name, meta.resolved)\n        if (fromTgz) {\n          meta.version = fromTgz.version\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name\n        meta.version = spec.subSpec.fetchSpec\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec\n      }\n      // ok, I did my best!  good luck!\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true\n    }\n\n    // save it for next time\n    return this.data.packages[location] = meta\n  }\n\n  add (node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path)\n    if (node.path === this.path) {\n      this.tree = node\n    }\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version,\n      } = this.get(node.path)\n\n      const pathFixed = !resolved ? null\n        : !/^file:/.test(resolved) ? resolved\n        // resolve onto the metadata path\n        : `file:${resolve(this.path, resolved.substr(5))}`\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved ||\n        node.resolved === pathFixed\n      const integrityOk = !integrity || !node.integrity ||\n        node.integrity === integrity\n      const versionOk = !version || !node.version || version === node.version\n\n      const allOk = (resolved || integrity || version) &&\n        resolvedOk && integrityOk && versionOk\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap,\n        } = Shrinkwrap.metaFromNode(node, this.path)\n        node.resolved = node.resolved || resolved || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      }\n    }\n    this[_awaitingUpdate].set(loc, node)\n  }\n\n  addEdge (edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return\n    }\n\n    const { to: node } = edge\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null) {\n      return\n    }\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return\n    }\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null\n      : !/file:/.test(node.resolved) ? node.resolved\n      : consistentResolve(node.resolved, node.path, this.path, true)\n\n    const spec = npa(`${node.name}@${edge.spec}`)\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`)\n\n    if (!entry ||\n        mismatch(node.version, entry.version) ||\n        mismatch(node.integrity, entry.integrity) ||\n        mismatch(pathFixed, entry.resolved)) {\n      return\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n    }\n\n    node.integrity = node.integrity || entry.integrity || null\n    node.resolved = node.resolved ||\n      consistentResolve(entry.resolved, this.path, node.path) || null\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node)\n  }\n\n  [_updateWaitingNode] (loc) {\n    const node = this[_awaitingUpdate].get(loc)\n    this[_awaitingUpdate].delete(loc)\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n  }\n\n  commit () {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree)\n      }\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path)\n      this.data.packages = {}\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root\n      }\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue\n        }\n        const loc = relpath(this.path, node.path)\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc)\n      }\n    }\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages['']\n      delete this.data.dependencies\n    } else if (this.tree) {\n      this[_buildLegacyLockfile](this.tree, this.data)\n    }\n\n    return this.data\n  }\n\n  [_buildLegacyLockfile] (node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name\n      if (node.version) {\n        lock.version = node.version\n      }\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules')\n      const bloc = b.from.location.split('node_modules')\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1\n        : bloc.length > aloc.length ? -1\n        : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1])\n    })[0]\n\n    const res = consistentResolve(node.resolved, this.path, this.path, true)\n    const rSpec = specFromResolved(res)\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec\n      : npa.resolve(node.name, edge.spec, edge.from.realpath)\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath)}`\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw) {\n        lock.from = spec.raw\n      }\n    } else if (!node.isRoot &&\n        node.package &&\n        node.packageName &&\n        node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`\n    } else if (node.package && node.version) {\n      lock.version = node.version\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true\n    }\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved &&\n        !node.isLink &&\n        rSpec.type !== 'git' &&\n        rSpec.type !== 'file' &&\n        rSpec.type !== 'directory' &&\n        spec.type !== 'directory' &&\n        spec.type !== 'git' &&\n        spec.type !== 'file' &&\n        spec.type !== 'remote') {\n      lock.resolved = node.resolved\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true\n      }\n\n      if (node.dev) {\n        lock.dev = true\n      }\n\n      if (node.optional) {\n        lock.optional = true\n      }\n    }\n\n    const depender = node.target\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()]\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const { spec, peer } = v\n          if (peer) {\n            return set\n          }\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length))\n            set[k] = `file:${relpath(node.realpath, p)}`\n          } else {\n            set[k] = spec\n          }\n          return set\n        }, {})\n      } else {\n        lock.requires = true\n      }\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const {children} = node.target\n    if (!children.size) {\n      delete lock.dependencies\n    } else {\n      const kidPath = [...path, node.realpath]\n      const dependencies = {}\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue\n        }\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath)\n        found = true\n      }\n      if (found) {\n        lock.dependencies = dependencies\n      }\n    }\n    return lock\n  }\n\n  save (options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data')\n    }\n\n    const { format = true } = options\n    const defaultIndent = this.indent || 2\n    const indent = format === true ? defaultIndent\n      : format || 0\n    const eol = format ? this.newline || '\\n' : ''\n    const data = this.commit()\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol)\n    return Promise.all([\n      writeFile(this.filename, json).catch(er => {\n        if (this.hiddenLockfile) {\n          // well, we did our best.\n          // if we reify, and there's nothing there, then it might be lacking\n          // a node_modules folder, but then the lockfile is not important.\n          // Remove the file, so that in case there WERE deps, but we just\n          // failed to update the file for some reason, it's not out of sync.\n          return rimraf(this.filename)\n        }\n        throw er\n      }),\n      this.yarnLock && this.yarnLock.entries.size &&\n        writeFile(this.path + '/yarn.lock', this.yarnLock.toString()),\n    ])\n  }\n}\n\nmodule.exports = Shrinkwrap\n"]},"metadata":{},"sourceType":"script"}