{"ast":null,"code":"const archy = require('archy');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst chalk = require('chalk');\n\nconst pacote = require('pacote');\n\nconst semver = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  readTree: getFundingInfo,\n  normalizeFunding,\n  isValidFunding\n} = require('libnpmfund');\n\nconst completion = require('./utils/completion/installed-deep.js');\n\nconst openUrl = require('./utils/open-url.js');\n\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\n\nconst getPrintableName = ({\n  name,\n  version\n}) => {\n  const printableVersion = version ? `@${version}` : '';\n  return `${name}${printableVersion}`;\n};\n\nclass Fund extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Retrieve funding information';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'fund';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['json', 'browser', 'unicode', 'workspace', 'which'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[[<@scope>/]<pkg>]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n\n  exec(args, cb) {\n    this.fund(args).then(() => cb()).catch(cb);\n  }\n\n  async fund(args) {\n    const spec = args[0];\n    const numberArg = this.npm.config.get('which');\n    const fundingSourceNumber = numberArg && parseInt(numberArg, 10);\n    const badFundingSourceNumber = numberArg !== null && (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1);\n\n    if (badFundingSourceNumber) {\n      const err = new Error('`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer');\n      err.code = 'EFUNDNUMBER';\n      throw err;\n    }\n\n    if (this.npm.config.get('global')) {\n      const err = new Error('`npm fund` does not support global packages');\n      err.code = 'EFUNDGLOBAL';\n      throw err;\n    }\n\n    const where = this.npm.prefix;\n    const arb = new Arborist({ ...this.npm.flatOptions,\n      path: where\n    });\n    const tree = await arb.loadActual();\n\n    if (spec) {\n      await this.openFundingUrl({\n        path: where,\n        tree,\n        spec,\n        fundingSourceNumber\n      });\n      return;\n    }\n\n    const fundingInfo = getFundingInfo(tree, { ...this.flatOptions,\n      log: this.npm.log,\n      workspaces: this.workspaceNames\n    });\n    if (this.npm.config.get('json')) this.npm.output(this.printJSON(fundingInfo));else this.npm.output(this.printHuman(fundingInfo));\n  }\n\n  printJSON(fundingInfo) {\n    return JSON.stringify(fundingInfo, null, 2);\n  }\n\n  printHuman(fundingInfo) {\n    const color = this.npm.color;\n    const unicode = this.npm.config.get('unicode');\n    const seenUrls = new Map();\n\n    const tree = obj => archy(obj, '', {\n      unicode\n    });\n\n    const result = depth({\n      tree: fundingInfo,\n      // composes human readable package name\n      // and creates a new archy item for readable output\n      visit: ({\n        name,\n        version,\n        funding\n      }) => {\n        const [fundingSource] = [].concat(normalizeFunding(funding)).filter(isValidFunding);\n        const {\n          url\n        } = fundingSource || {};\n        const pkgRef = getPrintableName({\n          name,\n          version\n        });\n        let item = {\n          label: pkgRef\n        };\n\n        if (url) {\n          item.label = tree({\n            label: color ? chalk.bgBlack.white(url) : url,\n            nodes: [pkgRef]\n          }).trim(); // stacks all packages together under the same item\n\n          if (seenUrls.has(url)) {\n            item = seenUrls.get(url);\n            item.label += `, ${pkgRef}`;\n            return null;\n          } else seenUrls.set(url, item);\n        }\n\n        return item;\n      },\n      // puts child nodes back into returned archy\n      // output while also filtering out missing items\n      leave: (item, children) => {\n        if (item) item.nodes = children.filter(Boolean);\n        return item;\n      },\n      // turns tree-like object return by libnpmfund\n      // into children to be properly read by treeverse\n      getChildren: node => Object.keys(node.dependencies || {}).map(key => ({\n        name: key,\n        ...node.dependencies[key]\n      }))\n    });\n    const res = tree(result);\n    return color ? chalk.reset(res) : res;\n  }\n\n  async openFundingUrl({\n    path,\n    tree,\n    spec,\n    fundingSourceNumber\n  }) {\n    const arg = npa(spec, path);\n\n    const retrievePackageMetadata = () => {\n      if (arg.type === 'directory') {\n        if (tree.path === arg.fetchSpec) {\n          // matches cwd, e.g: npm fund .\n          return tree.package;\n        } else {\n          // matches any file path within current arborist inventory\n          for (const item of tree.inventory.values()) {\n            if (item.path === arg.fetchSpec) return item.package;\n          }\n        }\n      } else {\n        // tries to retrieve a package from arborist inventory\n        // by matching resulted package name from the provided spec\n        const [item] = [...tree.inventory.query('name', arg.name)].filter(i => semver.valid(i.package.version)).sort((a, b) => semver.rcompare(a.package.version, b.package.version));\n        if (item) return item.package;\n      }\n    };\n\n    const {\n      funding\n    } = retrievePackageMetadata() || (await pacote.manifest(arg, this.npm.flatOptions).catch(() => ({})));\n    const validSources = [].concat(normalizeFunding(funding)).filter(isValidFunding);\n    const matchesValidSource = validSources.length === 1 || fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length;\n\n    if (matchesValidSource) {\n      const index = fundingSourceNumber ? fundingSourceNumber - 1 : 0;\n      const {\n        type,\n        url\n      } = validSources[index];\n      const typePrefix = type ? `${type} funding` : 'Funding';\n      const msg = `${typePrefix} available at the following URL`;\n      return openUrl(this.npm, url, msg);\n    } else if (validSources.length && !(fundingSourceNumber >= 1)) {\n      validSources.forEach(({\n        type,\n        url\n      }, i) => {\n        const typePrefix = type ? `${type} funding` : 'Funding';\n        const msg = `${typePrefix} available at the following URL`;\n        this.npm.output(`${i + 1}: ${msg}: ${url}`);\n      });\n      this.npm.output('Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package');\n    } else {\n      const noFundingError = new Error(`No valid funding method available for: ${spec}`);\n      noFundingError.code = 'ENOFUND';\n      throw noFundingError;\n    }\n  }\n\n}\n\nmodule.exports = Fund;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/fund.js"],"names":["archy","require","Arborist","chalk","pacote","semver","npa","depth","readTree","getFundingInfo","normalizeFunding","isValidFunding","completion","openUrl","ArboristWorkspaceCmd","getPrintableName","name","version","printableVersion","Fund","description","params","usage","opts","npm","exec","args","cb","fund","then","catch","spec","numberArg","config","get","fundingSourceNumber","parseInt","badFundingSourceNumber","String","err","Error","code","where","prefix","arb","flatOptions","path","tree","loadActual","openFundingUrl","fundingInfo","log","workspaces","workspaceNames","output","printJSON","printHuman","JSON","stringify","color","unicode","seenUrls","Map","obj","result","visit","funding","fundingSource","concat","filter","url","pkgRef","item","label","bgBlack","white","nodes","trim","has","set","leave","children","Boolean","getChildren","node","Object","keys","dependencies","map","key","res","reset","arg","retrievePackageMetadata","type","fetchSpec","package","inventory","values","query","i","valid","sort","a","b","rcompare","manifest","validSources","matchesValidSource","length","index","typePrefix","msg","forEach","noFundingError","module","exports"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAYN,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAM;AACJO,EAAAA,QAAQ,EAAEC,cADN;AAEJC,EAAAA,gBAFI;AAGJC,EAAAA;AAHI,IAIFV,OAAO,CAAC,YAAD,CAJX;;AAMA,MAAMW,UAAU,GAAGX,OAAO,CAAC,sCAAD,CAA1B;;AACA,MAAMY,OAAO,GAAGZ,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMa,oBAAoB,GAAGb,OAAO,CAAC,8BAAD,CAApC;;AAEA,MAAMc,gBAAgB,GAAG,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAuB;AAC9C,QAAMC,gBAAgB,GAAGD,OAAO,GAAI,IAAGA,OAAQ,EAAf,GAAmB,EAAnD;AACA,SAAQ,GAAED,IAAK,GAAEE,gBAAiB,EAAlC;AACD,CAHD;;AAKA,MAAMC,IAAN,SAAmBL,oBAAnB,CAAwC;AACtC;AACsB,aAAXM,WAAW,GAAI;AACxB,WAAO,8BAAP;AACD;AAED;;;AACe,aAAJJ,IAAI,GAAI;AACjB,WAAO,MAAP;AACD;AAED;;;AACiB,aAANK,MAAM,GAAI;AACnB,WAAO,CACL,MADK,EAEL,SAFK,EAGL,SAHK,EAIL,WAJK,EAKL,OALK,CAAP;AAOD;AAED;;;AACgB,aAALC,KAAK,GAAI;AAClB,WAAO,CAAC,oBAAD,CAAP;AACD;AAED;;;AACgB,QAAVV,UAAU,CAAEW,IAAF,EAAQ;AACtB,WAAOX,UAAU,CAAC,KAAKY,GAAN,EAAWD,IAAX,CAAjB;AACD;;AAEDE,EAAAA,IAAI,CAAEC,IAAF,EAAQC,EAAR,EAAY;AACd,SAAKC,IAAL,CAAUF,IAAV,EAAgBG,IAAhB,CAAqB,MAAMF,EAAE,EAA7B,EAAiCG,KAAjC,CAAuCH,EAAvC;AACD;;AAES,QAAJC,IAAI,CAAEF,IAAF,EAAQ;AAChB,UAAMK,IAAI,GAAGL,IAAI,CAAC,CAAD,CAAjB;AACA,UAAMM,SAAS,GAAG,KAAKR,GAAL,CAASS,MAAT,CAAgBC,GAAhB,CAAoB,OAApB,CAAlB;AAEA,UAAMC,mBAAmB,GAAGH,SAAS,IAAII,QAAQ,CAACJ,SAAD,EAAY,EAAZ,CAAjD;AAEA,UAAMK,sBAAsB,GAC1BL,SAAS,KAAK,IAAd,KACCM,MAAM,CAACH,mBAAD,CAAN,KAAgCH,SAAhC,IAA6CG,mBAAmB,GAAG,CADpE,CADF;;AAIA,QAAIE,sBAAJ,EAA4B;AAC1B,YAAME,GAAG,GAAG,IAAIC,KAAJ,CAAU,4FAAV,CAAZ;AACAD,MAAAA,GAAG,CAACE,IAAJ,GAAW,aAAX;AACA,YAAMF,GAAN;AACD;;AAED,QAAI,KAAKf,GAAL,CAASS,MAAT,CAAgBC,GAAhB,CAAoB,QAApB,CAAJ,EAAmC;AACjC,YAAMK,GAAG,GAAG,IAAIC,KAAJ,CAAU,6CAAV,CAAZ;AACAD,MAAAA,GAAG,CAACE,IAAJ,GAAW,aAAX;AACA,YAAMF,GAAN;AACD;;AAED,UAAMG,KAAK,GAAG,KAAKlB,GAAL,CAASmB,MAAvB;AACA,UAAMC,GAAG,GAAG,IAAI1C,QAAJ,CAAa,EAAE,GAAG,KAAKsB,GAAL,CAASqB,WAAd;AAA2BC,MAAAA,IAAI,EAAEJ;AAAjC,KAAb,CAAZ;AACA,UAAMK,IAAI,GAAG,MAAMH,GAAG,CAACI,UAAJ,EAAnB;;AAEA,QAAIjB,IAAJ,EAAU;AACR,YAAM,KAAKkB,cAAL,CAAoB;AACxBH,QAAAA,IAAI,EAAEJ,KADkB;AAExBK,QAAAA,IAFwB;AAGxBhB,QAAAA,IAHwB;AAIxBI,QAAAA;AAJwB,OAApB,CAAN;AAMA;AACD;;AAED,UAAMe,WAAW,GAAGzC,cAAc,CAACsC,IAAD,EAAO,EACvC,GAAG,KAAKF,WAD+B;AAEvCM,MAAAA,GAAG,EAAE,KAAK3B,GAAL,CAAS2B,GAFyB;AAGvCC,MAAAA,UAAU,EAAE,KAAKC;AAHsB,KAAP,CAAlC;AAMA,QAAI,KAAK7B,GAAL,CAASS,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAJ,EACE,KAAKV,GAAL,CAAS8B,MAAT,CAAgB,KAAKC,SAAL,CAAeL,WAAf,CAAhB,EADF,KAGE,KAAK1B,GAAL,CAAS8B,MAAT,CAAgB,KAAKE,UAAL,CAAgBN,WAAhB,CAAhB;AACH;;AAEDK,EAAAA,SAAS,CAAEL,WAAF,EAAe;AACtB,WAAOO,IAAI,CAACC,SAAL,CAAeR,WAAf,EAA4B,IAA5B,EAAkC,CAAlC,CAAP;AACD;;AAEDM,EAAAA,UAAU,CAAEN,WAAF,EAAe;AACvB,UAAMS,KAAK,GAAG,KAAKnC,GAAL,CAASmC,KAAvB;AACA,UAAMC,OAAO,GAAG,KAAKpC,GAAL,CAASS,MAAT,CAAgBC,GAAhB,CAAoB,SAApB,CAAhB;AACA,UAAM2B,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;;AAEA,UAAMf,IAAI,GAAGgB,GAAG,IACd/D,KAAK,CAAC+D,GAAD,EAAM,EAAN,EAAU;AAAEH,MAAAA;AAAF,KAAV,CADP;;AAGA,UAAMI,MAAM,GAAGzD,KAAK,CAAC;AACnBwC,MAAAA,IAAI,EAAEG,WADa;AAGnB;AACA;AACAe,MAAAA,KAAK,EAAE,CAAC;AAAEjD,QAAAA,IAAF;AAAQC,QAAAA,OAAR;AAAiBiD,QAAAA;AAAjB,OAAD,KAAgC;AACrC,cAAM,CAACC,aAAD,IAAkB,GACrBC,MADqB,CACd1D,gBAAgB,CAACwD,OAAD,CADF,EAErBG,MAFqB,CAEd1D,cAFc,CAAxB;AAGA,cAAM;AAAE2D,UAAAA;AAAF,YAAUH,aAAa,IAAI,EAAjC;AACA,cAAMI,MAAM,GAAGxD,gBAAgB,CAAC;AAAEC,UAAAA,IAAF;AAAQC,UAAAA;AAAR,SAAD,CAA/B;AACA,YAAIuD,IAAI,GAAG;AACTC,UAAAA,KAAK,EAAEF;AADE,SAAX;;AAIA,YAAID,GAAJ,EAAS;AACPE,UAAAA,IAAI,CAACC,KAAL,GAAa1B,IAAI,CAAC;AAChB0B,YAAAA,KAAK,EAAEd,KAAK,GAAGxD,KAAK,CAACuE,OAAN,CAAcC,KAAd,CAAoBL,GAApB,CAAH,GAA8BA,GAD1B;AAEhBM,YAAAA,KAAK,EAAE,CAACL,MAAD;AAFS,WAAD,CAAJ,CAGVM,IAHU,EAAb,CADO,CAMP;;AACA,cAAIhB,QAAQ,CAACiB,GAAT,CAAaR,GAAb,CAAJ,EAAuB;AACrBE,YAAAA,IAAI,GAAGX,QAAQ,CAAC3B,GAAT,CAAaoC,GAAb,CAAP;AACAE,YAAAA,IAAI,CAACC,KAAL,IAAe,KAAIF,MAAO,EAA1B;AACA,mBAAO,IAAP;AACD,WAJD,MAKEV,QAAQ,CAACkB,GAAT,CAAaT,GAAb,EAAkBE,IAAlB;AACH;;AAED,eAAOA,IAAP;AACD,OA/BkB;AAiCnB;AACA;AACAQ,MAAAA,KAAK,EAAE,CAACR,IAAD,EAAOS,QAAP,KAAoB;AACzB,YAAIT,IAAJ,EACEA,IAAI,CAACI,KAAL,GAAaK,QAAQ,CAACZ,MAAT,CAAgBa,OAAhB,CAAb;AAEF,eAAOV,IAAP;AACD,OAxCkB;AA0CnB;AACA;AACAW,MAAAA,WAAW,EAAGC,IAAD,IACXC,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACG,YAAL,IAAqB,EAAjC,EACGC,GADH,CACOC,GAAG,KAAK;AACXzE,QAAAA,IAAI,EAAEyE,GADK;AAEX,WAAGL,IAAI,CAACG,YAAL,CAAkBE,GAAlB;AAFQ,OAAL,CADV;AA7CiB,KAAD,CAApB;AAoDA,UAAMC,GAAG,GAAG3C,IAAI,CAACiB,MAAD,CAAhB;AACA,WAAOL,KAAK,GAAGxD,KAAK,CAACwF,KAAN,CAAYD,GAAZ,CAAH,GAAsBA,GAAlC;AACD;;AAEmB,QAAdzC,cAAc,CAAE;AAAEH,IAAAA,IAAF;AAAQC,IAAAA,IAAR;AAAchB,IAAAA,IAAd;AAAoBI,IAAAA;AAApB,GAAF,EAA6C;AAC/D,UAAMyD,GAAG,GAAGtF,GAAG,CAACyB,IAAD,EAAOe,IAAP,CAAf;;AACA,UAAM+C,uBAAuB,GAAG,MAAM;AACpC,UAAID,GAAG,CAACE,IAAJ,KAAa,WAAjB,EAA8B;AAC5B,YAAI/C,IAAI,CAACD,IAAL,KAAc8C,GAAG,CAACG,SAAtB,EAAiC;AAC/B;AACA,iBAAOhD,IAAI,CAACiD,OAAZ;AACD,SAHD,MAGO;AACL;AACA,eAAK,MAAMxB,IAAX,IAAmBzB,IAAI,CAACkD,SAAL,CAAeC,MAAf,EAAnB,EAA4C;AAC1C,gBAAI1B,IAAI,CAAC1B,IAAL,KAAc8C,GAAG,CAACG,SAAtB,EACE,OAAOvB,IAAI,CAACwB,OAAZ;AACH;AACF;AACF,OAXD,MAWO;AACL;AACA;AACA,cAAM,CAACxB,IAAD,IAAS,CAAC,GAAGzB,IAAI,CAACkD,SAAL,CAAeE,KAAf,CAAqB,MAArB,EAA6BP,GAAG,CAAC5E,IAAjC,CAAJ,EACZqD,MADY,CACL+B,CAAC,IAAI/F,MAAM,CAACgG,KAAP,CAAaD,CAAC,CAACJ,OAAF,CAAU/E,OAAvB,CADA,EAEZqF,IAFY,CAEP,CAACC,CAAD,EAAIC,CAAJ,KAAUnG,MAAM,CAACoG,QAAP,CAAgBF,CAAC,CAACP,OAAF,CAAU/E,OAA1B,EAAmCuF,CAAC,CAACR,OAAF,CAAU/E,OAA7C,CAFH,CAAf;AAIA,YAAIuD,IAAJ,EACE,OAAOA,IAAI,CAACwB,OAAZ;AACH;AACF,KAtBD;;AAwBA,UAAM;AAAE9B,MAAAA;AAAF,QAAc2B,uBAAuB,OACzC,MAAMzF,MAAM,CAACsG,QAAP,CAAgBd,GAAhB,EAAqB,KAAKpE,GAAL,CAASqB,WAA9B,EAA2Cf,KAA3C,CAAiD,OAAO,EAAP,CAAjD,CADmC,CAA3C;AAGA,UAAM6E,YAAY,GAAG,GAClBvC,MADkB,CACX1D,gBAAgB,CAACwD,OAAD,CADL,EAElBG,MAFkB,CAEX1D,cAFW,CAArB;AAIA,UAAMiG,kBAAkB,GACtBD,YAAY,CAACE,MAAb,KAAwB,CAAxB,IACC1E,mBAAmB,GAAG,CAAtB,IAA2BA,mBAAmB,IAAIwE,YAAY,CAACE,MAFlE;;AAIA,QAAID,kBAAJ,EAAwB;AACtB,YAAME,KAAK,GAAG3E,mBAAmB,GAAGA,mBAAmB,GAAG,CAAzB,GAA6B,CAA9D;AACA,YAAM;AAAE2D,QAAAA,IAAF;AAAQxB,QAAAA;AAAR,UAAgBqC,YAAY,CAACG,KAAD,CAAlC;AACA,YAAMC,UAAU,GAAGjB,IAAI,GAAI,GAAEA,IAAK,UAAX,GAAuB,SAA9C;AACA,YAAMkB,GAAG,GAAI,GAAED,UAAW,iCAA1B;AACA,aAAOlG,OAAO,CAAC,KAAKW,GAAN,EAAW8C,GAAX,EAAgB0C,GAAhB,CAAd;AACD,KAND,MAMO,IAAIL,YAAY,CAACE,MAAb,IAAuB,EAAE1E,mBAAmB,IAAI,CAAzB,CAA3B,EAAwD;AAC7DwE,MAAAA,YAAY,CAACM,OAAb,CAAqB,CAAC;AAAEnB,QAAAA,IAAF;AAAQxB,QAAAA;AAAR,OAAD,EAAgB8B,CAAhB,KAAsB;AACzC,cAAMW,UAAU,GAAGjB,IAAI,GAAI,GAAEA,IAAK,UAAX,GAAuB,SAA9C;AACA,cAAMkB,GAAG,GAAI,GAAED,UAAW,iCAA1B;AACA,aAAKvF,GAAL,CAAS8B,MAAT,CAAiB,GAAE8C,CAAC,GAAG,CAAE,KAAIY,GAAI,KAAI1C,GAAI,EAAzC;AACD,OAJD;AAKA,WAAK9C,GAAL,CAAS8B,MAAT,CAAgB,8GAAhB;AACD,KAPM,MAOA;AACL,YAAM4D,cAAc,GAAG,IAAI1E,KAAJ,CAAW,0CAAyCT,IAAK,EAAzD,CAAvB;AACAmF,MAAAA,cAAc,CAACzE,IAAf,GAAsB,SAAtB;AAEA,YAAMyE,cAAN;AACD;AACF;;AAhNqC;;AAkNxCC,MAAM,CAACC,OAAP,GAAiBjG,IAAjB","sourcesContent":["const archy = require('archy')\nconst Arborist = require('@npmcli/arborist')\nconst chalk = require('chalk')\nconst pacote = require('pacote')\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst { depth } = require('treeverse')\nconst {\n  readTree: getFundingInfo,\n  normalizeFunding,\n  isValidFunding,\n} = require('libnpmfund')\n\nconst completion = require('./utils/completion/installed-deep.js')\nconst openUrl = require('./utils/open-url.js')\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\n\nconst getPrintableName = ({ name, version }) => {\n  const printableVersion = version ? `@${version}` : ''\n  return `${name}${printableVersion}`\n}\n\nclass Fund extends ArboristWorkspaceCmd {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Retrieve funding information'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'fund'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'json',\n      'browser',\n      'unicode',\n      'workspace',\n      'which',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[[<@scope>/]<pkg>]']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.fund(args).then(() => cb()).catch(cb)\n  }\n\n  async fund (args) {\n    const spec = args[0]\n    const numberArg = this.npm.config.get('which')\n\n    const fundingSourceNumber = numberArg && parseInt(numberArg, 10)\n\n    const badFundingSourceNumber =\n      numberArg !== null &&\n      (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1)\n\n    if (badFundingSourceNumber) {\n      const err = new Error('`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer')\n      err.code = 'EFUNDNUMBER'\n      throw err\n    }\n\n    if (this.npm.config.get('global')) {\n      const err = new Error('`npm fund` does not support global packages')\n      err.code = 'EFUNDGLOBAL'\n      throw err\n    }\n\n    const where = this.npm.prefix\n    const arb = new Arborist({ ...this.npm.flatOptions, path: where })\n    const tree = await arb.loadActual()\n\n    if (spec) {\n      await this.openFundingUrl({\n        path: where,\n        tree,\n        spec,\n        fundingSourceNumber,\n      })\n      return\n    }\n\n    const fundingInfo = getFundingInfo(tree, {\n      ...this.flatOptions,\n      log: this.npm.log,\n      workspaces: this.workspaceNames,\n    })\n\n    if (this.npm.config.get('json'))\n      this.npm.output(this.printJSON(fundingInfo))\n    else\n      this.npm.output(this.printHuman(fundingInfo))\n  }\n\n  printJSON (fundingInfo) {\n    return JSON.stringify(fundingInfo, null, 2)\n  }\n\n  printHuman (fundingInfo) {\n    const color = this.npm.color\n    const unicode = this.npm.config.get('unicode')\n    const seenUrls = new Map()\n\n    const tree = obj =>\n      archy(obj, '', { unicode })\n\n    const result = depth({\n      tree: fundingInfo,\n\n      // composes human readable package name\n      // and creates a new archy item for readable output\n      visit: ({ name, version, funding }) => {\n        const [fundingSource] = []\n          .concat(normalizeFunding(funding))\n          .filter(isValidFunding)\n        const { url } = fundingSource || {}\n        const pkgRef = getPrintableName({ name, version })\n        let item = {\n          label: pkgRef,\n        }\n\n        if (url) {\n          item.label = tree({\n            label: color ? chalk.bgBlack.white(url) : url,\n            nodes: [pkgRef],\n          }).trim()\n\n          // stacks all packages together under the same item\n          if (seenUrls.has(url)) {\n            item = seenUrls.get(url)\n            item.label += `, ${pkgRef}`\n            return null\n          } else\n            seenUrls.set(url, item)\n        }\n\n        return item\n      },\n\n      // puts child nodes back into returned archy\n      // output while also filtering out missing items\n      leave: (item, children) => {\n        if (item)\n          item.nodes = children.filter(Boolean)\n\n        return item\n      },\n\n      // turns tree-like object return by libnpmfund\n      // into children to be properly read by treeverse\n      getChildren: (node) =>\n        Object.keys(node.dependencies || {})\n          .map(key => ({\n            name: key,\n            ...node.dependencies[key],\n          })),\n    })\n\n    const res = tree(result)\n    return color ? chalk.reset(res) : res\n  }\n\n  async openFundingUrl ({ path, tree, spec, fundingSourceNumber }) {\n    const arg = npa(spec, path)\n    const retrievePackageMetadata = () => {\n      if (arg.type === 'directory') {\n        if (tree.path === arg.fetchSpec) {\n          // matches cwd, e.g: npm fund .\n          return tree.package\n        } else {\n          // matches any file path within current arborist inventory\n          for (const item of tree.inventory.values()) {\n            if (item.path === arg.fetchSpec)\n              return item.package\n          }\n        }\n      } else {\n        // tries to retrieve a package from arborist inventory\n        // by matching resulted package name from the provided spec\n        const [item] = [...tree.inventory.query('name', arg.name)]\n          .filter(i => semver.valid(i.package.version))\n          .sort((a, b) => semver.rcompare(a.package.version, b.package.version))\n\n        if (item)\n          return item.package\n      }\n    }\n\n    const { funding } = retrievePackageMetadata() ||\n      await pacote.manifest(arg, this.npm.flatOptions).catch(() => ({}))\n\n    const validSources = []\n      .concat(normalizeFunding(funding))\n      .filter(isValidFunding)\n\n    const matchesValidSource =\n      validSources.length === 1 ||\n      (fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length)\n\n    if (matchesValidSource) {\n      const index = fundingSourceNumber ? fundingSourceNumber - 1 : 0\n      const { type, url } = validSources[index]\n      const typePrefix = type ? `${type} funding` : 'Funding'\n      const msg = `${typePrefix} available at the following URL`\n      return openUrl(this.npm, url, msg)\n    } else if (validSources.length && !(fundingSourceNumber >= 1)) {\n      validSources.forEach(({ type, url }, i) => {\n        const typePrefix = type ? `${type} funding` : 'Funding'\n        const msg = `${typePrefix} available at the following URL`\n        this.npm.output(`${i + 1}: ${msg}: ${url}`)\n      })\n      this.npm.output('Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package')\n    } else {\n      const noFundingError = new Error(`No valid funding method available for: ${spec}`)\n      noFundingError.code = 'ENOFUND'\n\n      throw noFundingError\n    }\n  }\n}\nmodule.exports = Fund\n"]},"metadata":{},"sourceType":"script"}