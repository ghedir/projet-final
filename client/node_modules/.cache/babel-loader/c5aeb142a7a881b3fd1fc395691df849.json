{"ast":null,"code":"const Table = require('cli-table3');\n\nconst ansistyles = require('ansistyles');\n\nconst {\n  v4: isCidrV4,\n  v6: isCidrV6\n} = require('is-cidr');\n\nconst log = require('npmlog');\n\nconst profile = require('npm-profile');\n\nconst otplease = require('./utils/otplease.js');\n\nconst pulseTillDone = require('./utils/pulse-till-done.js');\n\nconst readUserInfo = require('./utils/read-user-info.js');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Token extends BaseCommand {\n  static get description() {\n    return 'Manage your authentication tokens';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'token';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['list', 'revoke <id|token>', 'create [--read-only] [--cidr=list]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['read-only', 'cidr', 'registry', 'otp'];\n  }\n\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n    const subcommands = ['list', 'revoke', 'create'];\n    if (argv.length === 2) return subcommands;\n    if (subcommands.includes(argv[2])) return [];\n    throw new Error(argv[2] + ' not recognized');\n  }\n\n  exec(args, cb) {\n    this.token(args).then(() => cb()).catch(cb);\n  }\n\n  async token(args, cb) {\n    log.gauge.show('token');\n    if (args.length === 0) return this.list();\n\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list();\n\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1));\n\n      case 'create':\n        return this.create(args.slice(1));\n\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`);\n    }\n  }\n\n  async list() {\n    const conf = this.config();\n    log.info('token', 'getting list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2));\n      return;\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'));\n      tokens.forEach(token => {\n        this.npm.output([token.key, token.token, token.created, token.readonly ? 'true' : 'false', token.cidr_whitelist ? token.cidr_whitelist.join(',') : ''].join('\\t'));\n      });\n      return;\n    }\n\n    this.generateTokenIds(tokens, 6);\n    const idWidth = tokens.reduce((acc, token) => Math.max(acc, token.id.length), 0);\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10]\n    });\n    tokens.forEach(token => {\n      table.push([token.id, token.token + 'â€¦', String(token.created).slice(0, 10), token.readonly ? 'yes' : 'no', token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '']);\n    });\n    this.npm.output(table.toString());\n  }\n\n  async rm(args) {\n    if (args.length === 0) throw this.usageError('`<tokenKey>` argument is required.');\n    const conf = this.config();\n    const toRemove = [];\n    const progress = log.newItem('removing tokens', toRemove.length);\n    progress.info('token', 'getting existing list');\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));\n    args.forEach(id => {\n      const matches = tokens.filter(token => token.key.indexOf(id) === 0);\n      if (matches.length === 1) toRemove.push(matches[0].key);else if (matches.length > 1) throw new Error(`Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`);else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0);\n        if (!tokenMatches) throw new Error(`Unknown token id or value \"${id}\".`);\n        toRemove.push(id);\n      }\n    });\n    await Promise.all(toRemove.map(key => {\n      return otplease(conf, conf => {\n        return profile.removeToken(key, conf);\n      });\n    }));\n    if (conf.json) this.npm.output(JSON.stringify(toRemove));else if (conf.parseable) this.npm.output(toRemove.join('\\t'));else this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''));\n  }\n\n  async create(args) {\n    const conf = this.config();\n    const cidr = conf.cidr;\n    const readonly = conf.readOnly;\n    return readUserInfo.password().then(password => {\n      const validCIDR = this.validateCIDRList(cidr);\n      log.info('token', 'creating');\n      return pulseTillDone.withPromise(otplease(conf, conf => {\n        return profile.createToken(password, readonly, validCIDR, conf);\n      }));\n    }).then(result => {\n      delete result.key;\n      delete result.updated;\n      if (conf.json) this.npm.output(JSON.stringify(result));else if (conf.parseable) Object.keys(result).forEach(k => this.npm.output(k + '\\t' + result[k]));else {\n        const table = new Table();\n\n        for (const k of Object.keys(result)) table.push({\n          [ansistyles.bright(k)]: String(result[k])\n        });\n\n        this.npm.output(table.toString());\n      }\n    });\n  }\n\n  config() {\n    const conf = { ...this.npm.flatOptions\n    };\n    const creds = this.npm.config.getCredentialsByURI(conf.registry);\n    if (creds.token) conf.auth = {\n      token: creds.token\n    };else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password\n        }\n      };\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2);\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1]\n        }\n      };\n    } else conf.auth = {};\n    if (conf.otp) conf.auth.otp = conf.otp;\n    return conf;\n  }\n\n  invalidCIDRError(msg) {\n    return Object.assign(new Error(msg), {\n      code: 'EINVALIDCIDR'\n    });\n  }\n\n  generateTokenIds(tokens, minLength) {\n    const byId = {};\n\n    for (const token of tokens) {\n      token.id = token.key;\n\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii));\n\n        if (!match) {\n          token.id = token.key.slice(0, ii);\n          break;\n        }\n      }\n\n      byId[token.id] = token;\n    }\n\n    return byId;\n  }\n\n  validateCIDRList(cidrs) {\n    const maybeList = cidrs ? Array.isArray(cidrs) ? cidrs : [cidrs] : [];\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList;\n\n    for (const cidr of list) {\n      if (isCidrV6(cidr)) throw this.invalidCIDRError('CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6');\n      if (!isCidrV4(cidr)) throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr);\n    }\n\n    return list;\n  }\n\n}\n\nmodule.exports = Token;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/token.js"],"names":["Table","require","ansistyles","v4","isCidrV4","v6","isCidrV6","log","profile","otplease","pulseTillDone","readUserInfo","BaseCommand","Token","description","name","usage","params","completion","opts","argv","conf","remain","subcommands","length","includes","Error","exec","args","cb","token","then","catch","gauge","show","list","rm","slice","create","usageError","config","info","tokens","withPromise","listTokens","json","npm","output","JSON","stringify","parseable","join","forEach","key","created","readonly","cidr_whitelist","generateTokenIds","idWidth","reduce","acc","Math","max","id","table","head","colWidths","push","String","toString","toRemove","progress","newItem","matches","filter","indexOf","tokenMatches","some","t","Promise","all","map","removeToken","cidr","readOnly","password","validCIDR","validateCIDRList","createToken","result","updated","Object","keys","k","bright","flatOptions","creds","getCredentialsByURI","registry","auth","username","basic","Buffer","from","split","otp","invalidCIDRError","msg","assign","code","minLength","byId","ii","match","ot","cidrs","maybeList","Array","isArray","module","exports"],"mappings":"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","sourcesContent":["const Table = require('cli-table3')\nconst ansistyles = require('ansistyles')\nconst { v4: isCidrV4, v6: isCidrV6 } = require('is-cidr')\nconst log = require('npmlog')\nconst profile = require('npm-profile')\n\nconst otplease = require('./utils/otplease.js')\nconst pulseTillDone = require('./utils/pulse-till-done.js')\nconst readUserInfo = require('./utils/read-user-info.js')\n\nconst BaseCommand = require('./base-command.js')\nclass Token extends BaseCommand {\n  static get description () {\n    return 'Manage your authentication tokens'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'token'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      'list',\n      'revoke <id|token>',\n      'create [--read-only] [--cidr=list]',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'read-only',\n      'cidr',\n      'registry',\n      'otp',\n    ]\n  }\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n    const subcommands = ['list', 'revoke', 'create']\n    if (argv.length === 2)\n      return subcommands\n\n    if (subcommands.includes(argv[2]))\n      return []\n\n    throw new Error(argv[2] + ' not recognized')\n  }\n\n  exec (args, cb) {\n    this.token(args).then(() => cb()).catch(cb)\n  }\n\n  async token (args, cb) {\n    log.gauge.show('token')\n    if (args.length === 0)\n      return this.list()\n    switch (args[0]) {\n      case 'list':\n      case 'ls':\n        return this.list()\n      case 'delete':\n      case 'revoke':\n      case 'remove':\n      case 'rm':\n        return this.rm(args.slice(1))\n      case 'create':\n        return this.create(args.slice(1))\n      default:\n        throw this.usageError(`${args[0]} is not a recognized subcommand.`)\n    }\n  }\n\n  async list () {\n    const conf = this.config()\n    log.info('token', 'getting list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    if (conf.json) {\n      this.npm.output(JSON.stringify(tokens, null, 2))\n      return\n    } else if (conf.parseable) {\n      this.npm.output(['key', 'token', 'created', 'readonly', 'CIDR whitelist'].join('\\t'))\n      tokens.forEach((token) => {\n        this.npm.output([\n          token.key,\n          token.token,\n          token.created,\n          token.readonly ? 'true' : 'false',\n          token.cidr_whitelist ? token.cidr_whitelist.join(',') : '',\n        ].join('\\t'))\n      })\n      return\n    }\n    this.generateTokenIds(tokens, 6)\n    const idWidth = tokens.reduce((acc, token) =>\n      Math.max(acc, token.id.length), 0)\n    const table = new Table({\n      head: ['id', 'token', 'created', 'readonly', 'CIDR whitelist'],\n      colWidths: [Math.max(idWidth, 2) + 2, 9, 12, 10],\n    })\n    tokens.forEach((token) => {\n      table.push([\n        token.id,\n        token.token + 'â€¦',\n        String(token.created).slice(0, 10),\n        token.readonly ? 'yes' : 'no',\n        token.cidr_whitelist ? token.cidr_whitelist.join(', ') : '',\n      ])\n    })\n    this.npm.output(table.toString())\n  }\n\n  async rm (args) {\n    if (args.length === 0)\n      throw this.usageError('`<tokenKey>` argument is required.')\n\n    const conf = this.config()\n    const toRemove = []\n    const progress = log.newItem('removing tokens', toRemove.length)\n    progress.info('token', 'getting existing list')\n    const tokens = await pulseTillDone.withPromise(profile.listTokens(conf))\n    args.forEach((id) => {\n      const matches = tokens.filter((token) => token.key.indexOf(id) === 0)\n      if (matches.length === 1)\n        toRemove.push(matches[0].key)\n      else if (matches.length > 1)\n        throw new Error(`Token ID \"${id}\" was ambiguous, a new token may have been created since you last ran \\`npm token list\\`.`)\n      else {\n        const tokenMatches = tokens.some(t => id.indexOf(t.token) === 0)\n        if (!tokenMatches)\n          throw new Error(`Unknown token id or value \"${id}\".`)\n\n        toRemove.push(id)\n      }\n    })\n    await Promise.all(toRemove.map(key => {\n      return otplease(conf, conf => {\n        return profile.removeToken(key, conf)\n      })\n    }))\n    if (conf.json)\n      this.npm.output(JSON.stringify(toRemove))\n    else if (conf.parseable)\n      this.npm.output(toRemove.join('\\t'))\n    else\n      this.npm.output('Removed ' + toRemove.length + ' token' + (toRemove.length !== 1 ? 's' : ''))\n  }\n\n  async create (args) {\n    const conf = this.config()\n    const cidr = conf.cidr\n    const readonly = conf.readOnly\n\n    return readUserInfo.password().then((password) => {\n      const validCIDR = this.validateCIDRList(cidr)\n      log.info('token', 'creating')\n      return pulseTillDone.withPromise(otplease(conf, conf => {\n        return profile.createToken(password, readonly, validCIDR, conf)\n      }))\n    }).then((result) => {\n      delete result.key\n      delete result.updated\n      if (conf.json)\n        this.npm.output(JSON.stringify(result))\n      else if (conf.parseable)\n        Object.keys(result).forEach((k) => this.npm.output(k + '\\t' + result[k]))\n      else {\n        const table = new Table()\n        for (const k of Object.keys(result))\n          table.push({ [ansistyles.bright(k)]: String(result[k]) })\n        this.npm.output(table.toString())\n      }\n    })\n  }\n\n  config () {\n    const conf = { ...this.npm.flatOptions }\n    const creds = this.npm.config.getCredentialsByURI(conf.registry)\n    if (creds.token)\n      conf.auth = { token: creds.token }\n    else if (creds.username) {\n      conf.auth = {\n        basic: {\n          username: creds.username,\n          password: creds.password,\n        },\n      }\n    } else if (creds.auth) {\n      const auth = Buffer.from(creds.auth, 'base64').toString().split(':', 2)\n      conf.auth = {\n        basic: {\n          username: auth[0],\n          password: auth[1],\n        },\n      }\n    } else\n      conf.auth = {}\n\n    if (conf.otp)\n      conf.auth.otp = conf.otp\n    return conf\n  }\n\n  invalidCIDRError (msg) {\n    return Object.assign(new Error(msg), { code: 'EINVALIDCIDR' })\n  }\n\n  generateTokenIds (tokens, minLength) {\n    const byId = {}\n    for (const token of tokens) {\n      token.id = token.key\n      for (let ii = minLength; ii < token.key.length; ++ii) {\n        const match = tokens.some(ot =>\n          ot !== token &&\n          ot.key.slice(0, ii) === token.key.slice(0, ii))\n        if (!match) {\n          token.id = token.key.slice(0, ii)\n          break\n        }\n      }\n      byId[token.id] = token\n    }\n    return byId\n  }\n\n  validateCIDRList (cidrs) {\n    const maybeList = cidrs ? (Array.isArray(cidrs) ? cidrs : [cidrs]) : []\n    const list = maybeList.length === 1 ? maybeList[0].split(/,\\s*/) : maybeList\n    for (const cidr of list) {\n      if (isCidrV6(cidr))\n        throw this.invalidCIDRError('CIDR whitelist can only contain IPv4 addresses, ' + cidr + ' is IPv6')\n\n      if (!isCidrV4(cidr))\n        throw this.invalidCIDRError('CIDR whitelist contains invalid CIDR entry: ' + cidr)\n    }\n    return list\n  }\n}\nmodule.exports = Token\n"]},"metadata":{},"sourceType":"script"}