{"ast":null,"code":"// mixin implementing the reify method\nconst onExit = require('../signal-handling.js');\n\nconst pacote = require('pacote');\n\nconst AuditReport = require('../audit-report.js');\n\nconst {\n  subset,\n  intersects\n} = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst debug = require('../debug.js');\n\nconst walkUp = require('walk-up-path');\n\nconst {\n  dirname,\n  resolve,\n  relative\n} = require('path');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst fs = require('fs');\n\nconst {\n  promisify\n} = require('util');\n\nconst lstat = promisify(fs.lstat);\nconst symlink = promisify(fs.symlink);\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst justMkdirp = require('mkdirp');\n\nconst moveFile = require('@npmcli/move-file');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst PackageJson = require('@npmcli/package-json');\n\nconst packageContents = require('@npmcli/installed-package-contents');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst _force = Symbol.for('force');\n\nconst treeCheck = require('../tree-check.js');\n\nconst relpath = require('../relpath.js');\n\nconst Diff = require('../diff.js');\n\nconst retirePath = require('../retire-path.js');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst optionalSet = require('../optional-set.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst {\n  saveTypeMap,\n  hasSubKey\n} = require('../add-rm-pkg-deps.js');\n\nconst _retiredPaths = Symbol('retiredPaths');\n\nconst _retiredUnchanged = Symbol('retiredUnchanged');\n\nconst _sparseTreeDirs = Symbol('sparseTreeDirs');\n\nconst _sparseTreeRoots = Symbol('sparseTreeRoots');\n\nconst _savePrefix = Symbol('savePrefix');\n\nconst _retireShallowNodes = Symbol.for('retireShallowNodes');\n\nconst _getBundlesByDepth = Symbol('getBundlesByDepth');\n\nconst _registryResolved = Symbol('registryResolved');\n\nconst _addNodeToTrashList = Symbol('addNodeToTrashList');\n\nconst _workspaces = Symbol.for('workspaces'); // shared by rebuild mixin\n\n\nconst _trashList = Symbol.for('trashList');\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _loadTrees = Symbol.for('loadTrees'); // shared symbols for swapping out when testing\n\n\nconst _diffTrees = Symbol.for('diffTrees');\n\nconst _createSparseTree = Symbol.for('createSparseTree');\n\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees');\n\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated');\n\nconst _bundleUnpacked = Symbol('bundleUnpacked');\n\nconst _bundleMissing = Symbol('bundleMissing');\n\nconst _reifyNode = Symbol.for('reifyNode');\n\nconst _extractOrLink = Symbol('extractOrLink'); // defined by rebuild mixin\n\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _symlink = Symbol('symlink');\n\nconst _warnDeprecated = Symbol('warnDeprecated');\n\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees');\n\nconst _submitQuickAudit = Symbol('submitQuickAudit');\n\nconst _awaitQuickAudit = Symbol('awaitQuickAudit');\n\nconst _unpackNewModules = Symbol.for('unpackNewModules');\n\nconst _moveContents = Symbol.for('moveContents');\n\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged');\n\nconst _build = Symbol.for('build');\n\nconst _removeTrash = Symbol.for('removeTrash');\n\nconst _renamePath = Symbol.for('renamePath');\n\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes');\n\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree');\n\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged');\n\nconst _saveIdealTree = Symbol.for('saveIdealTree');\n\nconst _saveLockFile = Symbol('saveLockFile');\n\nconst _copyIdealToActual = Symbol('copyIdealToActual');\n\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList');\n\nconst _packageLockOnly = Symbol('packageLockOnly');\n\nconst _dryRun = Symbol('dryRun');\n\nconst _validateNodeModules = Symbol('validateNodeModules');\n\nconst _nmValidated = Symbol('nmValidated');\n\nconst _validatePath = Symbol('validatePath');\n\nconst _reifyPackages = Symbol.for('reifyPackages');\n\nconst _omitDev = Symbol('omitDev');\n\nconst _omitOptional = Symbol('omitOptional');\n\nconst _omitPeer = Symbol('omitPeer');\n\nconst _global = Symbol.for('global');\n\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps'); // defined by Ideal mixin\n\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _formatPackageLock = Symbol.for('formatPackageLock');\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true\n    } = options;\n    this[_dryRun] = !!dryRun;\n    this[_packageLockOnly] = !!packageLockOnly;\n    this[_savePrefix] = savePrefix;\n    this[_formatPackageLock] = !!formatPackageLock;\n    this.diff = null;\n    this[_retiredPaths] = {};\n    this[_shrinkwrapInflated] = new Set();\n    this[_retiredUnchanged] = {};\n    this[_sparseTreeDirs] = new Set();\n    this[_sparseTreeRoots] = new Set();\n    this[_trashList] = new Set(); // the nodes we unpack to read their bundles\n\n    this[_bundleUnpacked] = new Set(); // child nodes we'd EXPECT to be included in a bundle, but aren't\n\n    this[_bundleMissing] = new Set();\n    this[_nmValidated] = new Set();\n  } // public method\n\n\n  async reify(options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages');\n      er.code = 'ESHRINKWRAPGLOBAL';\n      throw er;\n    }\n\n    const omit = new Set(options.omit || []);\n    this[_omitDev] = omit.has('dev');\n    this[_omitOptional] = omit.has('optional');\n    this[_omitPeer] = omit.has('peer'); // start tracker block\n\n    this.addTracker('reify');\n    process.emit('time', 'reify');\n    await this[_validatePath]();\n    await this[_loadTrees](options);\n    await this[_diffTrees]();\n    await this[_reifyPackages]();\n    await this[_saveIdealTree](options);\n    await this[_copyIdealToActual]();\n    await this[_awaitQuickAudit]();\n    this.finishTracker('reify');\n    process.emit('timeEnd', 'reify');\n    return treeCheck(this.actualTree);\n  }\n\n  async [_validatePath]() {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return;\n    } // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n\n\n    await justMkdirp(resolve(this.path)); // do not allow the top-level node_modules to be a symlink\n\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'));\n  }\n\n  async [_reifyPackages]() {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return;\n    }\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]();\n    } // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n\n\n    let reifyTerminated = null;\n    const removeHandler = onExit(({\n      signal\n    }) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler();\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal\n      });\n      return false;\n    }); // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n\n    const steps = [[_rollbackRetireShallowNodes, [_retireShallowNodes]], [_rollbackCreateSparseTree, [_createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules]], [_rollbackMoveBackRetiredUnchanged, [_moveBackRetiredUnchanged, _build]]];\n\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]();\n\n          if (reifyTerminated) {\n            throw reifyTerminated;\n          }\n        } catch (er) {\n          await this[rollback](er);\n          /* istanbul ignore next - rollback throws, should never hit this */\n\n          throw er;\n        }\n      }\n    } // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n\n\n    await this[_removeTrash]();\n\n    if (reifyTerminated) {\n      throw reifyTerminated;\n    } // done modifying the file system, no need to keep listening for sigs\n\n\n    removeHandler();\n  } // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n\n\n  [_loadTrees](options) {\n    process.emit('time', 'reify:loadTrees');\n    const bitOpt = { ...options,\n      complete: this[_packageLockOnly] || this[_dryRun]\n    }; // if we're only writing a package lock, then it doesn't matter what's here\n\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true;\n        } // if we added it as an edgeOut, then we want it\n\n\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true;\n        } // if it's an explicit request, then we want it\n\n\n        const hasExplicit = [...this.explicitRequests].some(edge => edge.name === kid);\n\n        if (hasExplicit) {\n          return true;\n        } // ignore the rest of the global install folder\n\n\n        return false;\n      }\n    } : {\n      ignoreMissing: true\n    };\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)]).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    } // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n\n\n    return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n  }\n\n  [_diffTrees]() {\n    if (this[_packageLockOnly]) {\n      return;\n    }\n\n    process.emit('time', 'reify:diffTrees'); // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = [];\n\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target;\n      const actualTree = this.actualTree.target; // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n\n      for (const {\n        name\n      } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name);\n\n        if (ideal) {\n          filterNodes.push(ideal);\n        }\n\n        const actual = actualTree.children.get(name);\n\n        if (actual) {\n          filterNodes.push(actual);\n        }\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws);\n\n        if (ideal) {\n          filterNodes.push(ideal);\n        }\n\n        const actual = this.actualTree.children.get(ws);\n\n        if (actual) {\n          filterNodes.push(actual);\n        }\n      }\n    } // find all the nodes that need to change between the actual\n    // and ideal trees.\n\n\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree\n    }); // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees');\n  } // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n\n\n  [_addNodeToTrashList](node, retire = false) {\n    const paths = [node.path, ...node.binPaths];\n    const moves = this[_retiredPaths];\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths);\n\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path);\n        moves[path] = retired;\n\n        this[_trashList].add(retired);\n      } else {\n        this[_trashList].add(path);\n      }\n    }\n  } // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n\n\n  [_retireShallowNodes]() {\n    process.emit('time', 'reify:retireShallow');\n    const moves = this[_retiredPaths] = {};\n\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true);\n      }\n    }\n\n    this.log.silly('reify', 'moves', moves);\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](from, to));\n    return promiseAllRejectLate(movePromises).then(() => process.emit('timeEnd', 'reify:retireShallow'));\n  }\n\n  [_renamePath](from, to, didMkdirp = false) {\n    return moveFile(from, to).catch(er => {\n      // Occasionally an expected bin file might not exist in the package,\n      // or a shim/symlink might have been moved aside.  If we've already\n      // handled the most common cause of ENOENT (dir doesn't exist yet),\n      // then just ignore any ENOENT.\n      if (er.code === 'ENOENT') {\n        return didMkdirp ? null : mkdirp(dirname(to)).then(() => this[_renamePath](from, to, true));\n      } else if (er.code === 'EEXIST') {\n        return rimraf(to).then(() => moveFile(from, to));\n      } else {\n        throw er;\n      }\n    });\n  }\n\n  [_rollbackRetireShallowNodes](er) {\n    process.emit('time', 'reify:rollback:retireShallow');\n    const moves = this[_retiredPaths];\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](to, from));\n    return promiseAllRejectLate(movePromises) // ignore subsequent rollback errors\n    .catch(er => {}).then(() => process.emit('timeEnd', 'reify:rollback:retireShallow')).then(() => {\n      throw er;\n    });\n  } // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n\n\n  [_addOmitsToTrashList]() {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return;\n    }\n\n    process.emit('time', 'reify:trashOmits');\n\n    const filter = node => node.top.isProjectRoot && (node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev]);\n\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node);\n    }\n\n    process.emit('timeEnd', 'reify:trashOmits');\n  }\n\n  [_createSparseTree]() {\n    process.emit('time', 'reify:createSparse'); // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n\n    const leaves = this.diff.leaves.filter(diff => {\n      return (diff.action === 'ADD' || diff.action === 'CHANGE') && !this[_sparseTreeDirs].has(diff.ideal.path) && !diff.ideal.isLink;\n    }).map(diff => diff.ideal); // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n\n    const dirsChecked = new Set();\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break;\n        }\n\n        if (dirsChecked.has(d)) {\n          continue;\n        }\n\n        dirsChecked.add(d);\n        const st = await lstat(d).catch(er => null); // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n\n        /* istanbul ignore next - defense in depth */\n\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d);\n          this[_retiredPaths][d] = retired;\n\n          this[_trashList].add(retired);\n\n          await this[_renamePath](d, retired);\n        }\n      }\n\n      const made = await mkdirp(node.path);\n\n      this[_sparseTreeDirs].add(node.path);\n\n      this[_sparseTreeRoots].add(made);\n    })).then(() => process.emit('timeEnd', 'reify:createSparse'));\n  }\n\n  [_rollbackCreateSparseTree](er) {\n    process.emit('time', 'reify:rollback:createSparse'); // cut the roots of the sparse tree that were created, not the leaves\n\n    const roots = this[_sparseTreeRoots]; // also delete the moves that we retired, so that we can move them back\n\n    const failures = [];\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])];\n    const unlinks = targets.map(path => rimraf(path).catch(er => failures.push([path, er])));\n    return promiseAllRejectLate(unlinks).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:rollback:createSparse')).then(() => this[_rollbackRetireShallowNodes](er));\n  } // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n\n\n  [_loadShrinkwrapsAndUpdateTrees]() {\n    const seen = this[_shrinkwrapInflated];\n    const shrinkwraps = this.diff.leaves.filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));\n\n    if (!shrinkwraps.length) {\n      return;\n    }\n\n    process.emit('time', 'reify:loadShrinkwraps');\n    const Arborist = this.constructor;\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal;\n      seen.add(node);\n      return diff.action ? this[_reifyNode](node) : node;\n    })).then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({ ...this.options,\n      path: node.path\n    }).loadVirtual({\n      root: node\n    })))) // reload the diff and sparse tree because the ideal tree changed\n    .then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'));\n  } // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n\n\n  [_reifyNode](node) {\n    if (this[_trashList].has(node.path)) {\n      return node;\n    }\n\n    const timer = `reifyNode:${node.location}`;\n    process.emit('time', timer);\n    this.addTracker('reify', node.name, node.location);\n    const {\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const p = Promise.resolve().then(async () => {\n      // when we reify an optional node, check the engine and platform\n      // first. be sure to ignore the --force and --engine-strict flags,\n      // since we always want to skip any optional packages we can't install.\n      // these checks throwing will result in a rollback and removal\n      // of the mismatches\n      if (node.optional) {\n        checkEngine(node.package, npmVersion, nodeVersion, false);\n        checkPlatform(node.package, false);\n      }\n\n      await this[_checkBins](node);\n      await this[_extractOrLink](node);\n      await this[_warnDeprecated](node);\n    });\n    return this[_handleOptionalFailure](node, p).then(() => {\n      this.finishTracker('reify', node.name, node.location);\n      process.emit('timeEnd', timer);\n      return node;\n    });\n  } // do not allow node_modules to be a symlink\n\n\n  async [_validateNodeModules](nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return;\n    }\n\n    const st = await lstat(nm).catch(() => null);\n\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm);\n\n      return;\n    }\n\n    this.log.warn('reify', 'Removing non-directory', nm);\n    await rimraf(nm);\n  }\n\n  async [_extractOrLink](node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}` : node.packageName && node.version ? `${node.packageName}@${node.version}` : null; // no idea what this thing is.  remove it from the tree.\n\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' + 'please re-try this operation once it completes\\n' + 'so that the damage can be corrected, or perform\\n' + 'a fresh install with no lockfile if the problem persists.';\n      this.log.warn('reify', warning);\n      this.log.verbose('reify', 'unrecognized node in tree', node.path);\n      node.parent = null;\n      node.fsParent = null;\n\n      this[_addNodeToTrashList](node);\n\n      return;\n    }\n\n    const nm = resolve(node.parent.path, 'node_modules');\n    await this[_validateNodeModules](nm);\n\n    if (node.isLink) {\n      await rimraf(node.path);\n      await this[_symlink](node);\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null);\n\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node);\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path\n          });\n        }\n      });\n      await pacote.extract(res, node.path, { ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity\n      });\n    }\n  }\n\n  async [_symlink](node) {\n    const dir = dirname(node.path);\n    const target = node.realpath;\n    const rel = relative(dir, target);\n    await mkdirp(dir);\n    return symlink(rel, node.path, 'junction');\n  }\n\n  [_warnDeprecated](node) {\n    const {\n      _id,\n      deprecated\n    } = node.package;\n\n    if (deprecated) {\n      this.log.warn('deprecated', `${_id}: ${deprecated}`);\n    }\n  } // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n\n\n  [_handleOptionalFailure](node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node);\n\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path);\n\n        this[_addNodeToTrashList](node);\n      }\n    }) : p).then(() => node);\n  }\n\n  [_registryResolved](resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved.replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry);\n  } // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n\n\n  [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth = this[_getBundlesByDepth]()) {\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles');\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth');\n\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth);\n\n        this[_diffTrees]();\n      }\n\n      process.emit('timeEnd', 'reify:loadBundles');\n      return;\n    } // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n\n\n    const set = (bundlesByDepth.get(depth) || []).filter(node => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path));\n\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth);\n    } // extract all the nodes with bundles\n\n\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node);\n\n      return this[_reifyNode](node);\n    })) // then load their unpacked children and move into the ideal tree\n    .then(nodes => promiseAllRejectLate(nodes.map(async node => {\n      const arb = new this.constructor({ ...this.options,\n        path: node.path\n      });\n      const notTransplanted = new Set(node.children.keys());\n      await arb.loadActual({\n        root: node,\n        // don't transplant any sparse folders we created\n        // loadActual will set node.package to {} for empty directories\n        // if by chance there are some empty folders in the node_modules\n        // tree for some other reason, then ok, ignore those too.\n        transplantFilter: node => {\n          if (node.package._id) {\n            // it's actually in the bundle if it gets transplanted\n            notTransplanted.delete(node.name);\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n\n      for (const name of notTransplanted) {\n        this[_bundleMissing].add(node.children.get(name));\n      }\n    }))) // move onto the next level of bundled items\n    .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));\n  }\n\n  [_getBundlesByDepth]() {\n    const bundlesByDepth = new Map();\n    let maxBundleDepth = -1;\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal;\n\n        if (!node) {\n          return;\n        }\n\n        if (node.isProjectRoot) {\n          return;\n        }\n\n        const {\n          bundleDependencies\n        } = node.package;\n\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth);\n\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node]);\n          } else {\n            bundlesByDepth.get(node.depth).push(node);\n          }\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth);\n    return bundlesByDepth;\n  } // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n\n\n  [_pruneBundledMetadeps](bundlesByDepth) {\n    const bundleShadowed = new Set(); // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n    // create the list of nodes shadowed by children of bundlers\n\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue;\n      }\n\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name);\n\n          if (!shadow) {\n            continue;\n          }\n\n          bundleShadowed.add(shadow);\n          shadow.extraneous = true;\n        }\n      }\n    } // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n\n\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to);\n          shadDep.to.extraneous = true;\n        }\n      }\n    }\n\n    let changed;\n\n    do {\n      changed = false;\n\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false;\n            bundleShadowed.delete(shadow);\n            changed = true;\n            break;\n          }\n        }\n      }\n    } while (changed);\n\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow);\n\n      shadow.root = null;\n    }\n  }\n\n  [_submitQuickAudit]() {\n    if (this.options.audit === false) {\n      return this.auditReport = null;\n    } // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n\n\n    process.emit('time', 'reify:audit');\n    const options = { ...this.options\n    };\n    const tree = this.idealTree; // if we're operating on a workspace, only audit the workspace deps\n\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces]);\n    }\n\n    this.auditReport = AuditReport.load(tree, options).then(res => {\n      process.emit('timeEnd', 'reify:audit');\n      this.auditReport = res;\n    });\n  } // return the promise if we're waiting for it, or the replaced result\n\n\n  [_awaitQuickAudit]() {\n    return this.auditReport;\n  } // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n\n\n  [_unpackNewModules]() {\n    process.emit('time', 'reify:unpack');\n    const unpacks = [];\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return;\n        }\n\n        const node = diff.ideal;\n\n        const bd = this[_bundleUnpacked].has(node);\n\n        const sw = this[_shrinkwrapInflated].has(node);\n\n        const bundleMissing = this[_bundleMissing].has(node); // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n\n\n        const doUnpack = node && // can't unpack if removed!\n        // root node already exists\n        !node.isRoot && // already unpacked to read bundle\n        !bd && // already unpacked to read sw\n        !sw && (bundleMissing || !node.inDepBundle);\n\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node));\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    return promiseAllRejectLate(unpacks).then(() => process.emit('timeEnd', 'reify:unpack'));\n  } // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n\n\n  [_moveBackRetiredUnchanged]() {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire');\n    const moves = this[_retiredPaths];\n    this[_retiredUnchanged] = {};\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return;\n      }\n\n      const {\n        path: realFolder\n      } = diff.actual;\n      const retireFolder = moves[realFolder];\n      /* istanbul ignore next - should be impossible */\n\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired');\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action\n          });\n        }\n      });\n      this[_retiredUnchanged][retireFolder] = [];\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node));\n        } // will have been moved/unpacked along with bundler\n\n\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return;\n        }\n\n        this[_retiredUnchanged][retireFolder].push(node);\n\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel); // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n\n        const bd = node.package.bundleDependencies;\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path;\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath));\n      }));\n    })).then(() => process.emit('timeEnd', 'reify:unretire'));\n  } // move the contents from the fromPath to the node.path\n\n\n  [_moveContents](node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]])\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path);\n      const to = resolve(node.path, rel);\n      return this[_renamePath](path, to);\n    })));\n  }\n\n  [_rollbackMoveBackRetiredUnchanged](er) {\n    const moves = this[_retiredPaths]; // flip the mapping around to go back\n\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]));\n    const promises = Object.entries(this[_retiredUnchanged]).map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n      const realFolder = realFolders.get(retireFolder);\n      const rel = relative(realFolder, node.path);\n      const fromPath = resolve(retireFolder, rel);\n      return this[_moveContents]({ ...node,\n        path: fromPath\n      }, node.path);\n    })));\n    return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));\n  }\n\n  [_build]() {\n    process.emit('time', 'reify:build'); // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n\n    const nodes = [];\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal);\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE'\n    }); // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target; // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n\n      if (node.isLink && node.target.fsTop === tree) {\n        nodes.push(node);\n      }\n    }\n\n    return this.rebuild({\n      nodes,\n      handleOptionalFailure: true\n    }).then(() => process.emit('timeEnd', 'reify:build'));\n  } // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n\n\n  [_removeTrash]() {\n    process.emit('time', 'reify:trash');\n    const promises = [];\n    const failures = [];\n\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]));\n\n    for (const path of this[_trashList]) {\n      promises.push(rm(path));\n    }\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures);\n      }\n    }).then(() => process.emit('timeEnd', 'reify:trash'));\n  } // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n\n\n  async [_saveIdealTree](options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) {\n      return false;\n    }\n\n    process.emit('time', 'reify:save');\n    const updatedTrees = new Set(); // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n\n    if (this[_resolvedAdd].length) {\n      for (const {\n        name,\n        tree: addTree\n      } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name);\n        const pkg = addTree.package;\n        const req = npa.resolve(name, edge.spec, addTree.realpath);\n        const {\n          rawSpec,\n          subSpec\n        } = req;\n        const spec = subSpec ? subSpec.rawSpec : rawSpec;\n        const child = edge.to; // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n\n        if (!child) {\n          continue;\n        }\n\n        let newSpec;\n\n        if (req.registry) {\n          const version = child.version;\n          const prefixRange = version ? this[_savePrefix] + version : '*'; // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n\n          const isRange = (subSpec || req).type === 'range';\n          let range = spec;\n\n          if (!isRange || spec === '*' || subset(prefixRange, spec, {\n            loose: true\n          })) {\n            range = prefixRange;\n          }\n\n          const pname = child.packageName;\n          const alias = name !== pname;\n          newSpec = alias ? `npm:${pname}@${range}` : range;\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted;\n          const opt = {\n            noCommittish: false\n          };\n\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`;\n          } else {\n            newSpec = h.shortcut(opt);\n          }\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '');\n          const rel = relpath(addTree.realpath, p);\n          newSpec = `file:${rel}`;\n        } else {\n          newSpec = req.saveSpec;\n        }\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType);\n          pkg[depType][name] = newSpec; // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name];\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec;\n          }\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec; // don't update peer or optional if we don't have to\n\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name])) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name])) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec;\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec;\n            }\n          }\n        }\n\n        updatedTrees.add(addTree);\n      }\n    } // preserve indentation, if possible\n\n\n    const {\n      [Symbol.for('indent')]: indent\n    } = this.idealTree.package;\n    const format = indent === undefined ? '  ' : indent;\n    const saveOpt = {\n      format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]\n    };\n    const promises = [this[_saveLockFile](saveOpt)];\n\n    const updatePackageJson = async tree => {\n      const pkgJson = await PackageJson.load(tree.path).catch(() => new PackageJson(tree.path));\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {}\n      } = tree.package;\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies\n      });\n      await pkgJson.save();\n    }; // grab any from explicitRequests that had deps removed\n\n\n    for (const {\n      from: tree\n    } of this.explicitRequests) {\n      updatedTrees.add(tree);\n    }\n\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package;\n      promises.push(updatePackageJson(tree));\n    }\n\n    await Promise.all(promises);\n    process.emit('timeEnd', 'reify:save');\n    return true;\n  }\n\n  async [_saveLockFile](saveOpt) {\n    if (!this[_usePackageLock]) {\n      return;\n    }\n\n    const {\n      meta\n    } = this.idealTree;\n    return meta.save(saveOpt);\n  }\n\n  async [_copyIdealToActual]() {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path);\n      const node = this.idealTree.inventory.get(loc);\n\n      if (node && node.root === this.idealTree) {\n        node.parent = null;\n      }\n    } // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n\n\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set();\n      const {\n        filterSet\n      } = this.diff;\n      const seen = new Set();\n\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc); // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n\n        if (filterSet.has(ideal)) {\n          continue;\n        } // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n\n\n        const actual = this.actualTree.inventory.get(loc);\n\n        if (!actual) {\n          ideal.root = null;\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location);\n            continue;\n          }\n\n          const {\n            realpath,\n            isLink\n          } = actual;\n\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue;\n          } else {\n            reroot.add(actual);\n          }\n        }\n      } // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n\n\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue;\n        }\n\n        seen.add(loc); // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n\n        if (filterSet.has(actual)) {\n          continue;\n        }\n\n        reroot.add(actual);\n      } // go through the rerooted actual nodes, and move them over.\n\n\n      for (const actual of reroot) {\n        actual.root = this.idealTree;\n      } // prune out any tops that lack a linkIn, they are no longer relevant.\n\n\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null;\n        }\n      } // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n\n\n      calcDepFlags(this.idealTree);\n    } // save the ideal's meta as a hidden lockfile after we actualize it\n\n\n    this.idealTree.meta.filename = this.idealTree.realpath + '/node_modules/.package-lock.json';\n    this.idealTree.meta.hiddenLockfile = true;\n    this.actualTree = this.idealTree;\n    this.idealTree = null;\n\n    if (!this[_global]) {\n      await this.actualTree.meta.save();\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js"],"names":["onExit","require","pacote","AuditReport","subset","intersects","npa","debug","walkUp","dirname","resolve","relative","depth","dfwalk","fs","promisify","lstat","symlink","mkdirp","justMkdirp","moveFile","rimraf","PackageJson","packageContents","checkEngine","checkPlatform","_force","Symbol","for","treeCheck","relpath","Diff","retirePath","promiseAllRejectLate","optionalSet","calcDepFlags","saveTypeMap","hasSubKey","_retiredPaths","_retiredUnchanged","_sparseTreeDirs","_sparseTreeRoots","_savePrefix","_retireShallowNodes","_getBundlesByDepth","_registryResolved","_addNodeToTrashList","_workspaces","_trashList","_handleOptionalFailure","_loadTrees","_diffTrees","_createSparseTree","_loadShrinkwrapsAndUpdateTrees","_shrinkwrapInflated","_bundleUnpacked","_bundleMissing","_reifyNode","_extractOrLink","_checkBins","_symlink","_warnDeprecated","_loadBundlesAndUpdateTrees","_submitQuickAudit","_awaitQuickAudit","_unpackNewModules","_moveContents","_moveBackRetiredUnchanged","_build","_removeTrash","_renamePath","_rollbackRetireShallowNodes","_rollbackCreateSparseTree","_rollbackMoveBackRetiredUnchanged","_saveIdealTree","_saveLockFile","_copyIdealToActual","_addOmitsToTrashList","_packageLockOnly","_dryRun","_validateNodeModules","_nmValidated","_validatePath","_reifyPackages","_omitDev","_omitOptional","_omitPeer","_global","_pruneBundledMetadeps","_resolvedAdd","_usePackageLock","_formatPackageLock","module","exports","cls","Reifier","constructor","options","savePrefix","packageLockOnly","dryRun","formatPackageLock","diff","Set","reify","er","Error","code","omit","has","addTracker","process","emit","finishTracker","actualTree","path","reifyTerminated","removeHandler","signal","Object","assign","steps","rollback","actions","action","bitOpt","complete","buildIdealTree","then","actualOpt","ignoreMissing","global","filter","node","kid","explicitRequests","size","isProjectRoot","idealTree","edgesOut","hasExplicit","some","edge","name","Promise","all","loadActual","filterNodes","target","ideal","children","get","push","actual","ws","calculate","shrinkwrapInflated","retire","paths","binPaths","moves","log","silly","retired","add","movePromises","entries","map","from","to","didMkdirp","catch","top","peer","dev","optional","devOptional","inventory","leaves","isLink","dirsChecked","d","st","isDirectory","made","roots","failures","targets","keys","unlinks","length","warn","seen","shrinkwraps","hasShrinkwrap","Arborist","nodes","loadVirtual","root","timer","location","npmVersion","nodeVersion","p","package","nm","res","resolved","packageName","version","warning","verbose","parent","fsParent","e","extract","integrity","dir","realpath","rel","_id","deprecated","set","replace","registry","bundlesByDepth","maxBundleDepth","arb","notTransplanted","transplantFilter","delete","Map","tree","visit","bundleDependencies","Math","max","getChildren","bundleShadowed","bundles","values","Array","isArray","shadow","extraneous","shadDep","changed","edgesIn","audit","auditReport","filterSet","workspaceDependencySet","load","unpacks","bd","sw","bundleMissing","doUnpack","isRoot","inDepBundle","realFolder","retireFolder","unchanged","fromPath","packageJsonCache","realFolders","k","v","promises","leave","fsTop","rebuild","handleOptionalFailure","rm","save","updatedTrees","addTree","pkg","req","spec","rawSpec","subSpec","child","newSpec","prefixRange","isRange","type","range","loose","pname","alias","hosted","h","opt","noCommittish","https","auth","shortcut","fetchSpec","saveSpec","saveType","depType","optionalDependencies","dependencies","devDependencies","peerDependencies","indent","format","undefined","saveOpt","updatePackageJson","pkgJson","update","meta","loc","reroot","linksIn","link","tops","filename","hiddenLockfile"],"mappings":"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","sourcesContent":["// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js')\nconst pacote = require('pacote')\nconst AuditReport = require('../audit-report.js')\nconst {subset, intersects} = require('semver')\nconst npa = require('npm-package-arg')\nconst debug = require('../debug.js')\nconst walkUp = require('walk-up-path')\n\nconst {dirname, resolve, relative} = require('path')\nconst {depth: dfwalk} = require('treeverse')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst lstat = promisify(fs.lstat)\nconst symlink = promisify(fs.symlink)\nconst mkdirp = require('mkdirp-infer-owner')\nconst justMkdirp = require('mkdirp')\nconst moveFile = require('@npmcli/move-file')\nconst rimraf = promisify(require('rimraf'))\nconst PackageJson = require('@npmcli/package-json')\nconst packageContents = require('@npmcli/installed-package-contents')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\nconst _force = Symbol.for('force')\n\nconst treeCheck = require('../tree-check.js')\nconst relpath = require('../relpath.js')\nconst Diff = require('../diff.js')\nconst retirePath = require('../retire-path.js')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst optionalSet = require('../optional-set.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst { saveTypeMap, hasSubKey } = require('../add-rm-pkg-deps.js')\n\nconst _retiredPaths = Symbol('retiredPaths')\nconst _retiredUnchanged = Symbol('retiredUnchanged')\nconst _sparseTreeDirs = Symbol('sparseTreeDirs')\nconst _sparseTreeRoots = Symbol('sparseTreeRoots')\nconst _savePrefix = Symbol('savePrefix')\nconst _retireShallowNodes = Symbol.for('retireShallowNodes')\nconst _getBundlesByDepth = Symbol('getBundlesByDepth')\nconst _registryResolved = Symbol('registryResolved')\nconst _addNodeToTrashList = Symbol('addNodeToTrashList')\nconst _workspaces = Symbol.for('workspaces')\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList')\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _loadTrees = Symbol.for('loadTrees')\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees')\nconst _createSparseTree = Symbol.for('createSparseTree')\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees')\nconst _shrinkwrapInflated = Symbol('shrinkwrapInflated')\nconst _bundleUnpacked = Symbol('bundleUnpacked')\nconst _bundleMissing = Symbol('bundleMissing')\nconst _reifyNode = Symbol.for('reifyNode')\nconst _extractOrLink = Symbol('extractOrLink')\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins')\nconst _symlink = Symbol('symlink')\nconst _warnDeprecated = Symbol('warnDeprecated')\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees')\nconst _submitQuickAudit = Symbol('submitQuickAudit')\nconst _awaitQuickAudit = Symbol('awaitQuickAudit')\nconst _unpackNewModules = Symbol.for('unpackNewModules')\nconst _moveContents = Symbol.for('moveContents')\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged')\nconst _build = Symbol.for('build')\nconst _removeTrash = Symbol.for('removeTrash')\nconst _renamePath = Symbol.for('renamePath')\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes')\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree')\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged')\nconst _saveIdealTree = Symbol.for('saveIdealTree')\nconst _saveLockFile = Symbol('saveLockFile')\nconst _copyIdealToActual = Symbol('copyIdealToActual')\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList')\nconst _packageLockOnly = Symbol('packageLockOnly')\nconst _dryRun = Symbol('dryRun')\nconst _validateNodeModules = Symbol('validateNodeModules')\nconst _nmValidated = Symbol('nmValidated')\nconst _validatePath = Symbol('validatePath')\nconst _reifyPackages = Symbol.for('reifyPackages')\n\nconst _omitDev = Symbol('omitDev')\nconst _omitOptional = Symbol('omitOptional')\nconst _omitPeer = Symbol('omitPeer')\n\nconst _global = Symbol.for('global')\n\nconst _pruneBundledMetadeps = Symbol('pruneBundledMetadeps')\n\n// defined by Ideal mixin\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _formatPackageLock = Symbol.for('formatPackageLock')\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true,\n    } = options\n\n    this[_dryRun] = !!dryRun\n    this[_packageLockOnly] = !!packageLockOnly\n    this[_savePrefix] = savePrefix\n    this[_formatPackageLock] = !!formatPackageLock\n\n    this.diff = null\n    this[_retiredPaths] = {}\n    this[_shrinkwrapInflated] = new Set()\n    this[_retiredUnchanged] = {}\n    this[_sparseTreeDirs] = new Set()\n    this[_sparseTreeRoots] = new Set()\n    this[_trashList] = new Set()\n    // the nodes we unpack to read their bundles\n    this[_bundleUnpacked] = new Set()\n    // child nodes we'd EXPECT to be included in a bundle, but aren't\n    this[_bundleMissing] = new Set()\n    this[_nmValidated] = new Set()\n  }\n\n  // public method\n  async reify (options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages')\n      er.code = 'ESHRINKWRAPGLOBAL'\n      throw er\n    }\n\n    const omit = new Set(options.omit || [])\n    this[_omitDev] = omit.has('dev')\n    this[_omitOptional] = omit.has('optional')\n    this[_omitPeer] = omit.has('peer')\n\n    // start tracker block\n    this.addTracker('reify')\n    process.emit('time', 'reify')\n    await this[_validatePath]()\n    await this[_loadTrees](options)\n    await this[_diffTrees]()\n    await this[_reifyPackages]()\n    await this[_saveIdealTree](options)\n    await this[_copyIdealToActual]()\n    await this[_awaitQuickAudit]()\n\n    this.finishTracker('reify')\n    process.emit('timeEnd', 'reify')\n    return treeCheck(this.actualTree)\n  }\n\n  async [_validatePath] () {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) {\n      return\n    }\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path))\n\n    // do not allow the top-level node_modules to be a symlink\n    await this[_validateNodeModules](resolve(this.path, 'node_modules'))\n  }\n\n  async [_reifyPackages] () {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) {\n      return\n    }\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]()\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null\n    const removeHandler = onExit(({signal}) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler()\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal,\n      })\n      return false\n    })\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [\n      [_rollbackRetireShallowNodes, [\n        _retireShallowNodes,\n      ]],\n      [_rollbackCreateSparseTree, [\n        _createSparseTree,\n        _addOmitsToTrashList,\n        _loadShrinkwrapsAndUpdateTrees,\n        _loadBundlesAndUpdateTrees,\n        _submitQuickAudit,\n        _unpackNewModules,\n      ]],\n      [_rollbackMoveBackRetiredUnchanged, [\n        _moveBackRetiredUnchanged,\n        _build,\n      ]],\n    ]\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]()\n          if (reifyTerminated) {\n            throw reifyTerminated\n          }\n        } catch (er) {\n          await this[rollback](er)\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]()\n    if (reifyTerminated) {\n      throw reifyTerminated\n    }\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler()\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees] (options) {\n    process.emit('time', 'reify:loadTrees')\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun],\n    }\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt)\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) {\n          return true\n        }\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid)) {\n          return true\n        }\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests]\n          .some(edge => edge.name === kid)\n        if (hasExplicit) {\n          return true\n        }\n\n        // ignore the rest of the global install folder\n        return false\n      },\n    } : { ignoreMissing: true }\n\n    if (!this[_global]) {\n      return Promise.all([\n        this.loadActual(actualOpt),\n        this.buildIdealTree(bitOpt),\n      ]).then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt)\n      .then(() => this.loadActual(actualOpt))\n      .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n  }\n\n  [_diffTrees] () {\n    if (this[_packageLockOnly]) {\n      return\n    }\n\n    process.emit('time', 'reify:diffTrees')\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = []\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target\n      const actualTree = this.actualTree.target\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const { name } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name)\n        if (ideal) {\n          filterNodes.push(ideal)\n        }\n        const actual = actualTree.children.get(name)\n        if (actual) {\n          filterNodes.push(actual)\n        }\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws)\n        if (ideal) {\n          filterNodes.push(ideal)\n        }\n        const actual = this.actualTree.children.get(ws)\n        if (actual) {\n          filterNodes.push(actual)\n        }\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      shrinkwrapInflated: this[_shrinkwrapInflated],\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree,\n    })\n\n    // we don't have to add 'removed' folders to the trashlist, because\n    // they'll be moved aside to a retirement folder, and then the retired\n    // folder will be deleted at the end.  This is important when we have\n    // a folder like FOO being \"removed\" in favor of a folder like \"foo\",\n    // because if we remove node_modules/FOO on case-insensitive systems,\n    // it will remove the dep that we *want* at node_modules/foo.\n\n    process.emit('timeEnd', 'reify:diffTrees')\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList] (node, retire = false) {\n    const paths = [node.path, ...node.binPaths]\n    const moves = this[_retiredPaths]\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths)\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path)\n        moves[path] = retired\n        this[_trashList].add(retired)\n      } else {\n        this[_trashList].add(path)\n      }\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes] () {\n    process.emit('time', 'reify:retireShallow')\n    const moves = this[_retiredPaths] = {}\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true)\n      }\n    }\n    this.log.silly('reify', 'moves', moves)\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](from, to))\n    return promiseAllRejectLate(movePromises)\n      .then(() => process.emit('timeEnd', 'reify:retireShallow'))\n  }\n\n  [_renamePath] (from, to, didMkdirp = false) {\n    return moveFile(from, to)\n      .catch(er => {\n        // Occasionally an expected bin file might not exist in the package,\n        // or a shim/symlink might have been moved aside.  If we've already\n        // handled the most common cause of ENOENT (dir doesn't exist yet),\n        // then just ignore any ENOENT.\n        if (er.code === 'ENOENT') {\n          return didMkdirp ? null : mkdirp(dirname(to)).then(() =>\n            this[_renamePath](from, to, true))\n        } else if (er.code === 'EEXIST') {\n          return rimraf(to).then(() => moveFile(from, to))\n        } else {\n          throw er\n        }\n      })\n  }\n\n  [_rollbackRetireShallowNodes] (er) {\n    process.emit('time', 'reify:rollback:retireShallow')\n    const moves = this[_retiredPaths]\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](to, from))\n    return promiseAllRejectLate(movePromises)\n      // ignore subsequent rollback errors\n      .catch(er => {})\n      .then(() => process.emit('timeEnd', 'reify:rollback:retireShallow'))\n      .then(() => {\n        throw er\n      })\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList] () {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) {\n      return\n    }\n\n    process.emit('time', 'reify:trashOmits')\n\n    const filter = node =>\n      node.top.isProjectRoot &&\n        (node.peer && this[_omitPeer] ||\n          node.dev && this[_omitDev] ||\n          node.optional && this[_omitOptional] ||\n          node.devOptional && this[_omitOptional] && this[_omitDev])\n\n    for (const node of this.idealTree.inventory.filter(filter)) {\n      this[_addNodeToTrashList](node)\n    }\n\n    process.emit('timeEnd', 'reify:trashOmits')\n  }\n\n  [_createSparseTree] () {\n    process.emit('time', 'reify:createSparse')\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const leaves = this.diff.leaves\n      .filter(diff => {\n        return (diff.action === 'ADD' || diff.action === 'CHANGE') &&\n          !this[_sparseTreeDirs].has(diff.ideal.path) &&\n          !diff.ideal.isLink\n      })\n      .map(diff => diff.ideal)\n\n    // we check this in parallel, so guard against multiple attempts to\n    // retire the same path at the same time.\n    const dirsChecked = new Set()\n    return promiseAllRejectLate(leaves.map(async node => {\n      for (const d of walkUp(node.path)) {\n        if (d === node.top.path) {\n          break\n        }\n        if (dirsChecked.has(d)) {\n          continue\n        }\n        dirsChecked.add(d)\n        const st = await lstat(d).catch(er => null)\n        // this can happen if we have a link to a package with a name\n        // that the filesystem treats as if it is the same thing.\n        // would be nice to have conditional istanbul ignores here...\n        /* istanbul ignore next - defense in depth */\n        if (st && !st.isDirectory()) {\n          const retired = retirePath(d)\n          this[_retiredPaths][d] = retired\n          this[_trashList].add(retired)\n          await this[_renamePath](d, retired)\n        }\n      }\n      const made = await mkdirp(node.path)\n      this[_sparseTreeDirs].add(node.path)\n      this[_sparseTreeRoots].add(made)\n    }))\n      .then(() => process.emit('timeEnd', 'reify:createSparse'))\n  }\n\n  [_rollbackCreateSparseTree] (er) {\n    process.emit('time', 'reify:rollback:createSparse')\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots]\n    // also delete the moves that we retired, so that we can move them back\n    const failures = []\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])]\n    const unlinks = targets\n      .map(path => rimraf(path).catch(er => failures.push([path, er])))\n    return promiseAllRejectLate(unlinks)\n      .then(() => {\n        if (failures.length) {\n          this.log.warn('cleanup', 'Failed to remove some directories', failures)\n        }\n      })\n      .then(() => process.emit('timeEnd', 'reify:rollback:createSparse'))\n      .then(() => this[_rollbackRetireShallowNodes](er))\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees] () {\n    const seen = this[_shrinkwrapInflated]\n    const shrinkwraps = this.diff.leaves\n      .filter(d => (d.action === 'CHANGE' || d.action === 'ADD' || !d.action) &&\n        d.ideal.hasShrinkwrap && !seen.has(d.ideal) &&\n        !this[_trashList].has(d.ideal.path))\n\n    if (!shrinkwraps.length) {\n      return\n    }\n\n    process.emit('time', 'reify:loadShrinkwraps')\n\n    const Arborist = this.constructor\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal\n      seen.add(node)\n      return diff.action ? this[_reifyNode](node) : node\n    }))\n      .then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n        ...this.options,\n        path: node.path,\n      }).loadVirtual({ root: node }))))\n      // reload the diff and sparse tree because the ideal tree changed\n      .then(() => this[_diffTrees]())\n      .then(() => this[_createSparseTree]())\n      .then(() => this[_addOmitsToTrashList]())\n      .then(() => this[_loadShrinkwrapsAndUpdateTrees]())\n      .then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'))\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode] (node) {\n    if (this[_trashList].has(node.path)) {\n      return node\n    }\n\n    const timer = `reifyNode:${node.location}`\n    process.emit('time', timer)\n    this.addTracker('reify', node.name, node.location)\n\n    const { npmVersion, nodeVersion } = this.options\n    const p = Promise.resolve()\n      .then(async () => {\n        // when we reify an optional node, check the engine and platform\n        // first. be sure to ignore the --force and --engine-strict flags,\n        // since we always want to skip any optional packages we can't install.\n        // these checks throwing will result in a rollback and removal\n        // of the mismatches\n        if (node.optional) {\n          checkEngine(node.package, npmVersion, nodeVersion, false)\n          checkPlatform(node.package, false)\n        }\n        await this[_checkBins](node)\n        await this[_extractOrLink](node)\n        await this[_warnDeprecated](node)\n      })\n\n    return this[_handleOptionalFailure](node, p)\n      .then(() => {\n        this.finishTracker('reify', node.name, node.location)\n        process.emit('timeEnd', timer)\n        return node\n      })\n  }\n\n  // do not allow node_modules to be a symlink\n  async [_validateNodeModules] (nm) {\n    if (this[_force] || this[_nmValidated].has(nm)) {\n      return\n    }\n    const st = await lstat(nm).catch(() => null)\n    if (!st || st.isDirectory()) {\n      this[_nmValidated].add(nm)\n      return\n    }\n    this.log.warn('reify', 'Removing non-directory', nm)\n    await rimraf(nm)\n  }\n\n  async [_extractOrLink] (node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}`\n      : node.packageName && node.version\n        ? `${node.packageName}@${node.version}`\n        : null\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' +\n        'please re-try this operation once it completes\\n' +\n        'so that the damage can be corrected, or perform\\n' +\n        'a fresh install with no lockfile if the problem persists.'\n      this.log.warn('reify', warning)\n      this.log.verbose('reify', 'unrecognized node in tree', node.path)\n      node.parent = null\n      node.fsParent = null\n      this[_addNodeToTrashList](node)\n      return\n    }\n\n    const nm = resolve(node.parent.path, 'node_modules')\n    await this[_validateNodeModules](nm)\n\n    if (node.isLink) {\n      await rimraf(node.path)\n      await this[_symlink](node)\n    } else {\n      await debug(async () => {\n        const st = await lstat(node.path).catch(e => null)\n        if (st && !st.isDirectory()) {\n          debug.log('unpacking into a non-directory', node)\n          throw Object.assign(new Error('ENOTDIR: not a directory'), {\n            code: 'ENOTDIR',\n            path: node.path,\n          })\n        }\n      })\n      await pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity,\n      })\n    }\n  }\n\n  async [_symlink] (node) {\n    const dir = dirname(node.path)\n    const target = node.realpath\n    const rel = relative(dir, target)\n    await mkdirp(dir)\n    return symlink(rel, node.path, 'junction')\n  }\n\n  [_warnDeprecated] (node) {\n    const {_id, deprecated} = node.package\n    if (deprecated) {\n      this.log.warn('deprecated', `${_id}: ${deprecated}`)\n    }\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure] (node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node)\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path)\n        this[_addNodeToTrashList](node)\n      }\n    }) : p).then(() => node)\n  }\n\n  [_registryResolved] (resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved\n      .replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry)\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees] (\n    depth = 0, bundlesByDepth = this[_getBundlesByDepth]()\n  ) {\n    if (depth === 0) {\n      process.emit('time', 'reify:loadBundles')\n    }\n\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth')\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth)\n        this[_diffTrees]()\n      }\n      process.emit('timeEnd', 'reify:loadBundles')\n      return\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || [])\n      .filter(node => node.root === this.idealTree &&\n        node.target !== node.root &&\n        !this[_trashList].has(node.path))\n\n    if (!set.length) {\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth)\n    }\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => {\n      this[_bundleUnpacked].add(node)\n      return this[_reifyNode](node)\n    }))\n    // then load their unpacked children and move into the ideal tree\n      .then(nodes =>\n        promiseAllRejectLate(nodes.map(async node => {\n          const arb = new this.constructor({\n            ...this.options,\n            path: node.path,\n          })\n          const notTransplanted = new Set(node.children.keys())\n          await arb.loadActual({\n            root: node,\n            // don't transplant any sparse folders we created\n            // loadActual will set node.package to {} for empty directories\n            // if by chance there are some empty folders in the node_modules\n            // tree for some other reason, then ok, ignore those too.\n            transplantFilter: node => {\n              if (node.package._id) {\n                // it's actually in the bundle if it gets transplanted\n                notTransplanted.delete(node.name)\n                return true\n              } else {\n                return false\n              }\n            },\n          })\n          for (const name of notTransplanted) {\n            this[_bundleMissing].add(node.children.get(name))\n          }\n        })))\n    // move onto the next level of bundled items\n      .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))\n  }\n\n  [_getBundlesByDepth] () {\n    const bundlesByDepth = new Map()\n    let maxBundleDepth = -1\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal\n        if (!node) {\n          return\n        }\n        if (node.isProjectRoot) {\n          return\n        }\n\n        const { bundleDependencies } = node.package\n        if (bundleDependencies && bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth)\n          if (!bundlesByDepth.has(node.depth)) {\n            bundlesByDepth.set(node.depth, [node])\n          } else {\n            bundlesByDepth.get(node.depth).push(node)\n          }\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth)\n    return bundlesByDepth\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps] (bundlesByDepth) {\n    const bundleShadowed = new Set()\n\n    // Example dep graph:\n    // root -> (a, c)\n    // a -> BUNDLE(b)\n    // b -> c\n    // c -> b\n    //\n    // package tree:\n    // root\n    // +-- a\n    // |   +-- b(1)\n    // |   +-- c(1)\n    // +-- b(2)\n    // +-- c(2)\n    // 1. mark everything that's shadowed by anything in the bundle.  This\n    //    marks b(2) and c(2).\n    // 2. anything with edgesIn from outside the set, mark not-extraneous,\n    //    remove from set.  This unmarks c(2).\n    // 3. continue until no change\n    // 4. remove everything in the set from the tree.  b(2) is pruned\n\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) {\n        continue\n      }\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name)\n          if (!shadow) {\n            continue\n          }\n          bundleShadowed.add(shadow)\n          shadow.extraneous = true\n        }\n      }\n    }\n\n    // lib -> (a@1.x) BUNDLE(a@1.2.3 (b@1.2.3))\n    // a@1.2.3 -> (b@1.2.3)\n    // a@1.3.0 -> (b@2)\n    // b@1.2.3 -> ()\n    // b@2 -> (c@2)\n    //\n    // root\n    // +-- lib\n    // |   +-- a@1.2.3\n    // |   +-- b@1.2.3\n    // +-- b@2 <-- shadowed, now extraneous\n    // +-- c@2 <-- also shadowed, because only dependent is shadowed\n    for (const shadow of bundleShadowed) {\n      for (const shadDep of shadow.edgesOut.values()) {\n        /* istanbul ignore else - pretty unusual situation, just being\n         * defensive here. Would mean that a bundled dep has a dependency\n         * that is unmet. which, weird, but if you bundle it, we take\n         * whatever you put there and assume the publisher knows best. */\n        if (shadDep.to) {\n          bundleShadowed.add(shadDep.to)\n          shadDep.to.extraneous = true\n        }\n      }\n    }\n\n    let changed\n    do {\n      changed = false\n      for (const shadow of bundleShadowed) {\n        for (const edge of shadow.edgesIn) {\n          if (!bundleShadowed.has(edge.from)) {\n            shadow.extraneous = false\n            bundleShadowed.delete(shadow)\n            changed = true\n            break\n          }\n        }\n      }\n    } while (changed)\n\n    for (const shadow of bundleShadowed) {\n      this[_addNodeToTrashList](shadow)\n      shadow.root = null\n    }\n  }\n\n  [_submitQuickAudit] () {\n    if (this.options.audit === false) {\n      return this.auditReport = null\n    }\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit')\n    const options = { ...this.options }\n    const tree = this.idealTree\n\n    // if we're operating on a workspace, only audit the workspace deps\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(tree, this[_workspaces])\n    }\n\n    this.auditReport = AuditReport.load(tree, options)\n      .then(res => {\n        process.emit('timeEnd', 'reify:audit')\n        this.auditReport = res\n      })\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit] () {\n    return this.auditReport\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules] () {\n    process.emit('time', 'reify:unpack')\n    const unpacks = []\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') {\n          return\n        }\n\n        const node = diff.ideal\n        const bd = this[_bundleUnpacked].has(node)\n        const sw = this[_shrinkwrapInflated].has(node)\n        const bundleMissing = this[_bundleMissing].has(node)\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node && // can't unpack if removed!\n          // root node already exists\n          !node.isRoot &&\n          // already unpacked to read bundle\n          !bd &&\n          // already unpacked to read sw\n          !sw &&\n          // already unpacked by another dep's bundle\n          (bundleMissing || !node.inDepBundle)\n\n        if (doUnpack) {\n          unpacks.push(this[_reifyNode](node))\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n    return promiseAllRejectLate(unpacks)\n      .then(() => process.emit('timeEnd', 'reify:unpack'))\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged] () {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire')\n    const moves = this[_retiredPaths]\n    this[_retiredUnchanged] = {}\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      // skip if nothing was retired\n      if (diff.action !== 'CHANGE' && diff.action !== 'REMOVE') {\n        return\n      }\n\n      const { path: realFolder } = diff.actual\n      const retireFolder = moves[realFolder]\n      /* istanbul ignore next - should be impossible */\n      debug(() => {\n        if (!retireFolder) {\n          const er = new Error('trying to un-retire but not retired')\n          throw Object.assign(er, {\n            realFolder,\n            retireFolder,\n            actual: diff.actual,\n            ideal: diff.ideal,\n            action: diff.action,\n          })\n        }\n      })\n\n      this[_retiredUnchanged][retireFolder] = []\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) {\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node))\n        }\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle && !this[_bundleMissing].has(node)) {\n          return\n        }\n\n        this[_retiredUnchanged][retireFolder].push(node)\n\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath))\n      }))\n    }))\n      .then(() => process.emit('timeEnd', 'reify:unretire'))\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents] (node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]]),\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path)\n      const to = resolve(node.path, rel)\n      return this[_renamePath](path, to)\n    })))\n  }\n\n  [_rollbackMoveBackRetiredUnchanged] (er) {\n    const moves = this[_retiredPaths]\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]))\n    const promises = Object.entries(this[_retiredUnchanged])\n      .map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder)\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        return this[_moveContents]({ ...node, path: fromPath }, node.path)\n      })))\n    return promiseAllRejectLate(promises)\n      .then(() => this[_rollbackCreateSparseTree](er))\n  }\n\n  [_build] () {\n    process.emit('time', 'reify:build')\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = []\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) {\n          nodes.push(diff.ideal)\n        }\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE',\n    })\n\n    // pick up link nodes from the unchanged list as we want to run their\n    // scripts in every install despite of having a diff status change\n    for (const node of this.diff.unchanged) {\n      const tree = node.root.target\n\n      // skip links that only live within node_modules as they are most\n      // likely managed by packages we installed, we only want to rebuild\n      // unchanged links we directly manage\n      if (node.isLink && node.target.fsTop === tree) {\n        nodes.push(node)\n      }\n    }\n\n    return this.rebuild({ nodes, handleOptionalFailure: true })\n      .then(() => process.emit('timeEnd', 'reify:build'))\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash] () {\n    process.emit('time', 'reify:trash')\n    const promises = []\n    const failures = []\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]))\n\n    for (const path of this[_trashList]) {\n      promises.push(rm(path))\n    }\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) {\n        this.log.warn('cleanup', 'Failed to remove some directories', failures)\n      }\n    })\n      .then(() => process.emit('timeEnd', 'reify:trash'))\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  async [_saveIdealTree] (options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) {\n      return false\n    }\n\n    process.emit('time', 'reify:save')\n\n    const updatedTrees = new Set()\n\n    // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n    if (this[_resolvedAdd].length) {\n      for (const { name, tree: addTree } of this[_resolvedAdd]) {\n        // addTree either the root, or a workspace\n        const edge = addTree.edgesOut.get(name)\n        const pkg = addTree.package\n        const req = npa.resolve(name, edge.spec, addTree.realpath)\n        const {rawSpec, subSpec} = req\n\n        const spec = subSpec ? subSpec.rawSpec : rawSpec\n        const child = edge.to\n\n        // if we tried to install an optional dep, but it was a version\n        // that we couldn't resolve, this MAY be missing.  if we haven't\n        // blown up by now, it's because it was not a problem, though, so\n        // just move on.\n        if (!child) {\n          continue\n        }\n\n        let newSpec\n        if (req.registry) {\n          const version = child.version\n          const prefixRange = version ? this[_savePrefix] + version : '*'\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range'\n\n          let range = spec\n          if (\n            !isRange ||\n            spec === '*' ||\n            subset(prefixRange, spec, { loose: true })\n          ) {\n            range = prefixRange\n          }\n\n          const pname = child.packageName\n          const alias = name !== pname\n          newSpec = alias ? `npm:${pname}@${range}` : range\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted\n          const opt = { noCommittish: false }\n          if (h.https && h.auth) {\n            newSpec = `git+${h.https(opt)}`\n          } else {\n            newSpec = h.shortcut(opt)\n          }\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '')\n          const rel = relpath(addTree.realpath, p)\n          newSpec = `file:${rel}`\n        } else {\n          newSpec = req.saveSpec\n        }\n\n        if (options.saveType) {\n          const depType = saveTypeMap.get(options.saveType)\n          pkg[depType][name] = newSpec\n          // rpj will have moved it here if it was in both\n          // if it is empty it will be deleted later\n          if (options.saveType === 'prod' && pkg.optionalDependencies) {\n            delete pkg.optionalDependencies[name]\n          }\n        } else {\n          if (hasSubKey(pkg, 'dependencies', name)) {\n            pkg.dependencies[name] = newSpec\n          }\n\n          if (hasSubKey(pkg, 'devDependencies', name)) {\n            pkg.devDependencies[name] = newSpec\n            // don't update peer or optional if we don't have to\n            if (hasSubKey(pkg, 'peerDependencies', name) && !intersects(newSpec, pkg.peerDependencies[name])) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name) && !intersects(newSpec, pkg.optionalDependencies[name])) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          } else {\n            if (hasSubKey(pkg, 'peerDependencies', name)) {\n              pkg.peerDependencies[name] = newSpec\n            }\n\n            if (hasSubKey(pkg, 'optionalDependencies', name)) {\n              pkg.optionalDependencies[name] = newSpec\n            }\n          }\n        }\n\n        updatedTrees.add(addTree)\n      }\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent,\n    } = this.idealTree.package\n    const format = indent === undefined ? '  ' : indent\n\n    const saveOpt = {\n      format: (this[_formatPackageLock] && format) ? format\n      : this[_formatPackageLock],\n    }\n\n    const promises = [this[_saveLockFile](saveOpt)]\n\n    const updatePackageJson = async (tree) => {\n      const pkgJson = await PackageJson.load(tree.path)\n        .catch(() => new PackageJson(tree.path))\n      const {\n        dependencies = {},\n        devDependencies = {},\n        optionalDependencies = {},\n        peerDependencies = {},\n      } = tree.package\n\n      pkgJson.update({\n        dependencies,\n        devDependencies,\n        optionalDependencies,\n        peerDependencies,\n      })\n      await pkgJson.save()\n    }\n\n    // grab any from explicitRequests that had deps removed\n    for (const { from: tree } of this.explicitRequests) {\n      updatedTrees.add(tree)\n    }\n\n    for (const tree of updatedTrees) {\n      // refresh the edges so they have the correct specs\n      tree.package = tree.package\n      promises.push(updatePackageJson(tree))\n    }\n\n    await Promise.all(promises)\n    process.emit('timeEnd', 'reify:save')\n    return true\n  }\n\n  async [_saveLockFile] (saveOpt) {\n    if (!this[_usePackageLock]) {\n      return\n    }\n\n    const { meta } = this.idealTree\n\n    return meta.save(saveOpt)\n  }\n\n  async [_copyIdealToActual] () {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path)\n      const node = this.idealTree.inventory.get(loc)\n      if (node && node.root === this.idealTree) {\n        node.parent = null\n      }\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const reroot = new Set()\n\n      const { filterSet } = this.diff\n      const seen = new Set()\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        seen.add(loc)\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal)) {\n          continue\n        }\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc)\n        if (!actual) {\n          ideal.root = null\n        } else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location)\n            continue\n          }\n          const { realpath, isLink } = actual\n          if (isLink && ideal.isLink && ideal.realpath === realpath) {\n            continue\n          } else {\n            reroot.add(actual)\n          }\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) {\n          continue\n        }\n        seen.add(loc)\n\n        // we know that this is something that ISN'T in the idealTree,\n        // or else we will have addressed it in the previous loop.\n        // If it's in the filterSet, that means we intentionally removed\n        // it, so nothing to do here.\n        if (filterSet.has(actual)) {\n          continue\n        }\n\n        reroot.add(actual)\n      }\n\n      // go through the rerooted actual nodes, and move them over.\n      for (const actual of reroot) {\n        actual.root = this.idealTree\n      }\n\n      // prune out any tops that lack a linkIn, they are no longer relevant.\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) {\n          top.root = null\n        }\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree)\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename =\n      this.idealTree.realpath + '/node_modules/.package-lock.json'\n    this.idealTree.meta.hiddenLockfile = true\n\n    this.actualTree = this.idealTree\n    this.idealTree = null\n\n    if (!this[_global]) {\n      await this.actualTree.meta.save()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}