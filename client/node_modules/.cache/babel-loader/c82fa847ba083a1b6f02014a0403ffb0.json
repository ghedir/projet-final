{"ast":null,"code":"// Perform a breadth-first walk of a tree, either logical or physical\n// This one only visits, it doesn't leave.  That's because\n// in a breadth-first traversal, children may be visited long\n// after their parent, so the \"exit\" pass ends up being just\n// another breadth-first walk.\n//\n// Breadth-first traversals are good for either creating a tree (ie,\n// reifying a dep graph based on a package.json without a node_modules\n// or package-lock), or mutating it in-place.  For a map-reduce type of\n// walk, it doesn't make a lot of sense, and is very expensive.\nconst breadth = ({\n  visit,\n  filter = () => true,\n  getChildren,\n  tree\n}) => {\n  const queue = [];\n  const seen = new Map();\n\n  const next = () => {\n    while (queue.length) {\n      const node = queue.shift();\n      const res = visitNode(node);\n\n      if (isPromise(res)) {\n        return res.then(() => next());\n      }\n    }\n\n    return seen.get(tree);\n  };\n\n  const visitNode = tree => {\n    if (seen.has(tree)) return seen.get(tree);\n    seen.set(tree, null);\n    const res = visit ? visit(tree) : tree;\n\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res);\n        return kidNodes(tree);\n      });\n      seen.set(tree, fullResult);\n      return fullResult;\n    } else {\n      seen.set(tree, res);\n      return kidNodes(tree);\n    }\n  };\n\n  const kidNodes = tree => {\n    const kids = getChildren(tree, seen.get(tree));\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids);\n  };\n\n  const processKids = kids => {\n    kids = (kids || []).filter(filter);\n    queue.push(...kids);\n  };\n\n  queue.push(tree);\n  return next();\n};\n\nconst isPromise = p => p && typeof p.then === 'function';\n\nmodule.exports = breadth;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/treeverse/lib/breadth.js"],"names":["breadth","visit","filter","getChildren","tree","queue","seen","Map","next","length","node","shift","res","visitNode","isPromise","then","get","has","set","fullResult","kidNodes","kids","processKids","push","p","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,GAAG,CAAC;AACfC,EAAAA,KADe;AAEfC,EAAAA,MAAM,GAAG,MAAM,IAFA;AAGfC,EAAAA,WAHe;AAIfC,EAAAA;AAJe,CAAD,KAKV;AACJ,QAAMC,KAAK,GAAG,EAAd;AACA,QAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;;AAEA,QAAMC,IAAI,GAAG,MAAM;AACjB,WAAOH,KAAK,CAACI,MAAb,EAAqB;AACnB,YAAMC,IAAI,GAAGL,KAAK,CAACM,KAAN,EAAb;AACA,YAAMC,GAAG,GAAGC,SAAS,CAACH,IAAD,CAArB;;AACA,UAAII,SAAS,CAACF,GAAD,CAAb,EAAoB;AAClB,eAAOA,GAAG,CAACG,IAAJ,CAAS,MAAMP,IAAI,EAAnB,CAAP;AACD;AACF;;AACD,WAAOF,IAAI,CAACU,GAAL,CAASZ,IAAT,CAAP;AACD,GATD;;AAWA,QAAMS,SAAS,GAAIT,IAAD,IAAU;AAC1B,QAAIE,IAAI,CAACW,GAAL,CAASb,IAAT,CAAJ,EACE,OAAOE,IAAI,CAACU,GAAL,CAASZ,IAAT,CAAP;AAEFE,IAAAA,IAAI,CAACY,GAAL,CAASd,IAAT,EAAe,IAAf;AACA,UAAMQ,GAAG,GAAGX,KAAK,GAAGA,KAAK,CAACG,IAAD,CAAR,GAAiBA,IAAlC;;AACA,QAAIU,SAAS,CAACF,GAAD,CAAb,EAAoB;AAClB,YAAMO,UAAU,GAAGP,GAAG,CAACG,IAAJ,CAASH,GAAG,IAAI;AACjCN,QAAAA,IAAI,CAACY,GAAL,CAASd,IAAT,EAAeQ,GAAf;AACA,eAAOQ,QAAQ,CAAChB,IAAD,CAAf;AACD,OAHkB,CAAnB;AAIAE,MAAAA,IAAI,CAACY,GAAL,CAASd,IAAT,EAAee,UAAf;AACA,aAAOA,UAAP;AACD,KAPD,MAOO;AACLb,MAAAA,IAAI,CAACY,GAAL,CAASd,IAAT,EAAeQ,GAAf;AACA,aAAOQ,QAAQ,CAAChB,IAAD,CAAf;AACD;AACF,GAjBD;;AAmBA,QAAMgB,QAAQ,GAAIhB,IAAD,IAAU;AACzB,UAAMiB,IAAI,GAAGlB,WAAW,CAACC,IAAD,EAAOE,IAAI,CAACU,GAAL,CAASZ,IAAT,CAAP,CAAxB;AACA,WAAOU,SAAS,CAACO,IAAD,CAAT,GAAkBA,IAAI,CAACN,IAAL,CAAUO,WAAV,CAAlB,GAA2CA,WAAW,CAACD,IAAD,CAA7D;AACD,GAHD;;AAKA,QAAMC,WAAW,GAAID,IAAD,IAAU;AAC5BA,IAAAA,IAAI,GAAG,CAACA,IAAI,IAAI,EAAT,EAAanB,MAAb,CAAoBA,MAApB,CAAP;AACAG,IAAAA,KAAK,CAACkB,IAAN,CAAW,GAAGF,IAAd;AACD,GAHD;;AAKAhB,EAAAA,KAAK,CAACkB,IAAN,CAAWnB,IAAX;AACA,SAAOI,IAAI,EAAX;AACD,CAnDD;;AAqDA,MAAMM,SAAS,GAAGU,CAAC,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACT,IAAT,KAAkB,UAA9C;;AAEAU,MAAM,CAACC,OAAP,GAAiB1B,OAAjB","sourcesContent":["// Perform a breadth-first walk of a tree, either logical or physical\n// This one only visits, it doesn't leave.  That's because\n// in a breadth-first traversal, children may be visited long\n// after their parent, so the \"exit\" pass ends up being just\n// another breadth-first walk.\n//\n// Breadth-first traversals are good for either creating a tree (ie,\n// reifying a dep graph based on a package.json without a node_modules\n// or package-lock), or mutating it in-place.  For a map-reduce type of\n// walk, it doesn't make a lot of sense, and is very expensive.\nconst breadth = ({\n  visit,\n  filter = () => true,\n  getChildren,\n  tree,\n}) => {\n  const queue = []\n  const seen = new Map()\n\n  const next = () => {\n    while (queue.length) {\n      const node = queue.shift()\n      const res = visitNode(node)\n      if (isPromise(res)) {\n        return res.then(() => next())\n      }\n    }\n    return seen.get(tree)\n  }\n\n  const visitNode = (tree) => {\n    if (seen.has(tree))\n      return seen.get(tree)\n\n    seen.set(tree, null)\n    const res = visit ? visit(tree) : tree\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res)\n        return kidNodes(tree)\n      })\n      seen.set(tree, fullResult)\n      return fullResult\n    } else {\n      seen.set(tree, res)\n      return kidNodes(tree)\n    }\n  }\n\n  const kidNodes = (tree) => {\n    const kids = getChildren(tree, seen.get(tree))\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids)\n  }\n\n  const processKids = (kids) => {\n    kids = (kids || []).filter(filter)\n    queue.push(...kids)\n  }\n\n  queue.push(tree)\n  return next()\n}\n\nconst isPromise = p => p && typeof p.then === 'function'\n\nmodule.exports = breadth\n"]},"metadata":{},"sourceType":"script"}