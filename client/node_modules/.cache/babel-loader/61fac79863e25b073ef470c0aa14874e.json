{"ast":null,"code":"// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\nconst fs = require('fs');\n\nconst promisify = require('util').promisify;\n\nconst readlink = promisify(fs.readlink);\nconst lstat = promisify(fs.lstat);\n\nconst {\n  resolve,\n  basename,\n  dirname\n} = require('path');\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n\n  /* istanbul ignore next */\n  if (depth > 2000) {\n    throw eloop(path);\n  }\n\n  path = resolve(path);\n\n  if (rpcache.has(path)) {\n    return Promise.resolve(rpcache.get(path));\n  }\n\n  const dir = dirname(path);\n  const base = basename(path);\n\n  if (base && rpcache.has(dir)) {\n    return realpathChild(dir, base, rpcache, stcache, depth);\n  } // if it's the root, then we know it's real\n\n\n  if (!base) {\n    rpcache.set(dir, dir);\n    return Promise.resolve(dir);\n  } // the parent, what is that?\n  // find out, and then come back.\n\n\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() => realpathCached(path, rpcache, stcache, depth + 1));\n};\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) {\n    return Promise.resolve(stcache.get(path));\n  }\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st);\n    return st;\n  });\n  stcache.set(path, p);\n  return p;\n}; // This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\n\n\nconst eloop = path => Object.assign(new Error(`ELOOP: too many symbolic links encountered, stat '${path}'`), {\n  errno: -62,\n  syscall: 'stat',\n  code: 'ELOOP',\n  path: path\n});\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir); // that unpossible\n\n  /* istanbul ignore next */\n\n  if (typeof realdir === 'undefined') {\n    throw new Error('in realpathChild without parent being in realpath cache');\n  }\n\n  const realish = resolve(realdir, base);\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish);\n      return realish;\n    }\n\n    return readlink(realish).then(target => {\n      const resolved = resolve(realdir, target);\n\n      if (realish === resolved) {\n        throw eloop(realish);\n      }\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1);\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real);\n      return real;\n    });\n  });\n};\n\nmodule.exports = realpathCached;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/realpath.js"],"names":["fs","require","promisify","readlink","lstat","resolve","basename","dirname","realpathCached","path","rpcache","stcache","depth","eloop","has","Promise","get","dir","base","realpathChild","set","then","lstatCached","p","st","Object","assign","Error","errno","syscall","code","realdir","realish","isSymbolicLink","target","resolved","real","module","exports"],"mappings":"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","sourcesContent":["// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\n\nconst fs = require('fs')\nconst promisify = require('util').promisify\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst { resolve, basename, dirname } = require('path')\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n  /* istanbul ignore next */\n  if (depth > 2000) {\n    throw eloop(path)\n  }\n\n  path = resolve(path)\n  if (rpcache.has(path)) {\n    return Promise.resolve(rpcache.get(path))\n  }\n\n  const dir = dirname(path)\n  const base = basename(path)\n\n  if (base && rpcache.has(dir)) {\n    return realpathChild(dir, base, rpcache, stcache, depth)\n  }\n\n  // if it's the root, then we know it's real\n  if (!base) {\n    rpcache.set(dir, dir)\n    return Promise.resolve(dir)\n  }\n\n  // the parent, what is that?\n  // find out, and then come back.\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() =>\n    realpathCached(path, rpcache, stcache, depth + 1))\n}\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) {\n    return Promise.resolve(stcache.get(path))\n  }\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st)\n    return st\n  })\n  stcache.set(path, p)\n  return p\n}\n\n// This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\nconst eloop = path =>\n  Object.assign(new Error(\n    `ELOOP: too many symbolic links encountered, stat '${path}'`), {\n    errno: -62,\n    syscall: 'stat',\n    code: 'ELOOP',\n    path: path,\n  })\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir)\n  // that unpossible\n  /* istanbul ignore next */\n  if (typeof realdir === 'undefined') {\n    throw new Error('in realpathChild without parent being in realpath cache')\n  }\n\n  const realish = resolve(realdir, base)\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish)\n      return realish\n    }\n\n    return readlink(realish).then(target => {\n      const resolved = resolve(realdir, target)\n      if (realish === resolved) {\n        throw eloop(realish)\n      }\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1)\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real)\n      return real\n    })\n  })\n}\n\nmodule.exports = realpathCached\n"]},"metadata":{},"sourceType":"script"}