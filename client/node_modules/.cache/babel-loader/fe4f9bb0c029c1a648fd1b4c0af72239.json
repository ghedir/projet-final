{"ast":null,"code":"// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst {\n  resolve\n} = require('path');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst consistentResolve = require('../consistent-resolve.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst relpath = require('../relpath.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst rpj = require('read-package-json-fast');\n\nconst treeCheck = require('../tree-check.js');\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap');\nconst resolveNodes = Symbol('resolveNodes');\nconst resolveLinks = Symbol('resolveLinks');\nconst assignBundles = Symbol('assignBundles');\nconst loadRoot = Symbol('loadRoot');\nconst loadNode = Symbol('loadVirtualNode');\nconst loadLink = Symbol('loadVirtualLink');\nconst loadWorkspaces = Symbol.for('loadWorkspaces');\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual');\nconst flagsSuspect = Symbol.for('flagsSuspect');\nconst reCalcDepFlags = Symbol('reCalcDepFlags');\nconst checkRootEdges = Symbol('checkRootEdges');\nconst rootOptionProvided = Symbol('rootOptionProvided');\n\nconst depsToEdges = (type, deps) => Object.entries(deps).map(d => [type, ...d]);\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor(options) {\n    super(options); // the virtual tree we load from a shrinkwrap\n\n    this.virtualTree = options.virtualTree;\n    this[flagsSuspect] = false;\n  } // public method\n\n\n  async loadVirtual(options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree;\n    } // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n\n    options = { ...this.options,\n      ...options\n    };\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root);\n      return treeCheck(this.virtualTree);\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path\n    });\n\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file');\n      throw Object.assign(er, {\n        code: 'ENOLOCK'\n      });\n    } // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n\n\n    const {\n      root = await this[loadRoot](s)\n    } = options;\n    this[rootOptionProvided] = options.root;\n    await this[loadFromShrinkwrap](s, root);\n    return treeCheck(this.virtualTree);\n  }\n\n  async [loadRoot](s) {\n    const pj = this.path + '/package.json';\n    const pkg = (await rpj(pj).catch(() => s.data.packages[''])) || {};\n    return this[loadWorkspaces](this[loadNode]('', pkg));\n  }\n\n  async [loadFromShrinkwrap](s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false;\n      root.dev = false;\n      root.optional = false;\n      root.devOptional = false;\n      root.peer = false;\n    } else {\n      this[flagsSuspect] = true;\n    }\n\n    this[checkRootEdges](s, root);\n    root.meta = s;\n    this.virtualTree = root;\n    const {\n      links,\n      nodes\n    } = this[resolveNodes](s, root);\n    await this[resolveLinks](links, nodes);\n\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes);\n    }\n\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values());\n    }\n\n    return root;\n  }\n\n  [reCalcDepFlags](nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue;\n      }\n\n      node.extraneous = true;\n      node.dev = true;\n      node.optional = true;\n      node.devOptional = true;\n      node.peer = true;\n    }\n\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided]);\n  } // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n\n\n  [checkRootEdges](s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return;\n    }\n\n    const lock = s.get('');\n    const prod = lock.dependencies || {};\n    const dev = lock.devDependencies || {};\n    const optional = lock.optionalDependencies || {};\n    const peer = lock.peerDependencies || {};\n    const peerOptional = {};\n\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name];\n          delete peer[name];\n        }\n      }\n    }\n\n    for (const name of Object.keys(optional)) {\n      delete prod[name];\n    }\n\n    const lockWS = [];\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data\n    });\n\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path}`]);\n    }\n\n    const lockEdges = [...depsToEdges('prod', prod), ...depsToEdges('dev', dev), ...depsToEdges('optional', optional), ...depsToEdges('peer', peer), ...depsToEdges('peerOptional', peerOptional), ...lockWS].sort(([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname));\n    const rootEdges = [...root.edgesOut.values()].map(e => [e.type, e.name, e.spec]).sort(([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname));\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true;\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true;\n      }\n    }\n  } // separate out link metadatas, and create Node objects for nodes\n\n\n  [resolveNodes](s, root) {\n    const links = new Map();\n    const nodes = new Map([['', root]]);\n\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue;\n      }\n\n      if (meta.link) {\n        links.set(location, meta);\n      } else {\n        nodes.set(location, this[loadNode](location, meta));\n      }\n    }\n\n    return {\n      links,\n      nodes\n    };\n  } // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n\n\n  async [resolveLinks](links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved);\n      const targetLoc = relpath(this.path, targetPath);\n      const target = nodes.get(targetLoc);\n      const link = this[loadLink](location, targetLoc, target, meta);\n      nodes.set(location, link);\n      nodes.set(targetLoc, link.target); // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json';\n        const pkg = await rpj(pj).catch(() => null);\n\n        if (pkg) {\n          link.target.package = pkg;\n        }\n      }\n    }\n  }\n\n  [assignBundles](nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue;\n      }\n\n      const {\n        name,\n        parent,\n        package: {\n          inBundle\n        }\n      } = node;\n\n      if (!parent) {\n        continue;\n      } // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n\n\n      const {\n        package: ppkg\n      } = parent;\n      const {\n        inBundle: parentBundled\n      } = ppkg;\n\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name];\n        } else {\n          ppkg.bundleDependencies.push(name);\n        }\n      }\n    }\n  }\n\n  [loadNode](location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path;\n    const path = resolve(p, location); // shrinkwrap doesn't include package name unless necessary\n\n    if (!sw.name) {\n      sw.name = nameFromFolder(path);\n    }\n\n    const dev = sw.dev;\n    const optional = sw.optional;\n    const devOptional = dev || optional || sw.devOptional;\n    const peer = sw.peer;\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer\n    }); // cast to boolean because they're undefined in the lock file when false\n\n    node.extraneous = !!sw.extraneous;\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);\n    node.peer = !!sw.peer;\n    node.optional = !!sw.optional;\n    node.dev = !!sw.dev;\n    return node;\n  }\n\n  [loadLink](location, targetLoc, target, meta) {\n    const path = resolve(this.path, location);\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package\n    });\n    link.extraneous = target.extraneous;\n    link.devOptional = target.devOptional;\n    link.peer = target.peer;\n    link.optional = target.optional;\n    link.dev = target.dev;\n    return link;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"],"names":["localeCompare","require","resolve","nameFromFolder","consistentResolve","Shrinkwrap","Node","Link","relpath","calcDepFlags","rpj","treeCheck","loadFromShrinkwrap","Symbol","resolveNodes","resolveLinks","assignBundles","loadRoot","loadNode","loadLink","loadWorkspaces","for","loadWorkspacesVirtual","flagsSuspect","reCalcDepFlags","checkRootEdges","rootOptionProvided","depsToEdges","type","deps","Object","entries","map","d","module","exports","cls","VirtualLoader","constructor","options","virtualTree","loadVirtual","root","meta","s","load","path","loadedFromDisk","er","Error","assign","code","pj","pkg","catch","data","packages","extraneous","dev","optional","devOptional","peer","links","nodes","originalLockfileVersion","values","node","isRoot","ancientLockfile","lock","get","prod","dependencies","devDependencies","optionalDependencies","peerDependencies","peerOptional","peerDependenciesMeta","name","undefined","keys","lockWS","workspaces","cwd","lockfile","push","lockEdges","sort","atype","aname","btype","bname","rootEdges","edgesOut","e","spec","length","i","Map","location","link","set","targetPath","resolved","targetLoc","target","parent","realpath","package","isLink","inBundle","ppkg","parentBundled","has","bundleDependencies","sw","p","legacyPeerDeps","integrity","hasShrinkwrap"],"mappings":"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","sourcesContent":["// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst {resolve} = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({ path: this.path })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else {\n      this[flagsSuspect] = true\n    }\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const {links, nodes} = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes)\n    }\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values())\n    }\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue\n      }\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return\n    }\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional)) {\n      delete prod[name]\n    }\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path}`])\n    }\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true\n      }\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue\n      }\n\n      if (meta.link) {\n        links.set(location, meta)\n      } else {\n        nodes.set(location, this[loadNode](location, meta))\n      }\n    }\n    return {links, nodes}\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg) {\n          link.target.package = pkg\n        }\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue\n      }\n      const { name, parent, package: { inBundle }} = node\n\n      if (!parent) {\n        continue\n      }\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name]\n        } else {\n          ppkg.bundleDependencies.push(name)\n        }\n      }\n    }\n  }\n\n  [loadNode] (location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name) {\n      sw.name = nameFromFolder(path)\n    }\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n"]},"metadata":{},"sourceType":"script"}