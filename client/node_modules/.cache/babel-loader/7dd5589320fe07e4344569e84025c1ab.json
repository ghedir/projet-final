{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\n\nconst Arborist = require('@npmcli/arborist'); // supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\n\n\nfunction normalizeFunding(funding) {\n  const normalizeItem = item => typeof item === 'string' ? {\n    url: item\n  } : item;\n\n  const sources = [].concat(funding || []).map(normalizeItem);\n  return Array.isArray(funding) ? sources : sources[0];\n} // Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\n\n\nfunction isValidFunding(funding) {\n  if (!funding) return false;\n  if (Array.isArray(funding)) return funding.every(f => !Array.isArray(f) && isValidFunding(f));\n\n  try {\n    var parsed = new URL(funding.url || funding);\n  } catch (error) {\n    return false;\n  }\n\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') return false;\n  return Boolean(parsed.host);\n}\n\nconst empty = () => Object.create(null);\n\nfunction readTree(tree, opts) {\n  let packageWithFundingCount = 0;\n  const seen = new Set();\n  const {\n    countOnly\n  } = opts || {};\n\n  const _trailingDependencies = Symbol('trailingDependencies');\n\n  let filterSet;\n\n  if (opts && opts.workspaces && opts.workspaces.length) {\n    const arb = new Arborist(opts);\n    filterSet = arb.workspaceDependencySet(tree, opts.workspaces);\n  }\n\n  function tracked(name, version) {\n    const key = String(name) + String(version);\n    if (seen.has(key)) return true;\n    seen.add(key);\n  }\n\n  function retrieveDependencies(dependencies) {\n    const trailing = dependencies[_trailingDependencies];\n\n    if (trailing) {\n      return Object.assign(empty(), dependencies, trailing);\n    }\n\n    return dependencies;\n  }\n\n  function hasDependencies(dependencies) {\n    return dependencies && (Object.keys(dependencies).length || dependencies[_trailingDependencies]);\n  }\n\n  function attachFundingInfo(target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding);\n      packageWithFundingCount++;\n    }\n  }\n\n  function getFundingDependencies(tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values();\n    if (!edges) return empty();\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to) return empty();\n      const node = edge.to.target || edge.to;\n      if (!node.package) return empty();\n      if (filterSet && filterSet.size > 0 && !filterSet.has(node)) return empty();\n      const {\n        name,\n        funding,\n        version\n      } = node.package; // avoids duplicated items within the funding tree\n\n      if (tracked(name, version)) return empty();\n      const fundingItem = {};\n      if (version) fundingItem.version = version;\n      attachFundingInfo(fundingItem, funding);\n      return {\n        node,\n        fundingItem\n      };\n    });\n    return directDepsWithFunding.reduce((res, {\n      node,\n      fundingItem\n    }, i) => {\n      if (!fundingItem || fundingItem.length === 0 || !node) return res; // recurse\n\n      const transitiveDependencies = node.edgesOut && node.edgesOut.size > 0 && getFundingDependencies(node); // if we're only counting items there's no need\n      // to add all the data to the resulting object\n\n      if (countOnly) return null;\n\n      if (hasDependencies(transitiveDependencies)) {\n        fundingItem.dependencies = retrieveDependencies(transitiveDependencies);\n      }\n\n      if (isValidFunding(fundingItem.funding)) res[node.package.name] = fundingItem;else if (hasDependencies(fundingItem.dependencies)) {\n        res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies);\n      }\n      return res;\n    }, countOnly ? null : empty());\n  }\n\n  const treeDependencies = getFundingDependencies(tree);\n  const result = {\n    length: packageWithFundingCount\n  };\n\n  if (!countOnly) {\n    const name = tree && tree.package && tree.package.name || tree && tree.name;\n    result.name = name || tree && tree.path;\n    if (tree && tree.package && tree.package.version) result.version = tree.package.version;\n    if (tree && tree.package && tree.package.funding) result.funding = normalizeFunding(tree.package.funding);\n    result.dependencies = retrieveDependencies(treeDependencies);\n  }\n\n  return result;\n}\n\nasync function read(opts) {\n  const arb = new Arborist(opts);\n  const tree = await arb.loadActual(opts);\n  return readTree(tree, opts);\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/libnpmfund/index.js"],"names":["URL","require","Arborist","normalizeFunding","funding","normalizeItem","item","url","sources","concat","map","Array","isArray","isValidFunding","every","f","parsed","error","protocol","Boolean","host","empty","Object","create","readTree","tree","opts","packageWithFundingCount","seen","Set","countOnly","_trailingDependencies","Symbol","filterSet","workspaces","length","arb","workspaceDependencySet","tracked","name","version","key","String","has","add","retrieveDependencies","dependencies","trailing","assign","hasDependencies","keys","attachFundingInfo","target","getFundingDependencies","edges","edgesOut","values","directDepsWithFunding","from","edge","to","node","package","size","fundingItem","reduce","res","i","transitiveDependencies","treeDependencies","result","path","read","loadActual","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst URL = require('url').URL\nconst Arborist = require('@npmcli/arborist')\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction normalizeFunding (funding) {\n  const normalizeItem = item =>\n    typeof item === 'string' ? { url: item } : item\n  const sources = [].concat(funding || []).map(normalizeItem)\n  return Array.isArray(funding) ? sources : sources[0]\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction isValidFunding (funding) {\n  if (!funding)\n    return false\n\n  if (Array.isArray(funding))\n    return funding.every(f => !Array.isArray(f) && isValidFunding(f))\n\n  try {\n    var parsed = new URL(funding.url || funding)\n  } catch (error) {\n    return false\n  }\n\n  if (\n    parsed.protocol !== 'https:' &&\n    parsed.protocol !== 'http:'\n  )\n    return false\n\n  return Boolean(parsed.host)\n}\n\nconst empty = () => Object.create(null)\n\nfunction readTree (tree, opts) {\n  let packageWithFundingCount = 0\n  const seen = new Set()\n  const { countOnly } = opts || {}\n  const _trailingDependencies = Symbol('trailingDependencies')\n\n  let filterSet\n\n  if (opts && opts.workspaces && opts.workspaces.length) {\n    const arb = new Arborist(opts)\n    filterSet = arb.workspaceDependencySet(tree, opts.workspaces)\n  }\n\n  function tracked (name, version) {\n    const key = String(name) + String(version)\n    if (seen.has(key))\n      return true\n\n    seen.add(key)\n  }\n\n  function retrieveDependencies (dependencies) {\n    const trailing = dependencies[_trailingDependencies]\n\n    if (trailing) {\n      return Object.assign(\n        empty(),\n        dependencies,\n        trailing\n      )\n    }\n\n    return dependencies\n  }\n\n  function hasDependencies (dependencies) {\n    return dependencies && (\n      Object.keys(dependencies).length ||\n      dependencies[_trailingDependencies]\n    )\n  }\n\n  function attachFundingInfo (target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding)\n      packageWithFundingCount++\n    }\n  }\n\n  function getFundingDependencies (tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values()\n    if (!edges)\n      return empty()\n\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to)\n        return empty()\n\n      const node = edge.to.target || edge.to\n      if (!node.package)\n        return empty()\n\n      if (filterSet && filterSet.size > 0 && !filterSet.has(node))\n        return empty()\n\n      const { name, funding, version } = node.package\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version))\n        return empty()\n\n      const fundingItem = {}\n\n      if (version)\n        fundingItem.version = version\n\n      attachFundingInfo(fundingItem, funding)\n\n      return {\n        node,\n        fundingItem,\n      }\n    })\n\n    return directDepsWithFunding.reduce(\n      (res, { node, fundingItem }, i) => {\n        if (!fundingItem ||\n          fundingItem.length === 0 ||\n          !node)\n          return res\n\n        // recurse\n        const transitiveDependencies = node.edgesOut &&\n          node.edgesOut.size > 0 &&\n          getFundingDependencies(node)\n\n        // if we're only counting items there's no need\n        // to add all the data to the resulting object\n        if (countOnly)\n          return null\n\n        if (hasDependencies(transitiveDependencies)) {\n          fundingItem.dependencies =\n            retrieveDependencies(transitiveDependencies)\n        }\n\n        if (isValidFunding(fundingItem.funding))\n          res[node.package.name] = fundingItem\n        else if (hasDependencies(fundingItem.dependencies)) {\n          res[_trailingDependencies] =\n            Object.assign(\n              empty(),\n              res[_trailingDependencies],\n              fundingItem.dependencies\n            )\n        }\n\n        return res\n      }, countOnly ? null : empty())\n  }\n\n  const treeDependencies = getFundingDependencies(tree)\n  const result = {\n    length: packageWithFundingCount,\n  }\n\n  if (!countOnly) {\n    const name =\n      (tree && tree.package && tree.package.name) ||\n      (tree && tree.name)\n    result.name = name || (tree && tree.path)\n\n    if (tree && tree.package && tree.package.version)\n      result.version = tree.package.version\n\n    if (tree && tree.package && tree.package.funding)\n      result.funding = normalizeFunding(tree.package.funding)\n\n    result.dependencies = retrieveDependencies(treeDependencies)\n  }\n\n  return result\n}\n\nasync function read (opts) {\n  const arb = new Arborist(opts)\n  const tree = await arb.loadActual(opts)\n  return readTree(tree, opts)\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding,\n}\n"]},"metadata":{},"sourceType":"script"}