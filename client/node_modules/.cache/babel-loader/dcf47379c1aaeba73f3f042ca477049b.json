{"ast":null,"code":"const {\n  fixer\n} = require('normalize-package-data');\n\nconst npmFetch = require('npm-registry-fetch');\n\nconst npa = require('npm-package-arg');\n\nconst semver = require('semver');\n\nconst {\n  URL\n} = require('url');\n\nconst ssri = require('ssri');\n\nconst publish = async (manifest, tarballData, opts) => {\n  if (manifest.private) {\n    throw Object.assign(new Error(`This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`), {\n      code: 'EPRIVATE'\n    });\n  } // spec is used to pick the appropriate registry/auth combo\n\n\n  const spec = npa.resolve(manifest.name, manifest.version);\n  opts = {\n    defaultTag: 'latest',\n    // if scoped, restricted by default\n    access: spec.scope ? 'restricted' : 'public',\n    algorithms: ['sha512'],\n    ...opts,\n    spec\n  };\n  const reg = npmFetch.pickRegistry(spec, opts);\n  const pubManifest = patchManifest(manifest, opts); // registry-frontdoor cares about the access level,\n  // which is only configurable for scoped packages\n\n  if (!spec.scope && opts.access === 'restricted') {\n    throw Object.assign(new Error(\"Can't restrict access to unscoped packages.\"), {\n      code: 'EUNSCOPED'\n    });\n  }\n\n  const metadata = buildMetadata(reg, pubManifest, tarballData, opts);\n\n  try {\n    return await npmFetch(spec.escapedName, { ...opts,\n      method: 'PUT',\n      body: metadata,\n      ignoreBody: true\n    });\n  } catch (err) {\n    if (err.code !== 'E409') throw err; // if E409, we attempt exactly ONE retry, to protect us\n    // against malicious activity like trying to publish\n    // a bunch of new versions of a package at the same time\n    // and/or spamming the registry\n\n    const current = await npmFetch.json(spec.escapedName, { ...opts,\n      query: {\n        write: true\n      }\n    });\n    const newMetadata = patchMetadata(current, metadata, opts);\n    return npmFetch(spec.escapedName, { ...opts,\n      method: 'PUT',\n      body: newMetadata,\n      ignoreBody: true\n    });\n  }\n};\n\nconst patchManifest = (_manifest, opts) => {\n  const {\n    npmVersion\n  } = opts; // we only update top-level fields, so a shallow clone is fine\n\n  const manifest = { ..._manifest\n  };\n  manifest._nodeVersion = process.versions.node;\n  if (npmVersion) manifest._npmVersion = npmVersion;\n  fixer.fixNameField(manifest, {\n    strict: true,\n    allowLegacyCase: true\n  });\n  const version = semver.clean(manifest.version);\n\n  if (!version) {\n    throw Object.assign(new Error('invalid semver: ' + manifest.version), {\n      code: 'EBADSEMVER'\n    });\n  }\n\n  manifest.version = version;\n  return manifest;\n};\n\nconst buildMetadata = (registry, manifest, tarballData, opts) => {\n  const {\n    access,\n    defaultTag,\n    algorithms\n  } = opts;\n  const root = {\n    _id: manifest.name,\n    name: manifest.name,\n    description: manifest.description,\n    'dist-tags': {},\n    versions: {},\n    access\n  };\n  root.versions[manifest.version] = manifest;\n  const tag = manifest.tag || defaultTag;\n  root['dist-tags'][tag] = manifest.version;\n  const tarballName = `${manifest.name}-${manifest.version}.tgz`;\n  const tarballURI = `${manifest.name}/-/${tarballName}`;\n  const integrity = ssri.fromData(tarballData, {\n    algorithms: [...new Set(['sha1'].concat(algorithms))]\n  });\n  manifest._id = `${manifest.name}@${manifest.version}`;\n  manifest.dist = { ...manifest.dist\n  }; // Don't bother having sha1 in the actual integrity field\n\n  manifest.dist.integrity = integrity.sha512[0].toString(); // Legacy shasum support\n\n  manifest.dist.shasum = integrity.sha1[0].hexDigest(); // NB: the CLI always fetches via HTTPS if the registry is HTTPS,\n  // regardless of what's here.  This makes it so that installing\n  // from an HTTP-only mirror doesn't cause problems, though.\n\n  manifest.dist.tarball = new URL(tarballURI, registry).href.replace(/^https:\\/\\//, 'http://');\n  root._attachments = {};\n  root._attachments[tarballName] = {\n    content_type: 'application/octet-stream',\n    data: tarballData.toString('base64'),\n    length: tarballData.length\n  };\n  return root;\n};\n\nconst patchMetadata = (current, newData) => {\n  const curVers = Object.keys(current.versions || {}).map(v => semver.clean(v, true)).concat(Object.keys(current.time || {}).map(v => semver.valid(v, true) && semver.clean(v, true)).filter(v => v));\n  const newVersion = Object.keys(newData.versions)[0];\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    const {\n      name: pkgid,\n      version\n    } = newData;\n    throw Object.assign(new Error(`Cannot publish ${pkgid}@${version} over existing version.`), {\n      code: 'EPUBLISHCONFLICT',\n      pkgid,\n      version\n    });\n  }\n\n  current.versions = current.versions || {};\n  current.versions[newVersion] = newData.versions[newVersion];\n\n  for (const i in newData) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (const j in newData[i]) {\n          current[i] = current[i] || {};\n          current[i][j] = newData[i][j];\n        }\n\n        break;\n      // copy\n\n      default:\n        current[i] = newData[i];\n        break;\n    }\n  }\n\n  return current;\n};\n\nmodule.exports = publish;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/libnpmpublish/publish.js"],"names":["fixer","require","npmFetch","npa","semver","URL","ssri","publish","manifest","tarballData","opts","private","Object","assign","Error","code","spec","resolve","name","version","defaultTag","access","scope","algorithms","reg","pickRegistry","pubManifest","patchManifest","metadata","buildMetadata","escapedName","method","body","ignoreBody","err","current","json","query","write","newMetadata","patchMetadata","_manifest","npmVersion","_nodeVersion","process","versions","node","_npmVersion","fixNameField","strict","allowLegacyCase","clean","registry","root","_id","description","tag","tarballName","tarballURI","integrity","fromData","Set","concat","dist","sha512","toString","shasum","sha1","hexDigest","tarball","href","replace","_attachments","content_type","data","length","newData","curVers","keys","map","v","time","valid","filter","newVersion","indexOf","pkgid","i","j","module","exports"],"mappings":"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","sourcesContent":["const { fixer } = require('normalize-package-data')\nconst npmFetch = require('npm-registry-fetch')\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { URL } = require('url')\nconst ssri = require('ssri')\n\nconst publish = async (manifest, tarballData, opts) => {\n  if (manifest.private) {\n    throw Object.assign(\n      new Error(`This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`),\n      { code: 'EPRIVATE' }\n    )\n  }\n\n  // spec is used to pick the appropriate registry/auth combo\n  const spec = npa.resolve(manifest.name, manifest.version)\n  opts = {\n    defaultTag: 'latest',\n    // if scoped, restricted by default\n    access: spec.scope ? 'restricted' : 'public',\n    algorithms: ['sha512'],\n    ...opts,\n    spec,\n  }\n\n  const reg = npmFetch.pickRegistry(spec, opts)\n  const pubManifest = patchManifest(manifest, opts)\n\n  // registry-frontdoor cares about the access level,\n  // which is only configurable for scoped packages\n  if (!spec.scope && opts.access === 'restricted') {\n    throw Object.assign(\n      new Error(\"Can't restrict access to unscoped packages.\"),\n      { code: 'EUNSCOPED' }\n    )\n  }\n\n  const metadata = buildMetadata(reg, pubManifest, tarballData, opts)\n\n  try {\n    return await npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: metadata,\n      ignoreBody: true,\n    })\n  } catch (err) {\n    if (err.code !== 'E409')\n      throw err\n    // if E409, we attempt exactly ONE retry, to protect us\n    // against malicious activity like trying to publish\n    // a bunch of new versions of a package at the same time\n    // and/or spamming the registry\n    const current = await npmFetch.json(spec.escapedName, {\n      ...opts,\n      query: { write: true },\n    })\n    const newMetadata = patchMetadata(current, metadata, opts)\n    return npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: newMetadata,\n      ignoreBody: true,\n    })\n  }\n}\n\nconst patchManifest = (_manifest, opts) => {\n  const { npmVersion } = opts\n  // we only update top-level fields, so a shallow clone is fine\n  const manifest = { ..._manifest }\n\n  manifest._nodeVersion = process.versions.node\n  if (npmVersion)\n    manifest._npmVersion = npmVersion\n\n  fixer.fixNameField(manifest, { strict: true, allowLegacyCase: true })\n  const version = semver.clean(manifest.version)\n  if (!version) {\n    throw Object.assign(\n      new Error('invalid semver: ' + manifest.version),\n      { code: 'EBADSEMVER' }\n    )\n  }\n  manifest.version = version\n  return manifest\n}\n\nconst buildMetadata = (registry, manifest, tarballData, opts) => {\n  const { access, defaultTag, algorithms } = opts\n  const root = {\n    _id: manifest.name,\n    name: manifest.name,\n    description: manifest.description,\n    'dist-tags': {},\n    versions: {},\n    access,\n  }\n\n  root.versions[manifest.version] = manifest\n  const tag = manifest.tag || defaultTag\n  root['dist-tags'][tag] = manifest.version\n\n  const tarballName = `${manifest.name}-${manifest.version}.tgz`\n  const tarballURI = `${manifest.name}/-/${tarballName}`\n  const integrity = ssri.fromData(tarballData, {\n    algorithms: [...new Set(['sha1'].concat(algorithms))],\n  })\n\n  manifest._id = `${manifest.name}@${manifest.version}`\n  manifest.dist = { ...manifest.dist }\n  // Don't bother having sha1 in the actual integrity field\n  manifest.dist.integrity = integrity.sha512[0].toString()\n  // Legacy shasum support\n  manifest.dist.shasum = integrity.sha1[0].hexDigest()\n\n  // NB: the CLI always fetches via HTTPS if the registry is HTTPS,\n  // regardless of what's here.  This makes it so that installing\n  // from an HTTP-only mirror doesn't cause problems, though.\n  manifest.dist.tarball = new URL(tarballURI, registry).href\n    .replace(/^https:\\/\\//, 'http://')\n\n  root._attachments = {}\n  root._attachments[tarballName] = {\n    content_type: 'application/octet-stream',\n    data: tarballData.toString('base64'),\n    length: tarballData.length,\n  }\n\n  return root\n}\n\nconst patchMetadata = (current, newData) => {\n  const curVers = Object.keys(current.versions || {})\n    .map(v => semver.clean(v, true))\n    .concat(Object.keys(current.time || {})\n      .map(v => semver.valid(v, true) && semver.clean(v, true))\n      .filter(v => v))\n\n  const newVersion = Object.keys(newData.versions)[0]\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    const { name: pkgid, version } = newData\n    throw Object.assign(\n      new Error(\n        `Cannot publish ${pkgid}@${version} over existing version.`\n      ), {\n        code: 'EPUBLISHCONFLICT',\n        pkgid,\n        version,\n      })\n  }\n\n  current.versions = current.versions || {}\n  current.versions[newVersion] = newData.versions[newVersion]\n  for (const i in newData) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (const j in newData[i]) {\n          current[i] = current[i] || {}\n          current[i][j] = newData[i][j]\n        }\n        break\n\n      // copy\n      default:\n        current[i] = newData[i]\n        break\n    }\n  }\n\n  return current\n}\n\nmodule.exports = publish\n"]},"metadata":{},"sourceType":"script"}