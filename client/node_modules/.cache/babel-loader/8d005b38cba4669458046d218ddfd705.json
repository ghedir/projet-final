{"ast":null,"code":"const depTypes = new Set(['dependencies', 'optionalDependencies', 'devDependencies', 'peerDependencies']); // sort alphabetically all types of deps for a given package\n\nconst orderDeps = content => {\n  for (const type of depTypes) {\n    if (content && content[type]) {\n      content[type] = Object.keys(content[type]).sort((a, b) => a.localeCompare(b, 'en')).reduce((res, key) => {\n        res[key] = content[type][key];\n        return res;\n      }, {});\n    }\n  }\n\n  return content;\n};\n\nconst updateDependencies = ({\n  content,\n  originalContent\n}) => {\n  const pkg = orderDeps({ ...content\n  }); // optionalDependencies don't need to be repeated in two places\n\n  if (pkg.dependencies) {\n    if (pkg.optionalDependencies) {\n      for (const name of Object.keys(pkg.optionalDependencies)) delete pkg.dependencies[name];\n    }\n  }\n\n  const result = { ...originalContent\n  }; // loop through all types of dependencies and update package json pkg\n\n  for (const type of depTypes) {\n    if (pkg[type]) result[type] = pkg[type]; // prune empty type props from resulting object\n\n    const emptyDepType = pkg[type] && typeof pkg === 'object' && Object.keys(pkg[type]).length === 0;\n    if (emptyDepType) delete result[type];\n  } // if original package.json had dep in peerDeps AND deps, preserve that.\n\n\n  const {\n    dependencies: origProd,\n    peerDependencies: origPeer\n  } = originalContent || {};\n  const {\n    peerDependencies: newPeer\n  } = result;\n\n  if (origProd && origPeer && newPeer) {\n    // we have original prod/peer deps, and new peer deps\n    // copy over any that were in both in the original\n    for (const name of Object.keys(origPeer)) {\n      if (origProd[name] !== undefined && newPeer[name] !== undefined) {\n        result.dependencies = result.dependencies || {};\n        result.dependencies[name] = newPeer[name];\n      }\n    }\n  }\n\n  return result;\n};\n\nupdateDependencies.knownKeys = depTypes;\nmodule.exports = updateDependencies;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/package-json/lib/update-dependencies.js"],"names":["depTypes","Set","orderDeps","content","type","Object","keys","sort","a","b","localeCompare","reduce","res","key","updateDependencies","originalContent","pkg","dependencies","optionalDependencies","name","result","emptyDepType","length","origProd","peerDependencies","origPeer","newPeer","undefined","knownKeys","module","exports"],"mappings":"AAAA,MAAMA,QAAQ,GAAG,IAAIC,GAAJ,CAAQ,CACvB,cADuB,EAEvB,sBAFuB,EAGvB,iBAHuB,EAIvB,kBAJuB,CAAR,CAAjB,C,CAOA;;AACA,MAAMC,SAAS,GAAIC,OAAD,IAAa;AAC7B,OAAK,MAAMC,IAAX,IAAmBJ,QAAnB,EAA6B;AAC3B,QAAIG,OAAO,IAAIA,OAAO,CAACC,IAAD,CAAtB,EAA8B;AAC5BD,MAAAA,OAAO,CAACC,IAAD,CAAP,GAAgBC,MAAM,CAACC,IAAP,CAAYH,OAAO,CAACC,IAAD,CAAnB,EACbG,IADa,CACR,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,aAAF,CAAgBD,CAAhB,EAAmB,IAAnB,CADF,EAEbE,MAFa,CAEN,CAACC,GAAD,EAAMC,GAAN,KAAc;AACpBD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWV,OAAO,CAACC,IAAD,CAAP,CAAcS,GAAd,CAAX;AACA,eAAOD,GAAP;AACD,OALa,EAKX,EALW,CAAhB;AAMD;AACF;;AACD,SAAOT,OAAP;AACD,CAZD;;AAcA,MAAMW,kBAAkB,GAAG,CAAC;AAAEX,EAAAA,OAAF;AAAWY,EAAAA;AAAX,CAAD,KAAkC;AAC3D,QAAMC,GAAG,GAAGd,SAAS,CAAC,EACpB,GAAGC;AADiB,GAAD,CAArB,CAD2D,CAK3D;;AACA,MAAIa,GAAG,CAACC,YAAR,EAAsB;AACpB,QAAID,GAAG,CAACE,oBAAR,EAA8B;AAC5B,WAAK,MAAMC,IAAX,IAAmBd,MAAM,CAACC,IAAP,CAAYU,GAAG,CAACE,oBAAhB,CAAnB,EACE,OAAOF,GAAG,CAACC,YAAJ,CAAiBE,IAAjB,CAAP;AACH;AACF;;AAED,QAAMC,MAAM,GAAG,EAAE,GAAGL;AAAL,GAAf,CAb2D,CAe3D;;AACA,OAAK,MAAMX,IAAX,IAAmBJ,QAAnB,EAA6B;AAC3B,QAAIgB,GAAG,CAACZ,IAAD,CAAP,EACEgB,MAAM,CAAChB,IAAD,CAAN,GAAeY,GAAG,CAACZ,IAAD,CAAlB,CAFyB,CAI3B;;AACA,UAAMiB,YAAY,GAChBL,GAAG,CAACZ,IAAD,CAAH,IACG,OAAOY,GAAP,KAAe,QADlB,IAEGX,MAAM,CAACC,IAAP,CAAYU,GAAG,CAACZ,IAAD,CAAf,EAAuBkB,MAAvB,KAAkC,CAHvC;AAIA,QAAID,YAAJ,EACE,OAAOD,MAAM,CAAChB,IAAD,CAAb;AACH,GA3B0D,CA6B3D;;;AACA,QAAM;AAAEa,IAAAA,YAAY,EAAEM,QAAhB;AAA0BC,IAAAA,gBAAgB,EAAEC;AAA5C,MACJV,eAAe,IAAI,EADrB;AAEA,QAAM;AAAES,IAAAA,gBAAgB,EAAEE;AAApB,MAAgCN,MAAtC;;AACA,MAAIG,QAAQ,IAAIE,QAAZ,IAAwBC,OAA5B,EAAqC;AACnC;AACA;AACA,SAAK,MAAMP,IAAX,IAAmBd,MAAM,CAACC,IAAP,CAAYmB,QAAZ,CAAnB,EAA0C;AACxC,UAAIF,QAAQ,CAACJ,IAAD,CAAR,KAAmBQ,SAAnB,IAAgCD,OAAO,CAACP,IAAD,CAAP,KAAkBQ,SAAtD,EAAiE;AAC/DP,QAAAA,MAAM,CAACH,YAAP,GAAsBG,MAAM,CAACH,YAAP,IAAuB,EAA7C;AACAG,QAAAA,MAAM,CAACH,YAAP,CAAoBE,IAApB,IAA4BO,OAAO,CAACP,IAAD,CAAnC;AACD;AACF;AACF;;AAED,SAAOC,MAAP;AACD,CA7CD;;AA+CAN,kBAAkB,CAACc,SAAnB,GAA+B5B,QAA/B;AAEA6B,MAAM,CAACC,OAAP,GAAiBhB,kBAAjB","sourcesContent":["const depTypes = new Set([\n  'dependencies',\n  'optionalDependencies',\n  'devDependencies',\n  'peerDependencies',\n])\n\n// sort alphabetically all types of deps for a given package\nconst orderDeps = (content) => {\n  for (const type of depTypes) {\n    if (content && content[type]) {\n      content[type] = Object.keys(content[type])\n        .sort((a, b) => a.localeCompare(b, 'en'))\n        .reduce((res, key) => {\n          res[key] = content[type][key]\n          return res\n        }, {})\n    }\n  }\n  return content\n}\n\nconst updateDependencies = ({ content, originalContent }) => {\n  const pkg = orderDeps({\n    ...content,\n  })\n\n  // optionalDependencies don't need to be repeated in two places\n  if (pkg.dependencies) {\n    if (pkg.optionalDependencies) {\n      for (const name of Object.keys(pkg.optionalDependencies))\n        delete pkg.dependencies[name]\n    }\n  }\n\n  const result = { ...originalContent }\n\n  // loop through all types of dependencies and update package json pkg\n  for (const type of depTypes) {\n    if (pkg[type])\n      result[type] = pkg[type]\n\n    // prune empty type props from resulting object\n    const emptyDepType =\n      pkg[type]\n      && typeof pkg === 'object'\n      && Object.keys(pkg[type]).length === 0\n    if (emptyDepType)\n      delete result[type]\n  }\n\n  // if original package.json had dep in peerDeps AND deps, preserve that.\n  const { dependencies: origProd, peerDependencies: origPeer } =\n    originalContent || {}\n  const { peerDependencies: newPeer } = result\n  if (origProd && origPeer && newPeer) {\n    // we have original prod/peer deps, and new peer deps\n    // copy over any that were in both in the original\n    for (const name of Object.keys(origPeer)) {\n      if (origProd[name] !== undefined && newPeer[name] !== undefined) {\n        result.dependencies = result.dependencies || {}\n        result.dependencies[name] = newPeer[name]\n      }\n    }\n  }\n\n  return result\n}\n\nupdateDependencies.knownKeys = depTypes\n\nmodule.exports = updateDependencies\n"]},"metadata":{},"sourceType":"script"}