{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst fetch = require('npm-registry-fetch');\n\nconst ssri = require('ssri');\n\nconst Minipass = require('minipass'); // The default registry URL is a string of great magic.\n\n\nconst magic = /^https?:\\/\\/registry\\.npmjs\\.org\\//;\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\n\nconst _headers = Symbol('_headers');\n\nclass RemoteFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolved = this.spec.fetchSpec;\n    if (magic.test(this.resolved) && !magic.test(this.registry + '/')) this.resolved = this.resolved.replace(magic, this.registry + '/'); // nam is a fermented pork sausage that is good to eat\n\n    const nameat = this.spec.name ? `${this.spec.name}@` : '';\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;\n  } // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n\n\n  get [_cacheFetches]() {\n    return false;\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    const fetchOpts = { ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()]\n    };\n    fetch(this.resolved, fetchOpts).then(res => {\n      const hash = res.headers.get('x-local-cache-hash');\n\n      if (hash) {\n        this.integrity = decodeURIComponent(hash);\n      }\n\n      res.body.on('error',\n      /* istanbul ignore next - exceedingly rare and hard to simulate */\n      er => stream.emit('error', er)).pipe(stream);\n    }).catch(er => stream.emit('error', er));\n    return stream;\n  }\n\n  [_headers]() {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? {\n        'pacote-integrity': String(this.integrity)\n      } : {}),\n      ...(this.opts.headers || {})\n    };\n  }\n\n  get types() {\n    return ['remote'];\n  } // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n  manifest() {\n    return FileFetcher.prototype.manifest.apply(this);\n  }\n\n}\n\nmodule.exports = RemoteFetcher;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/pacote/lib/remote.js"],"names":["Fetcher","require","FileFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","fetch","ssri","Minipass","magic","_cacheFetches","_headers","RemoteFetcher","constructor","spec","opts","resolved","fetchSpec","test","registry","replace","nameat","name","pkgid","stream","fetchOpts","headers","integrity","algorithms","pickIntegrityAlgorithm","then","res","hash","get","decodeURIComponent","body","on","er","emit","pipe","catch","userAgent","process","String","types","packument","prototype","apply","manifest","module","exports"],"mappings":"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","sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst fetch = require('npm-registry-fetch')\nconst ssri = require('ssri')\nconst Minipass = require('minipass')\n// The default registry URL is a string of great magic.\nconst magic = /^https?:\\/\\/registry\\.npmjs\\.org\\//\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\nconst _headers = Symbol('_headers')\nclass RemoteFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    this.resolved = this.spec.fetchSpec\n    if (magic.test(this.resolved) && !magic.test(this.registry + '/'))\n      this.resolved = this.resolved.replace(magic, this.registry + '/')\n\n    // nam is a fermented pork sausage that is good to eat\n    const nameat = this.spec.name ? `${this.spec.name}@` : ''\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`\n  }\n\n  // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n  get [_cacheFetches] () {\n    return false\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    const fetchOpts = {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [ this.pickIntegrityAlgorithm() ],\n    }\n    fetch(this.resolved, fetchOpts).then(res => {\n      const hash = res.headers.get('x-local-cache-hash')\n      if (hash) {\n        this.integrity = decodeURIComponent(hash)\n      }\n\n      res.body.on('error',\n        /* istanbul ignore next - exceedingly rare and hard to simulate */\n        er => stream.emit('error', er)\n      ).pipe(stream)\n    }).catch(er => stream.emit('error', er))\n\n    return stream\n  }\n\n  [_headers] () {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? { 'pacote-integrity': String(this.integrity) }\n        : {}),\n      ...(this.opts.headers || {}),\n    }\n  }\n\n  get types () {\n    return ['remote']\n  }\n\n  // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n\n  manifest () {\n    return FileFetcher.prototype.manifest.apply(this)\n  }\n}\nmodule.exports = RemoteFetcher\n"]},"metadata":{},"sourceType":"script"}