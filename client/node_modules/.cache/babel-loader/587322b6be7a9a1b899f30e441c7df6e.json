{"ast":null,"code":"const util = require('util');\n\nconst _data = Symbol('data');\n\nconst _delete = Symbol('delete');\n\nconst _append = Symbol('append');\n\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/); // replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\n\n\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/);\n\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket;\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean);\n  }\n\n  return [str];\n};\n\nconst parseKeys = key => {\n  const sqBracketItems = new Set();\n  sqBracketItems.add(_append);\n\n  const parseSqBrackets = str => {\n    const index = sqBracketsMatcher(str); // once we find square brackets, we recursively parse all these\n\n    if (index) {\n      const preSqBracketPortion = index[1]; // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n\n      /* eslint-disable-next-line no-new-wrappers */\n\n      const foundKey = new String(index[2]);\n      const postSqBracketPortion = index[3]; // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n\n      sqBracketItems.add(foundKey); // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n\n      return [...parseSqBrackets(preSqBracketPortion), foundKey, ...(postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : [])];\n    } // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n\n\n    return replaceAppendSymbols(str);\n  };\n\n  const res = []; // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n\n  const sqBracketKeys = parseSqBrackets(key.trim());\n\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k)) res.push(k);else {\n      // splits the dot-sep property names and add them to the list of keys\n      for (const splitKey of k.split('.'))\n      /* eslint-disable-next-line no-new-wrappers */\n      res.push(new String(splitKey));\n    }\n  } // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n\n\n  return res;\n};\n\nconst getter = ({\n  data,\n  key\n}) => {\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key);\n  let _data = data;\n  let label = '';\n\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(new Error('Empty brackets are not valid syntax for retrieving values.'), {\n        code: 'EINVALIDSYNTAX'\n      });\n    } // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n\n\n    const maybeIndex = Number(k);\n\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k];\n        return acc;\n      }, {});\n      return _data;\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k]) return undefined; // otherwise sets the next value\n\n      _data = _data[k];\n    }\n\n    label += k;\n  } // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n\n\n  if (Array.isArray(_data) && _data.length <= 1) _data = _data[0];\n  return {\n    [key]: _data\n  };\n};\n\nconst setter = ({\n  data,\n  key,\n  value,\n  force\n}) => {\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key);\n\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN;\n\n    try {\n      maybeIndex = Number(_key);\n    } catch (err) {}\n\n    if (!Number.isNaN(maybeIndex)) _key = maybeIndex; // creates new array in case key is an index\n    // and the array obj is not yet defined\n\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append;\n    const dataHasNoItems = !Object.keys(_data).length;\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data)) _data = []; // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex) _data = { ..._data\n    }; // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(new Error(`Can't use append syntax in non-Array element`), {\n          code: 'ENOAPPEND'\n        });\n      }\n\n      _key = _data.length;\n    } // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n\n\n    const next = () => {\n      const haveContents = !force && _data[_key] != null && value !== _delete;\n      const shouldNotOverrideLiteralValue = !(typeof _data[_key] === 'object'); // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n\n      const shouldNotAddPropsToArrays = typeof keys[0] !== 'symbol' && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]));\n      const overrideError = haveContents && shouldNotOverrideLiteralValue;\n\n      if (overrideError) {\n        throw Object.assign(new Error(`Property ${_key} already exists and is not an Array or Object.`), {\n          code: 'EOVERRIDEVALUE'\n        });\n      }\n\n      const addPropsToArrayError = haveContents && shouldNotAddPropsToArrays;\n\n      if (addPropsToArrayError) {\n        throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {\n          code: 'ENOADDPROP'\n        });\n      }\n\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {};\n    }; // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n\n\n    if (keys.length) _data[_key] = setKeys(next(), keys.shift());else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data)) _data.splice(_key, 1);else delete _data[_key];\n      } else // finally, sets the value in its right place\n        _data[_key] = value;\n    }\n    return _data;\n  };\n\n  setKeys(data, keys.shift());\n};\n\nclass Queryable {\n  constructor(obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(new Error('Queryable needs an object to query properties from.'), {\n        code: 'ENOQUERYABLEOBJ'\n      });\n    }\n\n    this[_data] = obj;\n  }\n\n  query(queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '') return {\n      '': this[_data]\n    };\n\n    const q = query => getter({\n      data: this[_data],\n      key: query\n    });\n\n    if (Array.isArray(queries)) {\n      let res = {};\n\n      for (const query of queries) res = { ...res,\n        ...q(query)\n      };\n\n      return res;\n    } else return q(queries);\n  } // return the value for a single query if found, otherwise returns undefined\n\n\n  get(query) {\n    const obj = this.query(query);\n    if (obj) return obj[query];\n  } // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n\n\n  set(query, value, {\n    force\n  } = {}) {\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force\n    });\n  } // deletes the value of the property found at `query`\n\n\n  delete(query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete\n    });\n  }\n\n  toJSON() {\n    return this[_data];\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Queryable;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/utils/queryable.js"],"names":["util","require","_data","Symbol","_delete","_append","sqBracketsMatcher","str","match","replaceAppendSymbols","matchEmptyBracket","pre","post","filter","Boolean","parseKeys","key","sqBracketItems","Set","add","parseSqBrackets","index","preSqBracketPortion","foundKey","String","postSqBracketPortion","res","sqBracketKeys","trim","k","has","push","splitKey","split","getter","data","keys","label","Object","assign","Error","code","maybeIndex","Number","Array","isArray","isInteger","reduce","acc","i","undefined","length","setter","value","force","setKeys","_key","NaN","err","isNaN","keyIsAnArrayIndex","dataHasNoItems","next","haveContents","shouldNotOverrideLiteralValue","shouldNotAddPropsToArrays","overrideError","addPropsToArrayError","shift","splice","Queryable","constructor","obj","query","queries","q","get","set","delete","toJSON","inspect","custom","module","exports"],"mappings":"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","sourcesContent":["const util = require('util')\nconst _data = Symbol('data')\nconst _delete = Symbol('delete')\nconst _append = Symbol('append')\n\nconst sqBracketsMatcher = str => str.match(/(.+)\\[([^\\]]+)\\]\\.?(.*)$/)\n\n// replaces any occurence of an empty-brackets (e.g: []) with a special\n// Symbol(append) to represent it, this is going to be useful for the setter\n// method that will push values to the end of the array when finding these\nconst replaceAppendSymbols = str => {\n  const matchEmptyBracket = str.match(/^(.*)\\[\\]\\.?(.*)$/)\n\n  if (matchEmptyBracket) {\n    const [, pre, post] = matchEmptyBracket\n    return [...replaceAppendSymbols(pre), _append, post].filter(Boolean)\n  }\n\n  return [str]\n}\n\nconst parseKeys = (key) => {\n  const sqBracketItems = new Set()\n  sqBracketItems.add(_append)\n  const parseSqBrackets = (str) => {\n    const index = sqBracketsMatcher(str)\n\n    // once we find square brackets, we recursively parse all these\n    if (index) {\n      const preSqBracketPortion = index[1]\n\n      // we want to have a `new String` wrapper here in order to differentiate\n      // between multiple occurences of the same string, e.g:\n      // foo.bar[foo.bar] should split into { foo: { bar: { 'foo.bar': {} } }\n      /* eslint-disable-next-line no-new-wrappers */\n      const foundKey = new String(index[2])\n      const postSqBracketPortion = index[3]\n\n      // we keep track of items found during this step to make sure\n      // we don't try to split-separate keys that were defined within\n      // square brackets, since the key name itself might contain dots\n      sqBracketItems.add(foundKey)\n\n      // returns an array that contains either dot-separate items (that will\n      // be splitted appart during the next step OR the fully parsed keys\n      // read from square brackets, e.g:\n      // foo.bar[1.0.0].a.b -> ['foo.bar', '1.0.0', 'a.b']\n      return [\n        ...parseSqBrackets(preSqBracketPortion),\n        foundKey,\n        ...(\n          postSqBracketPortion\n            ? parseSqBrackets(postSqBracketPortion)\n            : []\n        ),\n      ]\n    }\n\n    // at the end of parsing, any usage of the special empty-bracket syntax\n    // (e.g: foo.array[]) has  not yet been parsed, here we'll take care\n    // of parsing it and adding a special symbol to represent it in\n    // the resulting list of keys\n    return replaceAppendSymbols(str)\n  }\n\n  const res = []\n  // starts by parsing items defined as square brackets, those might be\n  // representing properties that have a dot in the name or just array\n  // indexes, e.g: foo[1.0.0] or list[0]\n  const sqBracketKeys = parseSqBrackets(key.trim())\n\n  for (const k of sqBracketKeys) {\n    // keys parsed from square brackets should just be added to list of\n    // resulting keys as they might have dots as part of the key\n    if (sqBracketItems.has(k))\n      res.push(k)\n    else {\n      // splits the dot-sep property names and add them to the list of keys\n      for (const splitKey of k.split('.'))\n        /* eslint-disable-next-line no-new-wrappers */\n        res.push(new String(splitKey))\n    }\n  }\n\n  // returns an ordered list of strings in which each entry\n  // represents a key in an object defined by the previous entry\n  return res\n}\n\nconst getter = ({ data, key }) => {\n  // keys are a list in which each entry represents the name of\n  // a property that should be walked through the object in order to\n  // return the final found value\n  const keys = parseKeys(key)\n  let _data = data\n  let label = ''\n\n  for (const k of keys) {\n    // empty-bracket-shortcut-syntax is not supported on getter\n    if (k === _append) {\n      throw Object.assign(\n        new Error('Empty brackets are not valid syntax for retrieving values.'),\n        { code: 'EINVALIDSYNTAX' }\n      )\n    }\n\n    // extra logic to take into account printing array, along with its\n    // special syntax in which using a dot-sep property name after an\n    // arry will expand it's results, e.g:\n    // arr.name -> arr[0].name=value, arr[1].name=value, ...\n    const maybeIndex = Number(k)\n    if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) {\n      _data = _data.reduce((acc, i, index) => {\n        acc[`${label}[${index}].${k}`] = i[k]\n        return acc\n      }, {})\n      return _data\n    } else {\n      // if can't find any more values, it means it's just over\n      // and there's nothing to return\n      if (!_data[k])\n        return undefined\n\n      // otherwise sets the next value\n      _data = _data[k]\n    }\n\n    label += k\n  }\n\n  // these are some legacy expectations from\n  // the old API consumed by lib/view.js\n  if (Array.isArray(_data) && _data.length <= 1)\n    _data = _data[0]\n\n  return {\n    [key]: _data,\n  }\n}\n\nconst setter = ({ data, key, value, force }) => {\n  // setter goes to recursively transform the provided data obj,\n  // setting properties from the list of parsed keys, e.g:\n  // ['foo', 'bar', 'baz'] -> { foo: { bar: { baz:  {} } }\n  const keys = parseKeys(key)\n  const setKeys = (_data, _key) => {\n    // handles array indexes, converting valid integers to numbers,\n    // note that occurences of Symbol(append) will throw,\n    // so we just ignore these for now\n    let maybeIndex = Number.NaN\n    try {\n      maybeIndex = Number(_key)\n    } catch (err) {}\n    if (!Number.isNaN(maybeIndex))\n      _key = maybeIndex\n\n    // creates new array in case key is an index\n    // and the array obj is not yet defined\n    const keyIsAnArrayIndex = _key === maybeIndex || _key === _append\n    const dataHasNoItems = !Object.keys(_data).length\n    if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data))\n      _data = []\n\n    // converting from array to an object is also possible, in case the\n    // user is using force mode, we should also convert existing arrays\n    // to an empty object if the current _data is an array\n    if (force && Array.isArray(_data) && !keyIsAnArrayIndex)\n      _data = { ..._data }\n\n    // the _append key is a special key that is used to represent\n    // the empty-bracket notation, e.g: arr[] -> arr[arr.length]\n    if (_key === _append) {\n      if (!Array.isArray(_data)) {\n        throw Object.assign(\n          new Error(`Can't use append syntax in non-Array element`),\n          { code: 'ENOAPPEND' }\n        )\n      }\n      _key = _data.length\n    }\n\n    // retrieves the next data object to recursively iterate on,\n    // throws if trying to override a literal value or add props to an array\n    const next = () => {\n      const haveContents =\n        !force &&\n        _data[_key] != null &&\n        value !== _delete\n      const shouldNotOverrideLiteralValue =\n        !(typeof _data[_key] === 'object')\n      // if the next obj to recurse is an array and the next key to be\n      // appended to the resulting obj is not an array index, then it\n      // should throw since we can't append arbitrary props to arrays\n      const shouldNotAddPropsToArrays =\n        typeof keys[0] !== 'symbol' &&\n        Array.isArray(_data[_key]) &&\n        Number.isNaN(Number(keys[0]))\n\n      const overrideError =\n        haveContents &&\n        shouldNotOverrideLiteralValue\n      if (overrideError) {\n        throw Object.assign(\n          new Error(`Property ${_key} already exists and is not an Array or Object.`),\n          { code: 'EOVERRIDEVALUE' }\n        )\n      }\n\n      const addPropsToArrayError =\n        haveContents &&\n        shouldNotAddPropsToArrays\n      if (addPropsToArrayError) {\n        throw Object.assign(\n          new Error(`Can't add property ${key} to an Array.`),\n          { code: 'ENOADDPROP' }\n        )\n      }\n\n      return typeof _data[_key] === 'object' ? _data[_key] || {} : {}\n    }\n\n    // sets items from the parsed array of keys as objects, recurses to\n    // setKeys in case there are still items to be handled, otherwise it\n    // just sets the original value set by the user\n    if (keys.length)\n      _data[_key] = setKeys(next(), keys.shift())\n    else {\n      // handles special deletion cases for obj props / array items\n      if (value === _delete) {\n        if (Array.isArray(_data))\n          _data.splice(_key, 1)\n        else\n          delete _data[_key]\n      } else\n        // finally, sets the value in its right place\n        _data[_key] = value\n    }\n\n    return _data\n  }\n\n  setKeys(data, keys.shift())\n}\n\nclass Queryable {\n  constructor (obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Object.assign(\n        new Error('Queryable needs an object to query properties from.'),\n        { code: 'ENOQUERYABLEOBJ' }\n      )\n    }\n\n    this[_data] = obj\n  }\n\n  query (queries) {\n    // this ugly interface here is meant to be a compatibility layer\n    // with the legacy API lib/view.js is consuming, if at some point\n    // we refactor that command then we can revisit making this nicer\n    if (queries === '')\n      return { '': this[_data] }\n\n    const q = query => getter({\n      data: this[_data],\n      key: query,\n    })\n\n    if (Array.isArray(queries)) {\n      let res = {}\n      for (const query of queries)\n        res = { ...res, ...q(query) }\n      return res\n    } else\n      return q(queries)\n  }\n\n  // return the value for a single query if found, otherwise returns undefined\n  get (query) {\n    const obj = this.query(query)\n    if (obj)\n      return obj[query]\n  }\n\n  // creates objects along the way for the provided `query` parameter\n  // and assigns `value` to the last property of the query chain\n  set (query, value, { force } = {}) {\n    setter({\n      data: this[_data],\n      key: query,\n      value,\n      force,\n    })\n  }\n\n  // deletes the value of the property found at `query`\n  delete (query) {\n    setter({\n      data: this[_data],\n      key: query,\n      value: _delete,\n    })\n  }\n\n  toJSON () {\n    return this[_data]\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Queryable\n"]},"metadata":{},"sourceType":"script"}