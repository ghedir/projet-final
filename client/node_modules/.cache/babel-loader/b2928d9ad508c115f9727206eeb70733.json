{"ast":null,"code":"const {\n  explainNode\n} = require('./utils/explain-dep.js');\n\nconst completion = require('./utils/completion/installed-deep.js');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst npa = require('npm-package-arg');\n\nconst semver = require('semver');\n\nconst {\n  relative,\n  resolve\n} = require('path');\n\nconst validName = require('validate-npm-package-name');\n\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js');\n\nclass Explain extends ArboristWorkspaceCmd {\n  static get description() {\n    return 'Explain installed packages';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'explain';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['<folder | specifier>'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['json', 'workspace'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n\n  exec(args, cb) {\n    this.explain(args).then(() => cb()).catch(cb);\n  }\n\n  async explain(args) {\n    if (!args.length) throw this.usage;\n    const arb = new Arborist({\n      path: this.npm.prefix,\n      ...this.npm.flatOptions\n    });\n    const tree = await arb.loadActual();\n    if (this.workspaceNames && this.workspaceNames.length) this.filterSet = arb.workspaceDependencySet(tree, this.workspaceNames);\n    const nodes = new Set();\n\n    for (const arg of args) {\n      for (const node of this.getNodes(tree, arg)) {\n        const filteredOut = this.filterSet && this.filterSet.size > 0 && !this.filterSet.has(node);\n        if (!filteredOut) nodes.add(node);\n      }\n    }\n\n    if (nodes.size === 0) throw `No dependencies found matching ${args.join(', ')}`;\n    const expls = [];\n\n    for (const node of nodes) {\n      const {\n        extraneous,\n        dev,\n        optional,\n        devOptional,\n        peer,\n        inBundle\n      } = node;\n      const expl = node.explain();\n      if (extraneous) expl.extraneous = true;else {\n        expl.dev = dev;\n        expl.optional = optional;\n        expl.devOptional = devOptional;\n        expl.peer = peer;\n        expl.bundled = inBundle;\n      }\n      expls.push(expl);\n    }\n\n    if (this.npm.flatOptions.json) this.npm.output(JSON.stringify(expls, null, 2));else {\n      this.npm.output(expls.map(expl => {\n        return explainNode(expl, Infinity, this.npm.color);\n      }).join('\\n\\n'));\n    }\n  }\n\n  getNodes(tree, arg) {\n    // if it's just a name, return packages by that name\n    const {\n      validForOldPackages: valid\n    } = validName(arg);\n    if (valid) return tree.inventory.query('packageName', arg); // if it's a location, get that node\n\n    const maybeLoc = arg.replace(/\\\\/g, '/').replace(/\\/+$/, '');\n    const nodeByLoc = tree.inventory.get(maybeLoc);\n    if (nodeByLoc) return [nodeByLoc]; // maybe a path to a node_modules folder\n\n    const maybePath = relative(this.npm.prefix, resolve(maybeLoc)).replace(/\\\\/g, '/').replace(/\\/+$/, '');\n    const nodeByPath = tree.inventory.get(maybePath);\n    if (nodeByPath) return [nodeByPath]; // otherwise, try to select all matching nodes\n\n    try {\n      return this.getNodesByVersion(tree, arg);\n    } catch (er) {\n      return [];\n    }\n  }\n\n  getNodesByVersion(tree, arg) {\n    const spec = npa(arg, this.npm.prefix);\n    if (spec.type !== 'version' && spec.type !== 'range') return [];\n    return tree.inventory.filter(node => {\n      return node.package.name === spec.name && semver.satisfies(node.package.version, spec.rawSpec);\n    });\n  }\n\n}\n\nmodule.exports = Explain;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/explain.js"],"names":["explainNode","require","completion","Arborist","npa","semver","relative","resolve","validName","ArboristWorkspaceCmd","Explain","description","name","usage","params","opts","npm","exec","args","cb","explain","then","catch","length","arb","path","prefix","flatOptions","tree","loadActual","workspaceNames","filterSet","workspaceDependencySet","nodes","Set","arg","node","getNodes","filteredOut","size","has","add","join","expls","extraneous","dev","optional","devOptional","peer","inBundle","expl","bundled","push","json","output","JSON","stringify","map","Infinity","color","validForOldPackages","valid","inventory","query","maybeLoc","replace","nodeByLoc","get","maybePath","nodeByPath","getNodesByVersion","er","spec","type","filter","package","satisfies","version","rawSpec","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAkBC,OAAO,CAAC,wBAAD,CAA/B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,sCAAD,CAA1B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEK,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,IAAwBN,OAAO,CAAC,MAAD,CAArC;;AACA,MAAMO,SAAS,GAAGP,OAAO,CAAC,2BAAD,CAAzB;;AACA,MAAMQ,oBAAoB,GAAGR,OAAO,CAAC,8BAAD,CAApC;;AAEA,MAAMS,OAAN,SAAsBD,oBAAtB,CAA2C;AACnB,aAAXE,WAAW,GAAI;AACxB,WAAO,4BAAP;AACD;AAED;;;AACe,aAAJC,IAAI,GAAI;AACjB,WAAO,SAAP;AACD;AAED;;;AACgB,aAALC,KAAK,GAAI;AAClB,WAAO,CAAC,sBAAD,CAAP;AACD;AAED;;;AACiB,aAANC,MAAM,GAAI;AACnB,WAAO,CACL,MADK,EAEL,WAFK,CAAP;AAID;AAED;;;AACgB,QAAVZ,UAAU,CAAEa,IAAF,EAAQ;AACtB,WAAOb,UAAU,CAAC,KAAKc,GAAN,EAAWD,IAAX,CAAjB;AACD;;AAEDE,EAAAA,IAAI,CAAEC,IAAF,EAAQC,EAAR,EAAY;AACd,SAAKC,OAAL,CAAaF,IAAb,EAAmBG,IAAnB,CAAwB,MAAMF,EAAE,EAAhC,EAAoCG,KAApC,CAA0CH,EAA1C;AACD;;AAEY,QAAPC,OAAO,CAAEF,IAAF,EAAQ;AACnB,QAAI,CAACA,IAAI,CAACK,MAAV,EACE,MAAM,KAAKV,KAAX;AAEF,UAAMW,GAAG,GAAG,IAAIrB,QAAJ,CAAa;AAAEsB,MAAAA,IAAI,EAAE,KAAKT,GAAL,CAASU,MAAjB;AAAyB,SAAG,KAAKV,GAAL,CAASW;AAArC,KAAb,CAAZ;AACA,UAAMC,IAAI,GAAG,MAAMJ,GAAG,CAACK,UAAJ,EAAnB;AAEA,QAAI,KAAKC,cAAL,IAAuB,KAAKA,cAAL,CAAoBP,MAA/C,EACE,KAAKQ,SAAL,GAAiBP,GAAG,CAACQ,sBAAJ,CAA2BJ,IAA3B,EAAiC,KAAKE,cAAtC,CAAjB;AAEF,UAAMG,KAAK,GAAG,IAAIC,GAAJ,EAAd;;AACA,SAAK,MAAMC,GAAX,IAAkBjB,IAAlB,EAAwB;AACtB,WAAK,MAAMkB,IAAX,IAAmB,KAAKC,QAAL,CAAcT,IAAd,EAAoBO,GAApB,CAAnB,EAA6C;AAC3C,cAAMG,WAAW,GAAG,KAAKP,SAAL,IACf,KAAKA,SAAL,CAAeQ,IAAf,GAAsB,CADP,IAEf,CAAC,KAAKR,SAAL,CAAeS,GAAf,CAAmBJ,IAAnB,CAFN;AAGA,YAAI,CAACE,WAAL,EACEL,KAAK,CAACQ,GAAN,CAAUL,IAAV;AACH;AACF;;AACD,QAAIH,KAAK,CAACM,IAAN,KAAe,CAAnB,EACE,MAAO,kCAAiCrB,IAAI,CAACwB,IAAL,CAAU,IAAV,CAAgB,EAAxD;AAEF,UAAMC,KAAK,GAAG,EAAd;;AACA,SAAK,MAAMP,IAAX,IAAmBH,KAAnB,EAA0B;AACxB,YAAM;AAAEW,QAAAA,UAAF;AAAcC,QAAAA,GAAd;AAAmBC,QAAAA,QAAnB;AAA6BC,QAAAA,WAA7B;AAA0CC,QAAAA,IAA1C;AAAgDC,QAAAA;AAAhD,UAA6Db,IAAnE;AACA,YAAMc,IAAI,GAAGd,IAAI,CAAChB,OAAL,EAAb;AACA,UAAIwB,UAAJ,EACEM,IAAI,CAACN,UAAL,GAAkB,IAAlB,CADF,KAEK;AACHM,QAAAA,IAAI,CAACL,GAAL,GAAWA,GAAX;AACAK,QAAAA,IAAI,CAACJ,QAAL,GAAgBA,QAAhB;AACAI,QAAAA,IAAI,CAACH,WAAL,GAAmBA,WAAnB;AACAG,QAAAA,IAAI,CAACF,IAAL,GAAYA,IAAZ;AACAE,QAAAA,IAAI,CAACC,OAAL,GAAeF,QAAf;AACD;AACDN,MAAAA,KAAK,CAACS,IAAN,CAAWF,IAAX;AACD;;AAED,QAAI,KAAKlC,GAAL,CAASW,WAAT,CAAqB0B,IAAzB,EACE,KAAKrC,GAAL,CAASsC,MAAT,CAAgBC,IAAI,CAACC,SAAL,CAAeb,KAAf,EAAsB,IAAtB,EAA4B,CAA5B,CAAhB,EADF,KAEK;AACH,WAAK3B,GAAL,CAASsC,MAAT,CAAgBX,KAAK,CAACc,GAAN,CAAUP,IAAI,IAAI;AAChC,eAAOlD,WAAW,CAACkD,IAAD,EAAOQ,QAAP,EAAiB,KAAK1C,GAAL,CAAS2C,KAA1B,CAAlB;AACD,OAFe,EAEbjB,IAFa,CAER,MAFQ,CAAhB;AAGD;AACF;;AAEDL,EAAAA,QAAQ,CAAET,IAAF,EAAQO,GAAR,EAAa;AACnB;AACA,UAAM;AAAEyB,MAAAA,mBAAmB,EAAEC;AAAvB,QAAiCrD,SAAS,CAAC2B,GAAD,CAAhD;AACA,QAAI0B,KAAJ,EACE,OAAOjC,IAAI,CAACkC,SAAL,CAAeC,KAAf,CAAqB,aAArB,EAAoC5B,GAApC,CAAP,CAJiB,CAMnB;;AACA,UAAM6B,QAAQ,GAAG7B,GAAG,CAAC8B,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,EAAwBA,OAAxB,CAAgC,MAAhC,EAAwC,EAAxC,CAAjB;AACA,UAAMC,SAAS,GAAGtC,IAAI,CAACkC,SAAL,CAAeK,GAAf,CAAmBH,QAAnB,CAAlB;AACA,QAAIE,SAAJ,EACE,OAAO,CAACA,SAAD,CAAP,CAViB,CAYnB;;AACA,UAAME,SAAS,GAAG9D,QAAQ,CAAC,KAAKU,GAAL,CAASU,MAAV,EAAkBnB,OAAO,CAACyD,QAAD,CAAzB,CAAR,CACfC,OADe,CACP,KADO,EACA,GADA,EACKA,OADL,CACa,MADb,EACqB,EADrB,CAAlB;AAEA,UAAMI,UAAU,GAAGzC,IAAI,CAACkC,SAAL,CAAeK,GAAf,CAAmBC,SAAnB,CAAnB;AACA,QAAIC,UAAJ,EACE,OAAO,CAACA,UAAD,CAAP,CAjBiB,CAmBnB;;AACA,QAAI;AACF,aAAO,KAAKC,iBAAL,CAAuB1C,IAAvB,EAA6BO,GAA7B,CAAP;AACD,KAFD,CAEE,OAAOoC,EAAP,EAAW;AACX,aAAO,EAAP;AACD;AACF;;AAEDD,EAAAA,iBAAiB,CAAE1C,IAAF,EAAQO,GAAR,EAAa;AAC5B,UAAMqC,IAAI,GAAGpE,GAAG,CAAC+B,GAAD,EAAM,KAAKnB,GAAL,CAASU,MAAf,CAAhB;AACA,QAAI8C,IAAI,CAACC,IAAL,KAAc,SAAd,IAA2BD,IAAI,CAACC,IAAL,KAAc,OAA7C,EACE,OAAO,EAAP;AAEF,WAAO7C,IAAI,CAACkC,SAAL,CAAeY,MAAf,CAAsBtC,IAAI,IAAI;AACnC,aAAOA,IAAI,CAACuC,OAAL,CAAa/D,IAAb,KAAsB4D,IAAI,CAAC5D,IAA3B,IACLP,MAAM,CAACuE,SAAP,CAAiBxC,IAAI,CAACuC,OAAL,CAAaE,OAA9B,EAAuCL,IAAI,CAACM,OAA5C,CADF;AAED,KAHM,CAAP;AAID;;AApHwC;;AAsH3CC,MAAM,CAACC,OAAP,GAAiBtE,OAAjB","sourcesContent":["const { explainNode } = require('./utils/explain-dep.js')\nconst completion = require('./utils/completion/installed-deep.js')\nconst Arborist = require('@npmcli/arborist')\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { relative, resolve } = require('path')\nconst validName = require('validate-npm-package-name')\nconst ArboristWorkspaceCmd = require('./workspaces/arborist-cmd.js')\n\nclass Explain extends ArboristWorkspaceCmd {\n  static get description () {\n    return 'Explain installed packages'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'explain'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['<folder | specifier>']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'json',\n      'workspace',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.explain(args).then(() => cb()).catch(cb)\n  }\n\n  async explain (args) {\n    if (!args.length)\n      throw this.usage\n\n    const arb = new Arborist({ path: this.npm.prefix, ...this.npm.flatOptions })\n    const tree = await arb.loadActual()\n\n    if (this.workspaceNames && this.workspaceNames.length)\n      this.filterSet = arb.workspaceDependencySet(tree, this.workspaceNames)\n\n    const nodes = new Set()\n    for (const arg of args) {\n      for (const node of this.getNodes(tree, arg)) {\n        const filteredOut = this.filterSet\n          && this.filterSet.size > 0\n          && !this.filterSet.has(node)\n        if (!filteredOut)\n          nodes.add(node)\n      }\n    }\n    if (nodes.size === 0)\n      throw `No dependencies found matching ${args.join(', ')}`\n\n    const expls = []\n    for (const node of nodes) {\n      const { extraneous, dev, optional, devOptional, peer, inBundle } = node\n      const expl = node.explain()\n      if (extraneous)\n        expl.extraneous = true\n      else {\n        expl.dev = dev\n        expl.optional = optional\n        expl.devOptional = devOptional\n        expl.peer = peer\n        expl.bundled = inBundle\n      }\n      expls.push(expl)\n    }\n\n    if (this.npm.flatOptions.json)\n      this.npm.output(JSON.stringify(expls, null, 2))\n    else {\n      this.npm.output(expls.map(expl => {\n        return explainNode(expl, Infinity, this.npm.color)\n      }).join('\\n\\n'))\n    }\n  }\n\n  getNodes (tree, arg) {\n    // if it's just a name, return packages by that name\n    const { validForOldPackages: valid } = validName(arg)\n    if (valid)\n      return tree.inventory.query('packageName', arg)\n\n    // if it's a location, get that node\n    const maybeLoc = arg.replace(/\\\\/g, '/').replace(/\\/+$/, '')\n    const nodeByLoc = tree.inventory.get(maybeLoc)\n    if (nodeByLoc)\n      return [nodeByLoc]\n\n    // maybe a path to a node_modules folder\n    const maybePath = relative(this.npm.prefix, resolve(maybeLoc))\n      .replace(/\\\\/g, '/').replace(/\\/+$/, '')\n    const nodeByPath = tree.inventory.get(maybePath)\n    if (nodeByPath)\n      return [nodeByPath]\n\n    // otherwise, try to select all matching nodes\n    try {\n      return this.getNodesByVersion(tree, arg)\n    } catch (er) {\n      return []\n    }\n  }\n\n  getNodesByVersion (tree, arg) {\n    const spec = npa(arg, this.npm.prefix)\n    if (spec.type !== 'version' && spec.type !== 'range')\n      return []\n\n    return tree.inventory.filter(node => {\n      return node.package.name === spec.name &&\n        semver.satisfies(node.package.version, spec.rawSpec)\n    })\n  }\n}\nmodule.exports = Explain\n"]},"metadata":{},"sourceType":"script"}