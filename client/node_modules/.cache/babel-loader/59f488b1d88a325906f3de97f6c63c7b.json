{"ast":null,"code":"// helper function to output a clearer visualization\n// of the current node and its descendents\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst util = require('util');\n\nconst relpath = require('./relpath.js');\n\nclass ArboristNode {\n  constructor(tree, path) {\n    this.name = tree.name;\n\n    if (tree.packageName && tree.packageName !== this.name) {\n      this.packageName = tree.packageName;\n    }\n\n    if (tree.version) {\n      this.version = tree.version;\n    }\n\n    this.location = tree.location;\n    this.path = tree.path;\n\n    if (tree.realpath !== this.path) {\n      this.realpath = tree.realpath;\n    }\n\n    if (tree.resolved !== null) {\n      this.resolved = tree.resolved;\n    }\n\n    if (tree.extraneous) {\n      this.extraneous = true;\n    }\n\n    if (tree.dev) {\n      this.dev = true;\n    }\n\n    if (tree.optional) {\n      this.optional = true;\n    }\n\n    if (tree.devOptional && !tree.dev && !tree.optional) {\n      this.devOptional = true;\n    }\n\n    if (tree.peer) {\n      this.peer = true;\n    }\n\n    if (tree.inBundle) {\n      this.bundled = true;\n    }\n\n    if (tree.inDepBundle) {\n      this.bundler = tree.getBundler().location;\n    }\n\n    if (tree.isProjectRoot) {\n      this.isProjectRoot = true;\n    }\n\n    if (tree.isWorkspace) {\n      this.isWorkspace = true;\n    }\n\n    const bd = tree.package && tree.package.bundleDependencies;\n\n    if (bd && bd.length) {\n      this.bundleDependencies = bd;\n    }\n\n    if (tree.inShrinkwrap) {\n      this.inShrinkwrap = true;\n    } else if (tree.hasShrinkwrap) {\n      this.hasShrinkwrap = true;\n    }\n\n    if (tree.error) {\n      this.error = treeError(tree.error);\n    }\n\n    if (tree.errors && tree.errors.length) {\n      this.errors = tree.errors.map(treeError);\n    } // edgesOut sorted by name\n\n\n    if (tree.edgesOut.size) {\n      this.edgesOut = new Map([...tree.edgesOut.entries()].sort(([a], [b]) => localeCompare(a, b)).map(([name, edge]) => [name, new EdgeOut(edge)]));\n    } // edgesIn sorted by location\n\n\n    if (tree.edgesIn.size) {\n      this.edgesIn = new Set([...tree.edgesIn].sort((a, b) => localeCompare(a.from.location, b.from.location)).map(edge => new EdgeIn(edge)));\n    }\n\n    if (tree.workspaces && tree.workspaces.size) {\n      this.workspaces = new Map([...tree.workspaces.entries()].map(([name, path]) => [name, relpath(tree.root.realpath, path)]));\n    } // fsChildren sorted by path\n\n\n    if (tree.fsChildren.size) {\n      this.fsChildren = new Set([...tree.fsChildren].sort(({\n        path: a\n      }, {\n        path: b\n      }) => localeCompare(a, b)).map(tree => printableTree(tree, path)));\n    } // children sorted by name\n\n\n    if (tree.children.size) {\n      this.children = new Map([...tree.children.entries()].sort(([a], [b]) => localeCompare(a, b)).map(([name, tree]) => [name, printableTree(tree, path)]));\n    }\n  }\n\n}\n\nclass ArboristVirtualNode extends ArboristNode {\n  constructor(tree, path) {\n    super(tree, path);\n    this.sourceReference = printableTree(tree.sourceReference, path);\n  }\n\n}\n\nclass ArboristLink extends ArboristNode {\n  constructor(tree, path) {\n    super(tree, path);\n    this.target = printableTree(tree.target, path);\n  }\n\n}\n\nconst treeError = ({\n  code,\n  path\n}) => ({\n  code,\n  ...(path ? {\n    path\n  } : {})\n}); // print out edges without dumping the full node all over again\n// this base class will toJSON as a plain old object, but the\n// util.inspect() output will be a bit cleaner\n\n\nclass Edge {\n  constructor(edge) {\n    this.type = edge.type;\n    this.name = edge.name;\n    this.spec = edge.spec || '*';\n\n    if (edge.error) {\n      this.error = edge.error;\n    }\n\n    if (edge.overridden) {\n      this.overridden = edge.overridden;\n    }\n  }\n\n} // don't care about 'from' for edges out\n\n\nclass EdgeOut extends Edge {\n  constructor(edge) {\n    super(edge);\n    this.to = edge.to && edge.to.location;\n  }\n\n  [util.inspect.custom]() {\n    return `{ ${this.type} ${this.name}@${this.spec}${this.to ? ' -> ' + this.to : ''}${this.error ? ' ' + this.error : ''}${this.overridden ? ' overridden' : ''} }`;\n  }\n\n} // don't care about 'to' for edges in\n\n\nclass EdgeIn extends Edge {\n  constructor(edge) {\n    super(edge);\n    this.from = edge.from && edge.from.location;\n  }\n\n  [util.inspect.custom]() {\n    return `{ ${this.from || '\"\"'} ${this.type} ${this.name}@${this.spec}${this.error ? ' ' + this.error : ''}${this.overridden ? ' overridden' : ''} }`;\n  }\n\n}\n\nconst printableTree = (tree, path = []) => {\n  if (!tree) {\n    return tree;\n  }\n\n  const Cls = tree.isLink ? ArboristLink : tree.sourceReference ? ArboristVirtualNode : ArboristNode;\n\n  if (path.includes(tree)) {\n    const obj = Object.create(Cls.prototype);\n    return Object.assign(obj, {\n      location: tree.location\n    });\n  }\n\n  path.push(tree);\n  return new Cls(tree, path);\n};\n\nmodule.exports = printableTree;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/printable.js"],"names":["localeCompare","require","util","relpath","ArboristNode","constructor","tree","path","name","packageName","version","location","realpath","resolved","extraneous","dev","optional","devOptional","peer","inBundle","bundled","inDepBundle","bundler","getBundler","isProjectRoot","isWorkspace","bd","package","bundleDependencies","length","inShrinkwrap","hasShrinkwrap","error","treeError","errors","map","edgesOut","size","Map","entries","sort","a","b","edge","EdgeOut","edgesIn","Set","from","EdgeIn","workspaces","root","fsChildren","printableTree","children","ArboristVirtualNode","sourceReference","ArboristLink","target","code","Edge","type","spec","overridden","to","inspect","custom","Cls","isLink","includes","obj","Object","create","prototype","assign","push","module","exports"],"mappings":"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","sourcesContent":["// helper function to output a clearer visualization\n// of the current node and its descendents\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst util = require('util')\nconst relpath = require('./relpath.js')\n\nclass ArboristNode {\n  constructor (tree, path) {\n    this.name = tree.name\n    if (tree.packageName && tree.packageName !== this.name) {\n      this.packageName = tree.packageName\n    }\n    if (tree.version) {\n      this.version = tree.version\n    }\n    this.location = tree.location\n    this.path = tree.path\n    if (tree.realpath !== this.path) {\n      this.realpath = tree.realpath\n    }\n    if (tree.resolved !== null) {\n      this.resolved = tree.resolved\n    }\n    if (tree.extraneous) {\n      this.extraneous = true\n    }\n    if (tree.dev) {\n      this.dev = true\n    }\n    if (tree.optional) {\n      this.optional = true\n    }\n    if (tree.devOptional && !tree.dev && !tree.optional) {\n      this.devOptional = true\n    }\n    if (tree.peer) {\n      this.peer = true\n    }\n    if (tree.inBundle) {\n      this.bundled = true\n    }\n    if (tree.inDepBundle) {\n      this.bundler = tree.getBundler().location\n    }\n    if (tree.isProjectRoot) {\n      this.isProjectRoot = true\n    }\n    if (tree.isWorkspace) {\n      this.isWorkspace = true\n    }\n    const bd = tree.package && tree.package.bundleDependencies\n    if (bd && bd.length) {\n      this.bundleDependencies = bd\n    }\n    if (tree.inShrinkwrap) {\n      this.inShrinkwrap = true\n    } else if (tree.hasShrinkwrap) {\n      this.hasShrinkwrap = true\n    }\n    if (tree.error) {\n      this.error = treeError(tree.error)\n    }\n    if (tree.errors && tree.errors.length) {\n      this.errors = tree.errors.map(treeError)\n    }\n\n    // edgesOut sorted by name\n    if (tree.edgesOut.size) {\n      this.edgesOut = new Map([...tree.edgesOut.entries()]\n        .sort(([a], [b]) => localeCompare(a, b))\n        .map(([name, edge]) => [name, new EdgeOut(edge)]))\n    }\n\n    // edgesIn sorted by location\n    if (tree.edgesIn.size) {\n      this.edgesIn = new Set([...tree.edgesIn]\n        .sort((a, b) => localeCompare(a.from.location, b.from.location))\n        .map(edge => new EdgeIn(edge)))\n    }\n\n    if (tree.workspaces && tree.workspaces.size) {\n      this.workspaces = new Map([...tree.workspaces.entries()]\n        .map(([name, path]) => [name, relpath(tree.root.realpath, path)]))\n    }\n\n    // fsChildren sorted by path\n    if (tree.fsChildren.size) {\n      this.fsChildren = new Set([...tree.fsChildren]\n        .sort(({path: a}, {path: b}) => localeCompare(a, b))\n        .map(tree => printableTree(tree, path)))\n    }\n\n    // children sorted by name\n    if (tree.children.size) {\n      this.children = new Map([...tree.children.entries()]\n        .sort(([a], [b]) => localeCompare(a, b))\n        .map(([name, tree]) => [name, printableTree(tree, path)]))\n    }\n  }\n}\n\nclass ArboristVirtualNode extends ArboristNode {\n  constructor (tree, path) {\n    super(tree, path)\n    this.sourceReference = printableTree(tree.sourceReference, path)\n  }\n}\n\nclass ArboristLink extends ArboristNode {\n  constructor (tree, path) {\n    super(tree, path)\n    this.target = printableTree(tree.target, path)\n  }\n}\n\nconst treeError = ({code, path}) => ({\n  code,\n  ...(path ? { path } : {}),\n})\n\n// print out edges without dumping the full node all over again\n// this base class will toJSON as a plain old object, but the\n// util.inspect() output will be a bit cleaner\nclass Edge {\n  constructor (edge) {\n    this.type = edge.type\n    this.name = edge.name\n    this.spec = edge.spec || '*'\n    if (edge.error) {\n      this.error = edge.error\n    }\n    if (edge.overridden) {\n      this.overridden = edge.overridden\n    }\n  }\n}\n\n// don't care about 'from' for edges out\nclass EdgeOut extends Edge {\n  constructor (edge) {\n    super(edge)\n    this.to = edge.to && edge.to.location\n  }\n\n  [util.inspect.custom] () {\n    return `{ ${this.type} ${this.name}@${this.spec}${\n      this.to ? ' -> ' + this.to : ''\n    }${\n      this.error ? ' ' + this.error : ''\n    }${\n      this.overridden ? ' overridden' : ''\n    } }`\n  }\n}\n\n// don't care about 'to' for edges in\nclass EdgeIn extends Edge {\n  constructor (edge) {\n    super(edge)\n    this.from = edge.from && edge.from.location\n  }\n\n  [util.inspect.custom] () {\n    return `{ ${this.from || '\"\"'} ${this.type} ${this.name}@${this.spec}${\n      this.error ? ' ' + this.error : ''\n    }${\n      this.overridden ? ' overridden' : ''\n    } }`\n  }\n}\n\nconst printableTree = (tree, path = []) => {\n  if (!tree) {\n    return tree\n  }\n\n  const Cls = tree.isLink ? ArboristLink\n    : tree.sourceReference ? ArboristVirtualNode\n    : ArboristNode\n  if (path.includes(tree)) {\n    const obj = Object.create(Cls.prototype)\n    return Object.assign(obj, { location: tree.location })\n  }\n  path.push(tree)\n  return new Cls(tree, path)\n}\n\nmodule.exports = printableTree\n"]},"metadata":{},"sourceType":"script"}