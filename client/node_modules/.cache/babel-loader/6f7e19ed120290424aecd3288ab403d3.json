{"ast":null,"code":"const util = require('util');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst pack = require('libnpmpack');\n\nconst libpub = require('libnpmpublish').publish;\n\nconst runScript = require('@npmcli/run-script');\n\nconst pacote = require('pacote');\n\nconst npa = require('npm-package-arg');\n\nconst npmFetch = require('npm-registry-fetch');\n\nconst chalk = require('chalk');\n\nconst otplease = require('./utils/otplease.js');\n\nconst {\n  getContents,\n  logTar\n} = require('./utils/tar.js'); // for historical reasons, publishConfig in package.json can contain ANY config\n// keys that npm supports in .npmrc files and elsewhere.  We *may* want to\n// revisit this at some point, and have a minimal set that's a SemVer-major\n// change that ought to get a RFC written on it.\n\n\nconst flatten = require('./utils/config/flatten.js'); // this is the only case in the CLI where we want to use the old full slow\n// 'read-package-json' module, because we want to pull in all the defaults and\n// metadata, like git sha's and default scripts and all that.\n\n\nconst readJson = util.promisify(require('read-package-json'));\n\nconst BaseCommand = require('./base-command.js');\n\nclass Publish extends BaseCommand {\n  static get description() {\n    return 'Publish a package';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'publish';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['tag', 'access', 'dry-run', 'otp', 'workspace', 'workspaces'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[<folder>]'];\n  }\n\n  exec(args, cb) {\n    this.publish(args).then(() => cb()).catch(cb);\n  }\n\n  execWorkspaces(args, filters, cb) {\n    this.publishWorkspaces(args, filters).then(() => cb()).catch(cb);\n  }\n\n  async publish(args) {\n    if (args.length === 0) args = ['.'];\n    if (args.length !== 1) throw this.usageError();\n    log.verbose('publish', args);\n    const unicode = this.npm.config.get('unicode');\n    const dryRun = this.npm.config.get('dry-run');\n    const json = this.npm.config.get('json');\n    const defaultTag = this.npm.config.get('tag');\n    const ignoreScripts = this.npm.config.get('ignore-scripts');\n    const silent = log.level === 'silent';\n    if (semver.validRange(defaultTag)) throw new Error('Tag name must not be a valid SemVer range: ' + defaultTag.trim());\n    const opts = { ...this.npm.flatOptions\n    }; // you can publish name@version, ./foo.tgz, etc.\n    // even though the default is the 'file:.' cwd.\n\n    const spec = npa(args[0]);\n    let manifest = await this.getManifest(spec, opts);\n    if (manifest.publishConfig) flatten(manifest.publishConfig, opts); // only run scripts for directory type publishes\n\n    if (spec.type === 'directory' && !ignoreScripts) {\n      await runScript({\n        event: 'prepublishOnly',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent\n      });\n    }\n\n    const tarballData = await pack(spec, opts);\n    const pkgContents = await getContents(manifest, tarballData); // The purpose of re-reading the manifest is in case it changed,\n    // so that we send the latest and greatest thing to the registry\n    // note that publishConfig might have changed as well!\n\n    manifest = await this.getManifest(spec, opts);\n    if (manifest.publishConfig) flatten(manifest.publishConfig, opts); // note that logTar calls npmlog.notice(), so if we ARE in silent mode,\n    // this will do nothing, but we still want it in the debuglog if it fails.\n\n    if (!json) logTar(pkgContents, {\n      log,\n      unicode\n    });\n\n    if (!dryRun) {\n      const resolved = npa.resolve(manifest.name, manifest.version);\n      const registry = npmFetch.pickRegistry(resolved, opts);\n      const creds = this.npm.config.getCredentialsByURI(registry);\n\n      if (!creds.token && !creds.username) {\n        throw Object.assign(new Error('This command requires you to be logged in.'), {\n          code: 'ENEEDAUTH'\n        });\n      }\n\n      await otplease(opts, opts => libpub(manifest, tarballData, opts));\n    }\n\n    if (spec.type === 'directory' && !ignoreScripts) {\n      await runScript({\n        event: 'publish',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent\n      });\n      await runScript({\n        event: 'postpublish',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent\n      });\n    }\n\n    if (!this.suppressOutput) {\n      if (!silent && json) this.npm.output(JSON.stringify(pkgContents, null, 2));else if (!silent) this.npm.output(`+ ${pkgContents.id}`);\n    }\n\n    return pkgContents;\n  }\n\n  async publishWorkspaces(args, filters) {\n    // Suppresses JSON output in publish() so we can handle it here\n    this.suppressOutput = true;\n    const results = {};\n    const json = this.npm.config.get('json');\n    const silent = log.level === 'silent';\n\n    const noop = a => a;\n\n    const color = this.npm.color ? chalk : {\n      green: noop,\n      bold: noop\n    };\n    await this.setWorkspaces(filters);\n\n    for (const [name, workspace] of this.workspaces.entries()) {\n      let pkgContents;\n\n      try {\n        pkgContents = await this.publish([workspace]);\n      } catch (err) {\n        if (err.code === 'EPRIVATE') {\n          log.warn('publish', `Skipping workspace ${color.green(name)}, marked as ${color.bold('private')}`);\n          continue;\n        }\n\n        throw err;\n      } // This needs to be in-line w/ the rest of the output that non-JSON\n      // publish generates\n\n\n      if (!silent && !json) this.npm.output(`+ ${pkgContents.id}`);else results[name] = pkgContents;\n    }\n\n    if (!silent && json) this.npm.output(JSON.stringify(results, null, 2));\n  } // if it's a directory, read it from the file system\n  // otherwise, get the full metadata from whatever it is\n\n\n  getManifest(spec, opts) {\n    if (spec.type === 'directory') return readJson(`${spec.fetchSpec}/package.json`);\n    return pacote.manifest(spec, { ...opts,\n      fullMetadata: true\n    });\n  }\n\n}\n\nmodule.exports = Publish;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/publish.js"],"names":["util","require","log","semver","pack","libpub","publish","runScript","pacote","npa","npmFetch","chalk","otplease","getContents","logTar","flatten","readJson","promisify","BaseCommand","Publish","description","name","params","usage","exec","args","cb","then","catch","execWorkspaces","filters","publishWorkspaces","length","usageError","verbose","unicode","npm","config","get","dryRun","json","defaultTag","ignoreScripts","silent","level","validRange","Error","trim","opts","flatOptions","spec","manifest","getManifest","publishConfig","type","event","path","fetchSpec","stdio","pkg","banner","tarballData","pkgContents","resolved","resolve","version","registry","pickRegistry","creds","getCredentialsByURI","token","username","Object","assign","code","suppressOutput","output","JSON","stringify","id","results","noop","a","color","green","bold","setWorkspaces","workspace","workspaces","entries","err","warn","fullMetadata","module","exports"],"mappings":"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","sourcesContent":["const util = require('util')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst pack = require('libnpmpack')\nconst libpub = require('libnpmpublish').publish\nconst runScript = require('@npmcli/run-script')\nconst pacote = require('pacote')\nconst npa = require('npm-package-arg')\nconst npmFetch = require('npm-registry-fetch')\nconst chalk = require('chalk')\n\nconst otplease = require('./utils/otplease.js')\nconst { getContents, logTar } = require('./utils/tar.js')\n\n// for historical reasons, publishConfig in package.json can contain ANY config\n// keys that npm supports in .npmrc files and elsewhere.  We *may* want to\n// revisit this at some point, and have a minimal set that's a SemVer-major\n// change that ought to get a RFC written on it.\nconst flatten = require('./utils/config/flatten.js')\n\n// this is the only case in the CLI where we want to use the old full slow\n// 'read-package-json' module, because we want to pull in all the defaults and\n// metadata, like git sha's and default scripts and all that.\nconst readJson = util.promisify(require('read-package-json'))\n\nconst BaseCommand = require('./base-command.js')\nclass Publish extends BaseCommand {\n  static get description () {\n    return 'Publish a package'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'publish'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return ['tag', 'access', 'dry-run', 'otp', 'workspace', 'workspaces']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[<folder>]',\n    ]\n  }\n\n  exec (args, cb) {\n    this.publish(args).then(() => cb()).catch(cb)\n  }\n\n  execWorkspaces (args, filters, cb) {\n    this.publishWorkspaces(args, filters).then(() => cb()).catch(cb)\n  }\n\n  async publish (args) {\n    if (args.length === 0)\n      args = ['.']\n    if (args.length !== 1)\n      throw this.usageError()\n\n    log.verbose('publish', args)\n\n    const unicode = this.npm.config.get('unicode')\n    const dryRun = this.npm.config.get('dry-run')\n    const json = this.npm.config.get('json')\n    const defaultTag = this.npm.config.get('tag')\n    const ignoreScripts = this.npm.config.get('ignore-scripts')\n    const silent = log.level === 'silent'\n\n    if (semver.validRange(defaultTag))\n      throw new Error('Tag name must not be a valid SemVer range: ' + defaultTag.trim())\n\n    const opts = { ...this.npm.flatOptions }\n\n    // you can publish name@version, ./foo.tgz, etc.\n    // even though the default is the 'file:.' cwd.\n    const spec = npa(args[0])\n    let manifest = await this.getManifest(spec, opts)\n\n    if (manifest.publishConfig)\n      flatten(manifest.publishConfig, opts)\n\n    // only run scripts for directory type publishes\n    if (spec.type === 'directory' && !ignoreScripts) {\n      await runScript({\n        event: 'prepublishOnly',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent,\n      })\n    }\n\n    const tarballData = await pack(spec, opts)\n    const pkgContents = await getContents(manifest, tarballData)\n\n    // The purpose of re-reading the manifest is in case it changed,\n    // so that we send the latest and greatest thing to the registry\n    // note that publishConfig might have changed as well!\n    manifest = await this.getManifest(spec, opts)\n    if (manifest.publishConfig)\n      flatten(manifest.publishConfig, opts)\n\n    // note that logTar calls npmlog.notice(), so if we ARE in silent mode,\n    // this will do nothing, but we still want it in the debuglog if it fails.\n    if (!json)\n      logTar(pkgContents, { log, unicode })\n\n    if (!dryRun) {\n      const resolved = npa.resolve(manifest.name, manifest.version)\n      const registry = npmFetch.pickRegistry(resolved, opts)\n      const creds = this.npm.config.getCredentialsByURI(registry)\n      if (!creds.token && !creds.username) {\n        throw Object.assign(new Error('This command requires you to be logged in.'), {\n          code: 'ENEEDAUTH',\n        })\n      }\n      await otplease(opts, opts => libpub(manifest, tarballData, opts))\n    }\n\n    if (spec.type === 'directory' && !ignoreScripts) {\n      await runScript({\n        event: 'publish',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent,\n      })\n\n      await runScript({\n        event: 'postpublish',\n        path: spec.fetchSpec,\n        stdio: 'inherit',\n        pkg: manifest,\n        banner: !silent,\n      })\n    }\n\n    if (!this.suppressOutput) {\n      if (!silent && json)\n        this.npm.output(JSON.stringify(pkgContents, null, 2))\n      else if (!silent)\n        this.npm.output(`+ ${pkgContents.id}`)\n    }\n\n    return pkgContents\n  }\n\n  async publishWorkspaces (args, filters) {\n    // Suppresses JSON output in publish() so we can handle it here\n    this.suppressOutput = true\n\n    const results = {}\n    const json = this.npm.config.get('json')\n    const silent = log.level === 'silent'\n    const noop = a => a\n    const color = this.npm.color ? chalk : { green: noop, bold: noop }\n    await this.setWorkspaces(filters)\n\n    for (const [name, workspace] of this.workspaces.entries()) {\n      let pkgContents\n      try {\n        pkgContents = await this.publish([workspace])\n      } catch (err) {\n        if (err.code === 'EPRIVATE') {\n          log.warn(\n            'publish',\n            `Skipping workspace ${\n              color.green(name)\n            }, marked as ${\n              color.bold('private')\n            }`\n          )\n          continue\n        }\n        throw err\n      }\n      // This needs to be in-line w/ the rest of the output that non-JSON\n      // publish generates\n      if (!silent && !json)\n        this.npm.output(`+ ${pkgContents.id}`)\n      else\n        results[name] = pkgContents\n    }\n\n    if (!silent && json)\n      this.npm.output(JSON.stringify(results, null, 2))\n  }\n\n  // if it's a directory, read it from the file system\n  // otherwise, get the full metadata from whatever it is\n  getManifest (spec, opts) {\n    if (spec.type === 'directory')\n      return readJson(`${spec.fetchSpec}/package.json`)\n    return pacote.manifest(spec, { ...opts, fullMetadata: true })\n  }\n}\nmodule.exports = Publish\n"]},"metadata":{},"sourceType":"script"}