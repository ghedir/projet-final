{"ast":null,"code":"// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\nconst required = ['type', 'description', 'default', 'key'];\nconst allowed = ['default', 'defaultDescription', 'deprecated', 'description', 'flatten', 'hint', 'key', 'short', 'type', 'typeDescription', 'usage', 'envExport'];\n\nconst {\n  typeDefs: {\n    semver: {\n      type: semver\n    },\n    Umask: {\n      type: Umask\n    },\n    url: {\n      type: url\n    },\n    path: {\n      type: path\n    }\n  }\n} = require('@npmcli/config');\n\nclass Definition {\n  constructor(key, def) {\n    this.key = key; // if it's set falsey, don't export it, otherwise we do by default\n\n    this.envExport = true;\n    Object.assign(this, def);\n    this.validate();\n    if (!this.defaultDescription) this.defaultDescription = describeValue(this.default);\n    if (!this.typeDescription) this.typeDescription = describeType(this.type); // hint is only used for non-boolean values\n\n    if (!this.hint) {\n      if (this.type === Number) this.hint = '<number>';else this.hint = `<${this.key}>`;\n    }\n\n    if (!this.usage) this.usage = describeUsage(this);\n  }\n\n  validate() {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req)) throw new Error(`config lacks ${req}: ${this.key}`);\n    }\n\n    if (!this.key) throw new Error(`config lacks key: ${this.key}`);\n\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field)) throw new Error(`config defines unknown field ${field}: ${this.key}`);\n    }\n  } // a textual description of this config, suitable for help output\n\n\n  describe() {\n    const description = unindent(this.description);\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`;\n    const deprecated = !this.deprecated ? '' : `* DEPRECATED: ${unindent(this.deprecated)}\\n`;\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`);\n  }\n\n}\n\nconst describeUsage = def => {\n  let key = ''; // Single type\n\n  if (!Array.isArray(def.type)) {\n    if (def.short) key = `-${def.short}|`;\n    if (def.type === Boolean && def.default !== false) key = `${key}--no-${def.key}`;else key = `${key}--${def.key}`;\n    if (def.type !== Boolean) key = `${key} ${def.hint}`;\n    return key;\n  }\n\n  key = `--${def.key}`;\n  if (def.short) key = `-${def.short}|--${def.key}`; // Multiple types\n\n  let types = def.type;\n  const multiple = types.includes(Array);\n  const bool = types.includes(Boolean); // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean);\n  if (!types.length) return key;\n  let description;\n  if (!types.some(t => typeof t !== 'string')) // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`;else {\n    // Generic values, use hint\n    description = def.hint;\n  }\n\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`;\n  }\n\n  const usage = `${key} ${description}`;\n  if (multiple) return `${usage} [${usage} ...]`;else return usage;\n};\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type.filter(t => t !== Array).map(t => describeType(t)); // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n\n    const last = descriptions.length > 1 ? [descriptions.pop()] : [];\n    const oxford = descriptions.length > 1 ? ', or ' : ' or ';\n    const words = [descriptions.join(', ')].concat(last).join(oxford);\n    const multiple = type.includes(Array) ? ' (can be set multiple times)' : '';\n    return `${words}${multiple}`;\n  } // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n\n\n  switch (type) {\n    case String:\n      return 'String';\n\n    case Number:\n      return 'Number';\n\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)';\n\n    case Boolean:\n      return 'Boolean';\n\n    case Date:\n      return 'Date';\n\n    case path:\n      return 'Path';\n\n    case semver:\n      return 'SemVer string';\n\n    case url:\n      return 'URL';\n\n    default:\n      return describeValue(type);\n  }\n}; // if it's a string, quote it.  otherwise, just cast to string.\n\n\nconst describeValue = val => typeof val === 'string' ? JSON.stringify(val) : String(val);\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/);\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim();\n};\n\nconst wrap = s => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5;\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop();\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' ';\n    return left + join + right;\n  });\n};\n\nconst wrapAll = s => {\n  let inCodeBlock = false;\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```');\n      return block;\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ');\n      }).join('\\n* ');\n    } else return wrap(block);\n  }).join('\\n\\n');\n};\n\nmodule.exports = Definition;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/utils/config/definition.js"],"names":["required","allowed","typeDefs","semver","type","Umask","url","path","require","Definition","constructor","key","def","envExport","Object","assign","validate","defaultDescription","describeValue","default","typeDescription","describeType","hint","Number","usage","describeUsage","req","prototype","hasOwnProperty","call","Error","field","keys","includes","describe","description","unindent","noEnvExport","deprecated","wrapAll","Array","isArray","short","Boolean","types","multiple","bool","filter","t","length","some","d","join","descriptions","map","last","pop","oxford","words","concat","String","Date","val","JSON","stringify","s","match","trim","split","wrap","cols","Math","min","max","process","stdout","columns","reduce","left","right","inCodeBlock","block","startsWith","endsWith","charAt","substr","li","replace","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,QAAQ,GAAG,CACf,MADe,EAEf,aAFe,EAGf,SAHe,EAIf,KAJe,CAAjB;AAOA,MAAMC,OAAO,GAAG,CACd,SADc,EAEd,oBAFc,EAGd,YAHc,EAId,aAJc,EAKd,SALc,EAMd,MANc,EAOd,KAPc,EAQd,OARc,EASd,MATc,EAUd,iBAVc,EAWd,OAXc,EAYd,WAZc,CAAhB;;AAeA,MAAM;AACJC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,IAAI,EAAED;AAAR,KADA;AAERE,IAAAA,KAAK,EAAE;AAAED,MAAAA,IAAI,EAAEC;AAAR,KAFC;AAGRC,IAAAA,GAAG,EAAE;AAAEF,MAAAA,IAAI,EAAEE;AAAR,KAHG;AAIRC,IAAAA,IAAI,EAAE;AAAEH,MAAAA,IAAI,EAAEG;AAAR;AAJE;AADN,IAOFC,OAAO,CAAC,gBAAD,CAPX;;AASA,MAAMC,UAAN,CAAiB;AACfC,EAAAA,WAAW,CAAEC,GAAF,EAAOC,GAAP,EAAY;AACrB,SAAKD,GAAL,GAAWA,GAAX,CADqB,CAErB;;AACA,SAAKE,SAAL,GAAiB,IAAjB;AACAC,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBH,GAApB;AACA,SAAKI,QAAL;AACA,QAAI,CAAC,KAAKC,kBAAV,EACE,KAAKA,kBAAL,GAA0BC,aAAa,CAAC,KAAKC,OAAN,CAAvC;AACF,QAAI,CAAC,KAAKC,eAAV,EACE,KAAKA,eAAL,GAAuBC,YAAY,CAAC,KAAKjB,IAAN,CAAnC,CATmB,CAUrB;;AACA,QAAI,CAAC,KAAKkB,IAAV,EAAgB;AACd,UAAI,KAAKlB,IAAL,KAAcmB,MAAlB,EACE,KAAKD,IAAL,GAAY,UAAZ,CADF,KAGE,KAAKA,IAAL,GAAa,IAAG,KAAKX,GAAI,GAAzB;AACH;;AACD,QAAI,CAAC,KAAKa,KAAV,EACE,KAAKA,KAAL,GAAaC,aAAa,CAAC,IAAD,CAA1B;AACH;;AAEDT,EAAAA,QAAQ,GAAI;AACV,SAAK,MAAMU,GAAX,IAAkB1B,QAAlB,EAA4B;AAC1B,UAAI,CAACc,MAAM,CAACa,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqC,IAArC,EAA2CH,GAA3C,CAAL,EACE,MAAM,IAAII,KAAJ,CAAW,gBAAeJ,GAAI,KAAI,KAAKf,GAAI,EAA3C,CAAN;AACH;;AACD,QAAI,CAAC,KAAKA,GAAV,EACE,MAAM,IAAImB,KAAJ,CAAW,qBAAoB,KAAKnB,GAAI,EAAxC,CAAN;;AACF,SAAK,MAAMoB,KAAX,IAAoBjB,MAAM,CAACkB,IAAP,CAAY,IAAZ,CAApB,EAAuC;AACrC,UAAI,CAAC/B,OAAO,CAACgC,QAAR,CAAiBF,KAAjB,CAAL,EACE,MAAM,IAAID,KAAJ,CAAW,gCAA+BC,KAAM,KAAI,KAAKpB,GAAI,EAA7D,CAAN;AACH;AACF,GAjCc,CAmCf;;;AACAuB,EAAAA,QAAQ,GAAI;AACV,UAAMC,WAAW,GAAGC,QAAQ,CAAC,KAAKD,WAAN,CAA5B;AACA,UAAME,WAAW,GAAG,KAAKxB,SAAL,GAAiB,EAAjB,GAAuB;AAC/C;AACA,CAFI;AAGA,UAAMyB,UAAU,GAAG,CAAC,KAAKA,UAAN,GAAmB,EAAnB,GACd,iBAAgBF,QAAQ,CAAC,KAAKE,UAAN,CAAkB,IAD/C;AAEA,WAAOC,OAAO,CAAE,UAAS,KAAK5B,GAAI;AACtC;AACA,aAAayB,QAAQ,CAAC,KAAKnB,kBAAN,CAA0B;AAC/C,UAAUmB,QAAQ,CAAC,KAAKhB,eAAN,CAAuB;AACzC,EAAEkB,UAAW;AACb,EAAEH,WAAY;AACd,EAAEE,WAAY,EANI,CAAd;AAOD;;AAlDc;;AAqDjB,MAAMZ,aAAa,GAAIb,GAAD,IAAS;AAC7B,MAAID,GAAG,GAAG,EAAV,CAD6B,CAG7B;;AACA,MAAI,CAAC6B,KAAK,CAACC,OAAN,CAAc7B,GAAG,CAACR,IAAlB,CAAL,EAA8B;AAC5B,QAAIQ,GAAG,CAAC8B,KAAR,EACE/B,GAAG,GAAI,IAAGC,GAAG,CAAC8B,KAAM,GAApB;AAEF,QAAI9B,GAAG,CAACR,IAAJ,KAAauC,OAAb,IAAwB/B,GAAG,CAACO,OAAJ,KAAgB,KAA5C,EACER,GAAG,GAAI,GAAEA,GAAI,QAAOC,GAAG,CAACD,GAAI,EAA5B,CADF,KAGEA,GAAG,GAAI,GAAEA,GAAI,KAAIC,GAAG,CAACD,GAAI,EAAzB;AAEF,QAAIC,GAAG,CAACR,IAAJ,KAAauC,OAAjB,EACEhC,GAAG,GAAI,GAAEA,GAAI,IAAGC,GAAG,CAACU,IAAK,EAAzB;AAEF,WAAOX,GAAP;AACD;;AAEDA,EAAAA,GAAG,GAAI,KAAIC,GAAG,CAACD,GAAI,EAAnB;AACA,MAAIC,GAAG,CAAC8B,KAAR,EACE/B,GAAG,GAAI,IAAGC,GAAG,CAAC8B,KAAM,MAAK9B,GAAG,CAACD,GAAI,EAAjC,CArB2B,CAuB7B;;AACA,MAAIiC,KAAK,GAAGhC,GAAG,CAACR,IAAhB;AACA,QAAMyC,QAAQ,GAAGD,KAAK,CAACX,QAAN,CAAeO,KAAf,CAAjB;AACA,QAAMM,IAAI,GAAGF,KAAK,CAACX,QAAN,CAAeU,OAAf,CAAb,CA1B6B,CA4B7B;AACA;;AACAC,EAAAA,KAAK,GAAGA,KAAK,CAACG,MAAN,CAAaC,CAAC,IAAIA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAKR,KAApB,IAA6BQ,CAAC,KAAKL,OAArD,CAAR;AAEA,MAAI,CAACC,KAAK,CAACK,MAAX,EACE,OAAOtC,GAAP;AAEF,MAAIwB,WAAJ;AACA,MAAI,CAACS,KAAK,CAACM,IAAN,CAAWF,CAAC,IAAI,OAAOA,CAAP,KAAa,QAA7B,CAAL,EACE;AACAb,IAAAA,WAAW,GAAI,IAAGS,KAAK,CAACG,MAAN,CAAaI,CAAC,IAAIA,CAAlB,EAAqBC,IAArB,CAA0B,GAA1B,CAA+B,GAAjD,CAFF,KAGK;AACH;AACAjB,IAAAA,WAAW,GAAGvB,GAAG,CAACU,IAAlB;AACD;;AAED,MAAIwB,IAAJ,EAAU;AACR;AACA;AACA;AACAnC,IAAAA,GAAG,GAAI,QAAOC,GAAG,CAACD,GAAI,IAAGA,GAAI,EAA7B;AACD;;AAED,QAAMa,KAAK,GAAI,GAAEb,GAAI,IAAGwB,WAAY,EAApC;AACA,MAAIU,QAAJ,EACE,OAAQ,GAAErB,KAAM,KAAIA,KAAM,OAA1B,CADF,KAGE,OAAOA,KAAP;AACH,CAxDD;;AA0DA,MAAMH,YAAY,GAAGjB,IAAI,IAAI;AAC3B,MAAIoC,KAAK,CAACC,OAAN,CAAcrC,IAAd,CAAJ,EAAyB;AACvB,UAAMiD,YAAY,GAAGjD,IAAI,CACtB2C,MADkB,CACXC,CAAC,IAAIA,CAAC,KAAKR,KADA,EAElBc,GAFkB,CAEdN,CAAC,IAAI3B,YAAY,CAAC2B,CAAD,CAFH,CAArB,CADuB,CAKvB;AACA;AACA;AACA;AACA;;AACA,UAAMO,IAAI,GAAGF,YAAY,CAACJ,MAAb,GAAsB,CAAtB,GAA0B,CAACI,YAAY,CAACG,GAAb,EAAD,CAA1B,GAAiD,EAA9D;AACA,UAAMC,MAAM,GAAGJ,YAAY,CAACJ,MAAb,GAAsB,CAAtB,GAA0B,OAA1B,GAAoC,MAAnD;AACA,UAAMS,KAAK,GAAG,CAACL,YAAY,CAACD,IAAb,CAAkB,IAAlB,CAAD,EAA0BO,MAA1B,CAAiCJ,IAAjC,EAAuCH,IAAvC,CAA4CK,MAA5C,CAAd;AACA,UAAMZ,QAAQ,GAAGzC,IAAI,CAAC6B,QAAL,CAAcO,KAAd,IAAuB,8BAAvB,GACb,EADJ;AAEA,WAAQ,GAAEkB,KAAM,GAAEb,QAAS,EAA3B;AACD,GAjB0B,CAmB3B;AACA;AACA;;;AACA,UAAQzC,IAAR;AACE,SAAKwD,MAAL;AACE,aAAO,QAAP;;AACF,SAAKrC,MAAL;AACE,aAAO,QAAP;;AACF,SAAKlB,KAAL;AACE,aAAO,mDAAP;;AACF,SAAKsC,OAAL;AACE,aAAO,SAAP;;AACF,SAAKkB,IAAL;AACE,aAAO,MAAP;;AACF,SAAKtD,IAAL;AACE,aAAO,MAAP;;AACF,SAAKJ,MAAL;AACE,aAAO,eAAP;;AACF,SAAKG,GAAL;AACE,aAAO,KAAP;;AACF;AACE,aAAOY,aAAa,CAACd,IAAD,CAApB;AAlBJ;AAoBD,CA1CD,C,CA4CA;;;AACA,MAAMc,aAAa,GAAG4C,GAAG,IACvB,OAAOA,GAAP,KAAe,QAAf,GAA0BC,IAAI,CAACC,SAAL,CAAeF,GAAf,CAA1B,GAAgDF,MAAM,CAACE,GAAD,CADxD;;AAGA,MAAM1B,QAAQ,GAAG6B,CAAC,IAAI;AACpB;AACA;AACA,QAAMC,KAAK,GAAGD,CAAC,CAACC,KAAF,CAAQ,MAAR,CAAd;AACA,SAAO,CAACA,KAAD,GAASD,CAAC,CAACE,IAAF,EAAT,GAAoBF,CAAC,CAACG,KAAF,CAAQF,KAAK,CAAC,CAAD,CAAb,EAAkBd,IAAlB,CAAuB,IAAvB,EAA6Be,IAA7B,EAA3B;AACD,CALD;;AAOA,MAAME,IAAI,GAAIJ,CAAD,IAAO;AAClB,QAAMK,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAAS,EAAT,EAAaC,OAAO,CAACC,MAAR,CAAeC,OAA5B,KAAwC,EAAjD,EAAqD,EAArD,IAA2D,CAAxE;AACA,SAAOxC,QAAQ,CAAC6B,CAAD,CAAR,CAAYG,KAAZ,CAAkB,QAAlB,EAA4BS,MAA5B,CAAmC,CAACC,IAAD,EAAOC,KAAP,KAAiB;AACzD,UAAMxB,IAAI,GAAGuB,IAAI,CAACV,KAAL,CAAW,IAAX,EAAiBZ,GAAjB,EAAb;AACA,UAAMJ,IAAI,GAAGG,IAAI,CAACN,MAAL,IAAeM,IAAI,CAACN,MAAL,GAAc8B,KAAK,CAAC9B,MAApB,GAA6BqB,IAA5C,GAAmD,IAAnD,GAA0D,GAAvE;AACA,WAAOQ,IAAI,GAAG1B,IAAP,GAAc2B,KAArB;AACD,GAJM,CAAP;AAKD,CAPD;;AASA,MAAMxC,OAAO,GAAG0B,CAAC,IAAI;AACnB,MAAIe,WAAW,GAAG,KAAlB;AACA,SAAOf,CAAC,CAACG,KAAF,CAAQ,MAAR,EAAgBd,GAAhB,CAAoB2B,KAAK,IAAI;AAClC,QAAID,WAAW,IAAIC,KAAK,CAACC,UAAN,CAAiB,KAAjB,CAAnB,EAA4C;AAC1CF,MAAAA,WAAW,GAAG,CAACC,KAAK,CAACE,QAAN,CAAe,KAAf,CAAf;AACA,aAAOF,KAAP;AACD;;AAED,QAAIA,KAAK,CAACG,MAAN,CAAa,CAAb,MAAoB,GAAxB,EAA6B;AAC3B,aAAO,OAAOH,KAAK,CAACI,MAAN,CAAa,CAAb,EAAgBlB,IAAhB,GAAuBC,KAAvB,CAA6B,MAA7B,EAAqCd,GAArC,CAAyCgC,EAAE,IAAI;AAC3D,eAAOjB,IAAI,CAACiB,EAAD,CAAJ,CAASC,OAAT,CAAiB,KAAjB,EAAwB,MAAxB,CAAP;AACD,OAFa,EAEXnC,IAFW,CAEN,MAFM,CAAd;AAGD,KAJD,MAKE,OAAOiB,IAAI,CAACY,KAAD,CAAX;AACH,GAZM,EAYJ7B,IAZI,CAYC,MAZD,CAAP;AAaD,CAfD;;AAiBAoC,MAAM,CAACC,OAAP,GAAiBhF,UAAjB","sourcesContent":["// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\n\nconst required = [\n  'type',\n  'description',\n  'default',\n  'key',\n]\n\nconst allowed = [\n  'default',\n  'defaultDescription',\n  'deprecated',\n  'description',\n  'flatten',\n  'hint',\n  'key',\n  'short',\n  'type',\n  'typeDescription',\n  'usage',\n  'envExport',\n]\n\nconst {\n  typeDefs: {\n    semver: { type: semver },\n    Umask: { type: Umask },\n    url: { type: url },\n    path: { type: path },\n  },\n} = require('@npmcli/config')\n\nclass Definition {\n  constructor (key, def) {\n    this.key = key\n    // if it's set falsey, don't export it, otherwise we do by default\n    this.envExport = true\n    Object.assign(this, def)\n    this.validate()\n    if (!this.defaultDescription)\n      this.defaultDescription = describeValue(this.default)\n    if (!this.typeDescription)\n      this.typeDescription = describeType(this.type)\n    // hint is only used for non-boolean values\n    if (!this.hint) {\n      if (this.type === Number)\n        this.hint = '<number>'\n      else\n        this.hint = `<${this.key}>`\n    }\n    if (!this.usage)\n      this.usage = describeUsage(this)\n  }\n\n  validate () {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req))\n        throw new Error(`config lacks ${req}: ${this.key}`)\n    }\n    if (!this.key)\n      throw new Error(`config lacks key: ${this.key}`)\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field))\n        throw new Error(`config defines unknown field ${field}: ${this.key}`)\n    }\n  }\n\n  // a textual description of this config, suitable for help output\n  describe () {\n    const description = unindent(this.description)\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`\n    const deprecated = !this.deprecated ? ''\n      : `* DEPRECATED: ${unindent(this.deprecated)}\\n`\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`)\n  }\n}\n\nconst describeUsage = (def) => {\n  let key = ''\n\n  // Single type\n  if (!Array.isArray(def.type)) {\n    if (def.short)\n      key = `-${def.short}|`\n\n    if (def.type === Boolean && def.default !== false)\n      key = `${key}--no-${def.key}`\n    else\n      key = `${key}--${def.key}`\n\n    if (def.type !== Boolean)\n      key = `${key} ${def.hint}`\n\n    return key\n  }\n\n  key = `--${def.key}`\n  if (def.short)\n    key = `-${def.short}|--${def.key}`\n\n  // Multiple types\n  let types = def.type\n  const multiple = types.includes(Array)\n  const bool = types.includes(Boolean)\n\n  // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean)\n\n  if (!types.length)\n    return key\n\n  let description\n  if (!types.some(t => typeof t !== 'string'))\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`\n  else {\n    // Generic values, use hint\n    description = def.hint\n  }\n\n  if (bool) {\n    // Currently none of our multi-type configs with boolean values default to\n    // false so all their hints should show `--no-`, if we ever add ones that\n    // default to false we can branch the logic here\n    key = `--no-${def.key}|${key}`\n  }\n\n  const usage = `${key} ${description}`\n  if (multiple)\n    return `${usage} [${usage} ...]`\n  else\n    return usage\n}\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type\n      .filter(t => t !== Array)\n      .map(t => describeType(t))\n\n    // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n    const last = descriptions.length > 1 ? [descriptions.pop()] : []\n    const oxford = descriptions.length > 1 ? ', or ' : ' or '\n    const words = [descriptions.join(', ')].concat(last).join(oxford)\n    const multiple = type.includes(Array) ? ' (can be set multiple times)'\n      : ''\n    return `${words}${multiple}`\n  }\n\n  // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n  switch (type) {\n    case String:\n      return 'String'\n    case Number:\n      return 'Number'\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)'\n    case Boolean:\n      return 'Boolean'\n    case Date:\n      return 'Date'\n    case path:\n      return 'Path'\n    case semver:\n      return 'SemVer string'\n    case url:\n      return 'URL'\n    default:\n      return describeValue(type)\n  }\n}\n\n// if it's a string, quote it.  otherwise, just cast to string.\nconst describeValue = val =>\n  typeof val === 'string' ? JSON.stringify(val) : String(val)\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/)\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim()\n}\n\nconst wrap = (s) => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop()\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' '\n    return left + join + right\n  })\n}\n\nconst wrapAll = s => {\n  let inCodeBlock = false\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```')\n      return block\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ')\n      }).join('\\n* ')\n    } else\n      return wrap(block)\n  }).join('\\n\\n')\n}\n\nmodule.exports = Definition\n"]},"metadata":{},"sourceType":"script"}