{"ast":null,"code":"// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst {\n  dirname\n} = require('path');\n\nconst {\n  breadth\n} = require('treeverse'); // sort a key/value object into a string of JSON stringified keys and vals\n\n\nconst sortKV = obj => Object.keys(obj).sort(localeCompare).map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`).join('\\n'); // for checking against previous entries\n\n\nconst match = (p, n) => p.integrity && n.integrity ? p.integrity === n.integrity : p.resolved && n.resolved ? p.resolved === n.resolved : p.version && n.version ? p.version === n.version : true;\n\nconst prefix = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`;\nconst nullSymbol = Symbol('null');\n\nclass YarnLock {\n  static parse(data) {\n    return new YarnLock().parse(data);\n  }\n\n  static fromTree(tree) {\n    return new YarnLock().fromTree(tree);\n  }\n\n  constructor() {\n    this.entries = null;\n    this.endCurrent();\n  }\n\n  endCurrent() {\n    this.current = null;\n    this.subkey = nullSymbol;\n  }\n\n  parse(data) {\n    const ENTRY_START = /^[^\\s].*:$/;\n    const SUBKEY = /^ {2}[^\\s]+:$/;\n    const SUBVAL = /^ {4}[^\\s]+ .+$/;\n    const METADATA = /^ {2}[^\\s]+ .+$/;\n    this.entries = new Map();\n    this.current = null;\n    const linere = /([^\\r\\n]*)\\r?\\n/gm;\n    let match;\n    let lineNum = 0;\n\n    if (!/\\n$/.test(data)) {\n      data += '\\n';\n    }\n\n    while (match = linere.exec(data)) {\n      const line = match[1];\n      lineNum++;\n\n      if (line.charAt(0) === '#') {\n        continue;\n      }\n\n      if (line === '') {\n        this.endCurrent();\n        continue;\n      }\n\n      if (ENTRY_START.test(line)) {\n        this.endCurrent();\n        const specs = this.splitQuoted(line.slice(0, -1), /, */);\n        this.current = new YarnLockEntry(specs);\n        specs.forEach(spec => this.entries.set(spec, this.current));\n        continue;\n      }\n\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1);\n        this.current[this.subkey] = {};\n        continue;\n      }\n\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ');\n\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1];\n          continue;\n        }\n      } // any other metadata\n\n\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ');\n\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') {\n            metadata[1] = metadata[1].replace(/#.*/, '');\n          }\n\n          this.current[metadata[0]] = metadata[1];\n          continue;\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum\n      });\n    }\n\n    this.endCurrent();\n    return this;\n  }\n\n  splitQuoted(str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim);\n    const out = [];\n    let o = 0;\n\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i];\n\n      if (/^\".*\"$/.test(chunk)) {\n        out[o++] = chunk.trim().slice(1, -1);\n      } else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1);\n\n        while (++i < split.length) {\n          const n = split[i]; // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1);\n            break;\n          } else {\n            collect += n;\n          }\n        }\n\n        out[o++] = collect;\n      } else {\n        out[o++] = chunk.trim();\n      }\n    }\n\n    return out;\n  }\n\n  toString() {\n    return prefix + [...new Set([...this.entries.values()])].map(e => e.toString()).sort(localeCompare).join('\\n\\n') + '\\n';\n  }\n\n  fromTree(tree) {\n    this.entries = new Map(); // walk the tree in a deterministic order, breadth-first, alphabetical\n\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren].sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name))\n    });\n    return this;\n  }\n\n  addEntryFromNode(node) {\n    const specs = [...node.edgesIn].map(e => `${node.name}@${e.spec}`).sort(localeCompare); // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n\n    const n = this.entryDataFromNode(node);\n    let priorEntry = null;\n    const newSpecs = [];\n\n    for (const s of specs) {\n      const prev = this.entries.get(s); // no previous entry for this spec at all, so it's new\n\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) {\n          priorEntry.addSpec(s);\n        } else {\n          newSpecs.push(s);\n        }\n\n        continue;\n      }\n\n      const m = match(prev, n); // there was a prior entry, but a different thing.  skip this one\n\n      if (!m) {\n        continue;\n      } // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n\n\n      if (!priorEntry) {\n        priorEntry = prev;\n\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s);\n          this.entries.set(s, priorEntry);\n        }\n\n        newSpecs.length = 0;\n        continue;\n      } // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n\n\n      priorEntry.addSpec(s);\n      this.entries.set(s, priorEntry);\n    } // if we never found a matching prior, then this is a whole new thing\n\n\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n);\n\n      for (const s of newSpecs) {\n        this.entries.set(s, entry);\n      }\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n);\n    }\n  }\n\n  entryDataFromNode(node) {\n    const n = {};\n\n    if (node.package.dependencies) {\n      n.dependencies = node.package.dependencies;\n    }\n\n    if (node.package.optionalDependencies) {\n      n.optionalDependencies = node.package.optionalDependencies;\n    }\n\n    if (node.version) {\n      n.version = node.version;\n    }\n\n    if (node.resolved) {\n      n.resolved = consistentResolve(node.resolved, node.isLink ? dirname(node.path) : node.path, node.root.path, true);\n    }\n\n    if (node.integrity) {\n      n.integrity = node.integrity;\n    }\n\n    return n;\n  }\n\n  static get Entry() {\n    return YarnLockEntry;\n  }\n\n}\n\nconst _specs = Symbol('_specs');\n\nclass YarnLockEntry {\n  constructor(specs) {\n    this[_specs] = new Set(specs);\n    this.resolved = null;\n    this.version = null;\n    this.integrity = null;\n    this.dependencies = null;\n    this.optionalDependencies = null;\n  }\n\n  toString() {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]].sort(localeCompare).map(JSON.stringify).join(', ') + ':\\n' + Object.getOwnPropertyNames(this).filter(prop => this[prop] !== null).sort((a, b) =>\n    /* istanbul ignore next - sort call order is unpredictable */\n    typeof this[a] === 'object' === (typeof this[b] === 'object') ? localeCompare(a, b) : typeof this[a] === 'object' ? 1 : -1).map(prop => typeof this[prop] !== 'object' ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n` : Object.keys(this[prop]).length === 0 ? '' : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n').join('')).trim();\n  }\n\n  addSpec(spec) {\n    this[_specs].add(spec);\n  }\n\n}\n\nmodule.exports = YarnLock;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/yarn-lock.js"],"names":["localeCompare","require","consistentResolve","dirname","breadth","sortKV","obj","Object","keys","sort","map","k","JSON","stringify","join","match","p","n","integrity","resolved","version","prefix","nullSymbol","Symbol","YarnLock","parse","data","fromTree","tree","constructor","entries","endCurrent","current","subkey","ENTRY_START","SUBKEY","SUBVAL","METADATA","Map","linere","lineNum","test","exec","line","charAt","specs","splitQuoted","slice","YarnLockEntry","forEach","spec","set","subval","trimLeft","length","metadata","replace","assign","Error","position","index","content","str","delim","split","out","o","i","chunk","trim","collect","trimRight","toString","Set","values","e","visit","node","addEntryFromNode","getChildren","children","fsChildren","a","b","depth","name","edgesIn","entryDataFromNode","priorEntry","newSpecs","s","prev","get","addSpec","push","m","entry","package","dependencies","optionalDependencies","isLink","path","root","Entry","_specs","getOwnPropertyNames","filter","prop","add","module","exports"],"mappings":"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","sourcesContent":["// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst consistentResolve = require('./consistent-resolve.js')\nconst {dirname} = require('path')\nconst {breadth} = require('treeverse')\n\n// sort a key/value object into a string of JSON stringified keys and vals\nconst sortKV = obj => Object.keys(obj)\n  .sort(localeCompare)\n  .map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`)\n  .join('\\n')\n\n// for checking against previous entries\nconst match = (p, n) =>\n  p.integrity && n.integrity ? p.integrity === n.integrity\n  : p.resolved && n.resolved ? p.resolved === n.resolved\n  : p.version && n.version ? p.version === n.version\n  : true\n\nconst prefix =\n`# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`\n\nconst nullSymbol = Symbol('null')\nclass YarnLock {\n  static parse (data) {\n    return new YarnLock().parse(data)\n  }\n\n  static fromTree (tree) {\n    return new YarnLock().fromTree(tree)\n  }\n\n  constructor () {\n    this.entries = null\n    this.endCurrent()\n  }\n\n  endCurrent () {\n    this.current = null\n    this.subkey = nullSymbol\n  }\n\n  parse (data) {\n    const ENTRY_START = /^[^\\s].*:$/\n    const SUBKEY = /^ {2}[^\\s]+:$/\n    const SUBVAL = /^ {4}[^\\s]+ .+$/\n    const METADATA = /^ {2}[^\\s]+ .+$/\n    this.entries = new Map()\n    this.current = null\n    const linere = /([^\\r\\n]*)\\r?\\n/gm\n    let match\n    let lineNum = 0\n    if (!/\\n$/.test(data)) {\n      data += '\\n'\n    }\n    while (match = linere.exec(data)) {\n      const line = match[1]\n      lineNum++\n      if (line.charAt(0) === '#') {\n        continue\n      }\n      if (line === '') {\n        this.endCurrent()\n        continue\n      }\n      if (ENTRY_START.test(line)) {\n        this.endCurrent()\n        const specs = this.splitQuoted(line.slice(0, -1), /, */)\n        this.current = new YarnLockEntry(specs)\n        specs.forEach(spec => this.entries.set(spec, this.current))\n        continue\n      }\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1)\n        this.current[this.subkey] = {}\n        continue\n      }\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ')\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1]\n          continue\n        }\n      }\n      // any other metadata\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ')\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') {\n            metadata[1] = metadata[1].replace(/#.*/, '')\n          }\n          this.current[metadata[0]] = metadata[1]\n          continue\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum,\n      })\n    }\n    this.endCurrent()\n    return this\n  }\n\n  splitQuoted (str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim)\n    const out = []\n    let o = 0\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i]\n      if (/^\".*\"$/.test(chunk)) {\n        out[o++] = chunk.trim().slice(1, -1)\n      } else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1)\n        while (++i < split.length) {\n          const n = split[i]\n          // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1)\n            break\n          } else {\n            collect += n\n          }\n        }\n        out[o++] = collect\n      } else {\n        out[o++] = chunk.trim()\n      }\n    }\n    return out\n  }\n\n  toString () {\n    return prefix + [...new Set([...this.entries.values()])]\n      .map(e => e.toString())\n      .sort(localeCompare).join('\\n\\n') + '\\n'\n  }\n\n  fromTree (tree) {\n    this.entries = new Map()\n    // walk the tree in a deterministic order, breadth-first, alphabetical\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren]\n        .sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name)),\n    })\n    return this\n  }\n\n  addEntryFromNode (node) {\n    const specs = [...node.edgesIn]\n      .map(e => `${node.name}@${e.spec}`)\n      .sort(localeCompare)\n\n    // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n    const n = this.entryDataFromNode(node)\n    let priorEntry = null\n    const newSpecs = []\n    for (const s of specs) {\n      const prev = this.entries.get(s)\n      // no previous entry for this spec at all, so it's new\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) {\n          priorEntry.addSpec(s)\n        } else {\n          newSpecs.push(s)\n        }\n        continue\n      }\n\n      const m = match(prev, n)\n      // there was a prior entry, but a different thing.  skip this one\n      if (!m) {\n        continue\n      }\n\n      // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n      if (!priorEntry) {\n        priorEntry = prev\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s)\n          this.entries.set(s, priorEntry)\n        }\n        newSpecs.length = 0\n        continue\n      }\n\n      // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n      priorEntry.addSpec(s)\n      this.entries.set(s, priorEntry)\n    }\n\n    // if we never found a matching prior, then this is a whole new thing\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n)\n      for (const s of newSpecs) {\n        this.entries.set(s, entry)\n      }\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n)\n    }\n  }\n\n  entryDataFromNode (node) {\n    const n = {}\n    if (node.package.dependencies) {\n      n.dependencies = node.package.dependencies\n    }\n    if (node.package.optionalDependencies) {\n      n.optionalDependencies = node.package.optionalDependencies\n    }\n    if (node.version) {\n      n.version = node.version\n    }\n    if (node.resolved) {\n      n.resolved = consistentResolve(\n        node.resolved,\n        node.isLink ? dirname(node.path) : node.path,\n        node.root.path,\n        true\n      )\n    }\n    if (node.integrity) {\n      n.integrity = node.integrity\n    }\n\n    return n\n  }\n\n  static get Entry () {\n    return YarnLockEntry\n  }\n}\n\nconst _specs = Symbol('_specs')\nclass YarnLockEntry {\n  constructor (specs) {\n    this[_specs] = new Set(specs)\n    this.resolved = null\n    this.version = null\n    this.integrity = null\n    this.dependencies = null\n    this.optionalDependencies = null\n  }\n\n  toString () {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]]\n      .sort(localeCompare)\n      .map(JSON.stringify).join(', ') +\n      ':\\n' +\n      Object.getOwnPropertyNames(this)\n        .filter(prop => this[prop] !== null)\n        .sort(\n          (a, b) =>\n          /* istanbul ignore next - sort call order is unpredictable */\n            (typeof this[a] === 'object') === (typeof this[b] === 'object')\n              ? localeCompare(a, b)\n              : typeof this[a] === 'object' ? 1 : -1)\n        .map(prop =>\n          typeof this[prop] !== 'object'\n            ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n`\n            : Object.keys(this[prop]).length === 0 ? ''\n            : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n')\n        .join('')).trim()\n  }\n\n  addSpec (spec) {\n    this[_specs].add(spec)\n  }\n}\n\nmodule.exports = YarnLock\n"]},"metadata":{},"sourceType":"script"}