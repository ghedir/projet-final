{"ast":null,"code":"const {\n  spawn\n} = require('child_process');\n\nconst inferOwner = require('infer-owner');\n\nconst isPipe = (stdio = 'pipe', fd) => stdio === 'pipe' || stdio === null ? true : Array.isArray(stdio) ? isPipe(stdio[fd], fd) : false; // 'extra' object is for decorating the error a bit more\n\n\nconst promiseSpawn = (cmd, args, opts, extra = {}) => {\n  const cwd = opts.cwd || process.cwd();\n  const isRoot = process.getuid && process.getuid() === 0;\n  const {\n    uid,\n    gid\n  } = isRoot ? inferOwner.sync(cwd) : {};\n  return promiseSpawnUid(cmd, args, { ...opts,\n    cwd,\n    uid,\n    gid\n  }, extra);\n};\n\nconst stdioResult = (stdout, stderr, {\n  stdioString,\n  stdio\n}) => stdioString ? {\n  stdout: isPipe(stdio, 1) ? Buffer.concat(stdout).toString() : null,\n  stderr: isPipe(stdio, 2) ? Buffer.concat(stderr).toString() : null\n} : {\n  stdout: isPipe(stdio, 1) ? Buffer.concat(stdout) : null,\n  stderr: isPipe(stdio, 2) ? Buffer.concat(stderr) : null\n};\n\nconst promiseSpawnUid = (cmd, args, opts, extra) => {\n  let proc;\n  const p = new Promise((res, rej) => {\n    proc = spawn(cmd, args, opts);\n    const stdout = [];\n    const stderr = [];\n\n    const reject = er => rej(Object.assign(er, {\n      cmd,\n      args,\n      ...stdioResult(stdout, stderr, opts),\n      ...extra\n    }));\n\n    proc.on('error', reject);\n\n    if (proc.stdout) {\n      proc.stdout.on('data', c => stdout.push(c)).on('error', reject);\n      proc.stdout.on('error', er => reject(er));\n    }\n\n    if (proc.stderr) {\n      proc.stderr.on('data', c => stderr.push(c)).on('error', reject);\n      proc.stderr.on('error', er => reject(er));\n    }\n\n    proc.on('close', (code, signal) => {\n      const result = {\n        cmd,\n        args,\n        code,\n        signal,\n        ...stdioResult(stdout, stderr, opts),\n        ...extra\n      };\n      if (code || signal) rej(Object.assign(new Error('command failed'), result));else res(result);\n    });\n  });\n  p.stdin = proc.stdin;\n  p.process = proc;\n  return p;\n};\n\nmodule.exports = promiseSpawn;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/promise-spawn/index.js"],"names":["spawn","require","inferOwner","isPipe","stdio","fd","Array","isArray","promiseSpawn","cmd","args","opts","extra","cwd","process","isRoot","getuid","uid","gid","sync","promiseSpawnUid","stdioResult","stdout","stderr","stdioString","Buffer","concat","toString","proc","p","Promise","res","rej","reject","er","Object","assign","on","c","push","code","signal","result","Error","stdin","module","exports"],"mappings":"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","sourcesContent":["const {spawn} = require('child_process')\n\nconst inferOwner = require('infer-owner')\n\nconst isPipe = (stdio = 'pipe', fd) =>\n  stdio === 'pipe' || stdio === null ? true\n  : Array.isArray(stdio) ? isPipe(stdio[fd], fd)\n  : false\n\n// 'extra' object is for decorating the error a bit more\nconst promiseSpawn = (cmd, args, opts, extra = {}) => {\n  const cwd = opts.cwd || process.cwd()\n  const isRoot = process.getuid && process.getuid() === 0\n  const { uid, gid } = isRoot ? inferOwner.sync(cwd) : {}\n  return promiseSpawnUid(cmd, args, {\n    ...opts,\n    cwd,\n    uid,\n    gid\n  }, extra)\n}\n\nconst stdioResult = (stdout, stderr, {stdioString, stdio}) =>\n  stdioString ? {\n    stdout: isPipe(stdio, 1) ? Buffer.concat(stdout).toString() : null,\n    stderr: isPipe(stdio, 2) ? Buffer.concat(stderr).toString() : null,\n  }\n  : {\n    stdout: isPipe(stdio, 1) ? Buffer.concat(stdout) : null,\n    stderr: isPipe(stdio, 2) ? Buffer.concat(stderr) : null,\n  }\n\nconst promiseSpawnUid = (cmd, args, opts, extra) => {\n  let proc\n  const p = new Promise((res, rej) => {\n    proc = spawn(cmd, args, opts)\n    const stdout = []\n    const stderr = []\n    const reject = er => rej(Object.assign(er, {\n      cmd,\n      args,\n      ...stdioResult(stdout, stderr, opts),\n      ...extra,\n    }))\n    proc.on('error', reject)\n    if (proc.stdout) {\n      proc.stdout.on('data', c => stdout.push(c)).on('error', reject)\n      proc.stdout.on('error', er => reject(er))\n    }\n    if (proc.stderr) {\n      proc.stderr.on('data', c => stderr.push(c)).on('error', reject)\n      proc.stderr.on('error', er => reject(er))\n    }\n    proc.on('close', (code, signal) => {\n      const result = {\n        cmd,\n        args,\n        code,\n        signal,\n        ...stdioResult(stdout, stderr, opts),\n        ...extra\n      }\n      if (code || signal)\n        rej(Object.assign(new Error('command failed'), result))\n      else\n        res(result)\n    })\n  })\n\n  p.stdin = proc.stdin\n  p.process = proc\n  return p\n}\n\nmodule.exports = promiseSpawn\n"]},"metadata":{},"sourceType":"script"}