{"ast":null,"code":"// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\nconst {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst writeFile = promisify(fs.writeFile);\nconst readFile = promisify(fs.readFile);\nconst chmod = promisify(fs.chmod);\nconst stat = promisify(fs.stat);\nconst unlink = promisify(fs.unlink);\n\nconst {\n  dirname,\n  relative\n} = require('path');\n\nconst mkdir = require('mkdirp-infer-owner');\n\nconst toBatchSyntax = require('./lib/to-batch-syntax');\n\nconst shebangExpr = /^#\\!\\s*(?:\\/usr\\/bin\\/env)?\\s*([^ \\t]+=[^ \\t]+\\s+)*\\s*([^ \\t]+)(.*)$/;\n\nconst cmdShimIfExists = (from, to) => stat(from).then(() => cmdShim(from, to), () => {}); // Try to unlink, but ignore errors.\n// Any problems will surface later.\n\n\nconst rm = path => unlink(path).catch(() => {});\n\nconst cmdShim = (from, to) => stat(from).then(() => cmdShim_(from, to));\n\nconst cmdShim_ = (from, to) => Promise.all([rm(to), rm(to + '.cmd'), rm(to + '.ps1')]).then(() => writeShim(from, to));\n\nconst writeShim = (from, to) => // make a cmd file and a sh script\n// First, check if the bin is a #! of some sort.\n// If not, then assume it's something that'll be compiled, or some other\n// sort of script, and just call it directly.\nmkdir(dirname(to)).then(() => readFile(from, 'utf8')).then(data => {\n  const firstLine = data.trim().split(/\\r*\\n/)[0];\n  const shebang = firstLine.match(shebangExpr);\n  if (!shebang) return writeShim_(from, to);\n  const vars = shebang[1] || '';\n  const prog = shebang[2];\n  const args = shebang[3] || '';\n  return writeShim_(from, to, prog, args, vars);\n}, er => writeShim_(from, to));\n\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from);\n  let target = shTarget.split('/').join('\\\\');\n  let longProg;\n  let shProg = prog && prog.split('\\\\').join('/');\n  let shLongProg;\n  let pwshProg = shProg && `\"${shProg}$exe\"`;\n  let pwshLongProg;\n  shTarget = shTarget.split('\\\\').join('/');\n  args = args || '';\n  variables = variables || '';\n\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`;\n    shProg = `\"$basedir/${shTarget}\"`;\n    pwshProg = shProg;\n    args = '';\n    target = '';\n    shTarget = '';\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`;\n    shLongProg = `\"$basedir/${prog}\"`;\n    pwshLongProg = `\"$basedir/${prog}$exe\"`;\n    target = `\"%dp0%\\\\${target}\"`;\n    shTarget = `\"$basedir/${shTarget}\"`;\n  } // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n\n\n  const head = '@ECHO off\\r\\n' + 'GOTO start\\r\\n' + ':find_dp0\\r\\n' + 'SET dp0=%~dp0\\r\\n' + 'EXIT /b\\r\\n' + ':start\\r\\n' + 'SETLOCAL\\r\\n' + 'CALL :find_dp0\\r\\n';\n  let cmd;\n\n  if (longProg) {\n    shLongProg = shLongProg.trim();\n    args = args.trim();\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables);\n    cmd = head + variablesBatch + '\\r\\n' + `IF EXIST ${longProg} (\\r\\n` + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n` + ') ELSE (\\r\\n' + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n` + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n' + ')\\r\\n' + '\\r\\n' // prevent \"Terminate Batch Job? (Y/n)\" message\n    // https://github.com/npm/cli/issues/969#issuecomment-737496588\n    + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & ' + `\"%_prog%\" ${args} ${target} %*\\r\\n`;\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`;\n  } // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n\n  let sh = \"#!/bin/sh\\n\";\n  sh = sh + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n` + '\\n' + 'case `uname` in\\n' + '    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\\n' + 'esac\\n' + '\\n';\n\n  if (shLongProg) {\n    sh = sh + `if [ -x ${shLongProg} ]; then\\n` + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n` + 'else \\n' + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n` + 'fi\\n';\n  } else {\n    sh = sh + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`;\n  } // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n\n\n  let pwsh = '#!/usr/bin/env pwsh\\n' + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n' + '\\n' + '$exe=\"\"\\n' + 'if ($PSVersionTable.PSVersion -lt \\\"6.0\\\" -or $IsWindows) {\\n' + '  # Fix case when both the Windows and Linux builds of Node\\n' + '  # are installed in the same directory\\n' + '  $exe=\".exe\"\\n' + '}\\n';\n\n  if (shLongProg) {\n    pwsh = pwsh + '$ret=0\\n' + `if (Test-Path ${pwshLongProg}) {\\n` + '  # Support pipeline input\\n' + '  if ($MyInvocation.ExpectingInput) {\\n' + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n` + '  } else {\\n' + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n` + '  }\\n' + '  $ret=$LASTEXITCODE\\n' + '} else {\\n' + '  # Support pipeline input\\n' + '  if ($MyInvocation.ExpectingInput) {\\n' + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n` + '  } else {\\n' + `    & ${pwshProg} ${args} ${shTarget} $args\\n` + '  }\\n' + '  $ret=$LASTEXITCODE\\n' + '}\\n' + 'exit $ret\\n';\n  } else {\n    pwsh = pwsh + '# Support pipeline input\\n' + 'if ($MyInvocation.ExpectingInput) {\\n' + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n` + '} else {\\n' + `  & ${pwshProg} ${args} ${shTarget} $args\\n` + '}\\n' + 'exit $LASTEXITCODE\\n';\n  }\n\n  return Promise.all([writeFile(to + '.ps1', pwsh, 'utf8'), writeFile(to + '.cmd', cmd, 'utf8'), writeFile(to, sh, 'utf8')]).then(() => chmodShim(to));\n};\n\nconst chmodShim = to => Promise.all([chmod(to, 0o755), chmod(to + '.cmd', 0o755), chmod(to + '.ps1', 0o755)]);\n\nmodule.exports = cmdShim;\ncmdShim.ifExists = cmdShimIfExists;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/cmd-shim/index.js"],"names":["promisify","require","fs","writeFile","readFile","chmod","stat","unlink","dirname","relative","mkdir","toBatchSyntax","shebangExpr","cmdShimIfExists","from","to","then","cmdShim","rm","path","catch","cmdShim_","Promise","all","writeShim","data","firstLine","trim","split","shebang","match","writeShim_","vars","prog","args","er","variables","shTarget","target","join","longProg","shProg","shLongProg","pwshProg","pwshLongProg","head","cmd","variablesBatch","convertToSetCommands","replace","sh","pwsh","chmodShim","module","exports","ifExists"],"mappings":"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","sourcesContent":["// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\n\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst writeFile = promisify(fs.writeFile)\nconst readFile = promisify(fs.readFile)\nconst chmod = promisify(fs.chmod)\nconst stat = promisify(fs.stat)\nconst unlink = promisify(fs.unlink)\n\nconst {dirname, relative} = require('path')\nconst mkdir = require('mkdirp-infer-owner')\nconst toBatchSyntax = require('./lib/to-batch-syntax')\nconst shebangExpr = /^#\\!\\s*(?:\\/usr\\/bin\\/env)?\\s*([^ \\t]+=[^ \\t]+\\s+)*\\s*([^ \\t]+)(.*)$/\n\nconst cmdShimIfExists = (from, to) =>\n  stat(from).then(() => cmdShim(from, to), () => {})\n\n// Try to unlink, but ignore errors.\n// Any problems will surface later.\nconst rm = path => unlink(path).catch(() => {})\n\nconst cmdShim = (from, to) =>\n  stat(from).then(() => cmdShim_(from, to))\n\nconst cmdShim_ = (from, to) => Promise.all([\n  rm(to),\n  rm(to + '.cmd'),\n  rm(to + '.ps1'),\n]).then(() => writeShim(from, to))\n\nconst writeShim = (from, to) =>\n  // make a cmd file and a sh script\n  // First, check if the bin is a #! of some sort.\n  // If not, then assume it's something that'll be compiled, or some other\n  // sort of script, and just call it directly.\n  mkdir(dirname(to))\n    .then(() => readFile(from, 'utf8'))\n    .then(data => {\n      const firstLine = data.trim().split(/\\r*\\n/)[0]\n      const shebang = firstLine.match(shebangExpr)\n      if (!shebang) return writeShim_(from, to)\n      const vars = shebang[1] || ''\n      const prog = shebang[2]\n      const args = shebang[3] || ''\n      return writeShim_(from, to, prog, args, vars)\n    }, er => writeShim_(from, to))\n\n\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from)\n  let target = shTarget.split('/').join('\\\\')\n  let longProg\n  let shProg = prog && prog.split('\\\\').join('/')\n  let shLongProg\n  let pwshProg = shProg && `\"${shProg}$exe\"`\n  let pwshLongProg\n  shTarget = shTarget.split('\\\\').join('/')\n  args = args || ''\n  variables = variables || ''\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`\n    shProg = `\"$basedir/${shTarget}\"`\n    pwshProg = shProg\n    args = ''\n    target = ''\n    shTarget = ''\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`\n    shLongProg = `\"$basedir/${prog}\"`\n    pwshLongProg = `\"$basedir/${prog}$exe\"`\n    target = `\"%dp0%\\\\${target}\"`\n    shTarget = `\"$basedir/${shTarget}\"`\n  }\n\n  // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n  const head = '@ECHO off\\r\\n' +\n    'GOTO start\\r\\n' +\n    ':find_dp0\\r\\n' +\n    'SET dp0=%~dp0\\r\\n' +\n    'EXIT /b\\r\\n' +\n    ':start\\r\\n' +\n    'SETLOCAL\\r\\n' +\n    'CALL :find_dp0\\r\\n'\n\n  let cmd\n  if (longProg) {\n    shLongProg = shLongProg.trim();\n    args = args.trim();\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables)\n    cmd = head\n        + variablesBatch\n        + '\\r\\n'\n        + `IF EXIST ${longProg} (\\r\\n`\n        + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + ') ELSE (\\r\\n'\n        + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n'\n        + ')\\r\\n'\n        + '\\r\\n'\n        // prevent \"Terminate Batch Job? (Y/n)\" message\n        // https://github.com/npm/cli/issues/969#issuecomment-737496588\n        + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & '\n        +  `\"%_prog%\" ${args} ${target} %*\\r\\n`\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`\n  }\n\n  // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n  let sh = \"#!/bin/sh\\n\"\n\n  sh = sh\n      + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n`\n      + '\\n'\n      + 'case `uname` in\\n'\n      + '    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\\n'\n      + 'esac\\n'\n      + '\\n'\n\n  if (shLongProg) {\n    sh = sh\n       + `if [ -x ${shLongProg} ]; then\\n`\n       + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'else \\n'\n       + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'fi\\n'\n  } else {\n    sh = sh\n       + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`\n  }\n\n  // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n  let pwsh = '#!/usr/bin/env pwsh\\n'\n           + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n'\n           + '\\n'\n           + '$exe=\"\"\\n'\n           + 'if ($PSVersionTable.PSVersion -lt \\\"6.0\\\" -or $IsWindows) {\\n'\n           + '  # Fix case when both the Windows and Linux builds of Node\\n'\n           + '  # are installed in the same directory\\n'\n           + '  $exe=\".exe\"\\n'\n           + '}\\n'\n  if (shLongProg) {\n    pwsh = pwsh\n         + '$ret=0\\n'\n         + `if (Test-Path ${pwshLongProg}) {\\n`\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '} else {\\n'\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '}\\n'\n         + 'exit $ret\\n'\n  } else {\n    pwsh = pwsh\n         + '# Support pipeline input\\n'\n         + 'if ($MyInvocation.ExpectingInput) {\\n'\n         + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '} else {\\n'\n         + `  & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '}\\n'\n         + 'exit $LASTEXITCODE\\n'\n  }\n\n  return Promise.all([\n    writeFile(to + '.ps1', pwsh, 'utf8'),\n    writeFile(to + '.cmd', cmd, 'utf8'),\n    writeFile(to, sh, 'utf8'),\n  ]).then(() => chmodShim(to))\n}\n\nconst chmodShim = to => Promise.all([\n  chmod(to, 0o755),\n  chmod(to + '.cmd', 0o755),\n  chmod(to + '.ps1', 0o755),\n])\n\nmodule.exports = cmdShim\ncmdShim.ifExists = cmdShimIfExists\n"]},"metadata":{},"sourceType":"script"}