{"ast":null,"code":"const debug = require('./debug.js');\n\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]]; // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n\n  if (!tree.root || !tree.root.inventory) {\n    return tree;\n  }\n\n  const {\n    inventory\n  } = tree.root;\n  const seen = new Set();\n\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push(['CHECK', node && node.location, via && via.location, viaType, 'seen=' + seen.has(node), 'promise=' + !!(node && node.then), 'root=' + !!(node && node.isRoot)]);\n\n    if (!node || seen.has(node) || node.then) {\n      return;\n    }\n\n    seen.add(node);\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log\n      });\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node => [node.path, node.location]),\n        log\n      });\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev);\n\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log\n      });\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log\n      });\n    }\n\n    const {\n      parent,\n      fsParent,\n      target\n    } = node;\n    check(parent, node, 'parent');\n    check(fsParent, node, 'fsParent');\n    check(target, node, 'target');\n    log.push(['CHILDREN', node.location, ...node.children.keys()]);\n\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children');\n    }\n\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren');\n    }\n\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn');\n    }\n\n    for (const top of node.tops) {\n      check(top, node, 'tops');\n    }\n\n    log.push(['DONE', node.location]);\n  };\n\n  check(tree);\n\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log\n        });\n      }\n    }\n  }\n\n  return tree;\n}; // should only ever run this check in debug mode\n\n\nmodule.exports = tree => tree;\n\ndebug(() => module.exports = checkTree);","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/tree-check.js"],"names":["debug","require","checkTree","tree","checkUnreachable","log","path","root","inventory","seen","Set","check","node","via","viaType","push","location","has","then","isRoot","add","Object","assign","Error","realpath","otherRoot","size","values","map","dummy","devEdges","edgesOut","filter","e","dev","isTop","length","type","name","spec","error","isLink","parent","fsParent","target","children","keys","kid","fsChildren","link","linksIn","top","tops","module","exports"],"mappings":"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","sourcesContent":["const debug = require('./debug.js')\n\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]]\n\n  // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n  if (!tree.root || !tree.root.inventory) {\n    return tree\n  }\n\n  const { inventory } = tree.root\n  const seen = new Set()\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push([\n      'CHECK',\n      node && node.location,\n      via && via.location,\n      viaType,\n      'seen=' + seen.has(node),\n      'promise=' + !!(node && node.then),\n      'root=' + !!(node && node.isRoot),\n    ])\n\n    if (!node || seen.has(node) || node.then) {\n      return\n    }\n\n    seen.add(node)\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log,\n      })\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node =>\n          [node.path, node.location]),\n        log,\n      })\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev)\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log,\n      })\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const { parent, fsParent, target } = node\n    check(parent, node, 'parent')\n    check(fsParent, node, 'fsParent')\n    check(target, node, 'target')\n    log.push(['CHILDREN', node.location, ...node.children.keys()])\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children')\n    }\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren')\n    }\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn')\n    }\n    for (const top of node.tops) {\n      check(top, node, 'tops')\n    }\n    log.push(['DONE', node.location])\n  }\n  check(tree)\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log,\n        })\n      }\n    }\n  }\n  return tree\n}\n\n// should only ever run this check in debug mode\nmodule.exports = tree => tree\ndebug(() => module.exports = checkTree)\n"]},"metadata":{},"sourceType":"script"}