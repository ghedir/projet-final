{"ast":null,"code":"const {\n  resolve\n} = require('path');\n\nconst semver = require('semver');\n\nconst libnpmdiff = require('libnpmdiff');\n\nconst npa = require('npm-package-arg');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst npmlog = require('npmlog');\n\nconst pacote = require('pacote');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst readPackageName = require('./utils/read-package-name.js');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Diff extends BaseCommand {\n  static get description() {\n    return 'The registry diff command';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'diff';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[...<paths>]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['diff', 'diff-name-only', 'diff-unified', 'diff-ignore-all-space', 'diff-no-prefix', 'diff-src-prefix', 'diff-dst-prefix', 'diff-text', 'global', 'tag', 'workspace', 'workspaces'];\n  }\n\n  exec(args, cb) {\n    this.diff(args).then(() => cb()).catch(cb);\n  }\n\n  execWorkspaces(args, filters, cb) {\n    this.diffWorkspaces(args, filters).then(() => cb()).catch(cb);\n  }\n\n  async diff(args) {\n    const specs = this.npm.config.get('diff').filter(d => d);\n\n    if (specs.length > 2) {\n      throw new TypeError('Can\\'t use more than two --diff arguments.\\n\\n' + `Usage:\\n${this.usage}`);\n    } // diffWorkspaces may have set this already\n\n\n    if (!this.prefix) this.prefix = this.npm.prefix; // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n\n    if (this.npm.config.get('global')) this.top = resolve(this.npm.globalDir, '..');else this.top = this.prefix;\n    const [a, b] = await this.retrieveSpecs(specs);\n    npmlog.info('diff', {\n      src: a,\n      dst: b\n    });\n    const res = await libnpmdiff([a, b], { ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top\n    });\n    return this.npm.output(res);\n  }\n\n  async diffWorkspaces(args, filters) {\n    await this.setWorkspaces(filters);\n\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath;\n      this.prefix = workspacePath;\n      await this.diff(args);\n    }\n  } // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n\n\n  async packageName(path) {\n    let name;\n\n    try {\n      name = await readPackageName(this.prefix);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n    }\n\n    if (!name) throw this.usageError('Needs multiple arguments to compare or run from a project dir.\\n');\n    return name;\n  }\n\n  async retrieveSpecs([a, b]) {\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b]);\n      return this.findVersionsByPackageName(specs);\n    } // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n\n\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix);\n      return [`${pkgName}@${this.npm.config.get('tag')}`, `file:${this.prefix}`];\n    } // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n\n\n    let noPackageJson;\n    let pkgName;\n\n    try {\n      pkgName = await readPackageName(this.prefix);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n      noPackageJson = true;\n    }\n\n    const missingPackageJson = this.usageError('Needs multiple arguments to compare or run from a project dir.\\n'); // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n\n    if (semver.validRange(a)) {\n      if (!pkgName) throw missingPackageJson;\n      return [`${pkgName}@${a}`, `file:${this.prefix}`];\n    } // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n\n\n    const spec = npa(a);\n\n    if (spec.registry) {\n      let actualTree;\n      let node;\n\n      try {\n        const opts = { ...this.npm.flatOptions,\n          path: this.top\n        };\n        const arb = new Arborist(opts);\n        actualTree = await arb.loadActual(opts);\n        node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree');\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson) throw missingPackageJson;\n        return [`${spec.name}@${spec.fetchSpec}`, `file:${this.prefix}`];\n      }\n\n      const tryRootNodeSpec = () => (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec;\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn) return edge.spec;\n      };\n\n      const aSpec = `file:${node.realpath}`; // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n\n      let bSpec;\n      if (spec.rawSpec) bSpec = spec.rawSpec;else {\n        const bTargetVersion = tryRootNodeSpec() || tryAnySpec(); // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n\n        const packument = await pacote.packument(spec, { ...this.npm.flatOptions,\n          preferOnline: true\n        });\n        bSpec = pickManifest(packument, bTargetVersion, { ...this.npm.flatOptions\n        }).version;\n      }\n      return [`${spec.name}@${aSpec}`, `${spec.name}@${bSpec}`];\n    } else if (spec.type === 'directory') {\n      return [`file:${spec.fetchSpec}`, `file:${this.prefix}`];\n    } else throw this.usageError(`Spec type ${spec.type} not supported.\\n`);\n  }\n\n  async convertVersionsToSpecs([a, b]) {\n    const semverA = semver.validRange(a);\n    const semverB = semver.validRange(b); // both specs are semver versions, assume current project dir name\n\n    if (semverA && semverB) {\n      let pkgName;\n\n      try {\n        pkgName = await readPackageName(this.prefix);\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json');\n      }\n\n      if (!pkgName) throw this.usageError('Needs to be run from a project dir in order to diff two versions.\\n');\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`];\n    } // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n\n\n    if (!semverA && semverB) return [a, `${npa(a).name}@${b}`];\n    if (semverA && !semverB) return [`${npa(b).name}@${a}`, b]; // no valid semver ranges used\n\n    return [a, b];\n  }\n\n  async findVersionsByPackageName(specs) {\n    let actualTree;\n\n    try {\n      const opts = { ...this.npm.flatOptions,\n        path: this.top\n      };\n      const arb = new Arborist(opts);\n      actualTree = await arb.loadActual(opts);\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree');\n    }\n\n    return specs.map(i => {\n      const spec = npa(i);\n      if (spec.rawSpec) return i;\n      const node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      const res = !node || !node.package || !node.package.version ? spec.fetchSpec : `file:${node.realpath}`;\n      return `${spec.name}@${res}`;\n    });\n  }\n\n}\n\nmodule.exports = Diff;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/diff.js"],"names":["resolve","require","semver","libnpmdiff","npa","Arborist","npmlog","pacote","pickManifest","readPackageName","BaseCommand","Diff","description","name","usage","params","exec","args","cb","diff","then","catch","execWorkspaces","filters","diffWorkspaces","specs","npm","config","get","filter","d","length","TypeError","prefix","top","globalDir","a","b","retrieveSpecs","info","src","dst","res","flatOptions","diffFiles","where","output","setWorkspaces","workspacePath","workspacePaths","packageName","path","e","verbose","usageError","convertVersionsToSpecs","findVersionsByPackageName","pkgName","noPackageJson","missingPackageJson","validRange","spec","registry","actualTree","node","opts","arb","loadActual","inventory","query","values","next","value","package","version","fetchSpec","tryRootNodeSpec","edgesOut","tryAnySpec","edge","edgesIn","aSpec","realpath","bSpec","rawSpec","bTargetVersion","packument","preferOnline","type","semverA","semverB","map","i","module","exports"],"mappings":"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","sourcesContent":["const { resolve } = require('path')\n\nconst semver = require('semver')\nconst libnpmdiff = require('libnpmdiff')\nconst npa = require('npm-package-arg')\nconst Arborist = require('@npmcli/arborist')\nconst npmlog = require('npmlog')\nconst pacote = require('pacote')\nconst pickManifest = require('npm-pick-manifest')\n\nconst readPackageName = require('./utils/read-package-name.js')\nconst BaseCommand = require('./base-command.js')\n\nclass Diff extends BaseCommand {\n  static get description () {\n    return 'The registry diff command'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'diff'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[...<paths>]',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'diff',\n      'diff-name-only',\n      'diff-unified',\n      'diff-ignore-all-space',\n      'diff-no-prefix',\n      'diff-src-prefix',\n      'diff-dst-prefix',\n      'diff-text',\n      'global',\n      'tag',\n      'workspace',\n      'workspaces',\n    ]\n  }\n\n  exec (args, cb) {\n    this.diff(args).then(() => cb()).catch(cb)\n  }\n\n  execWorkspaces (args, filters, cb) {\n    this.diffWorkspaces(args, filters).then(() => cb()).catch(cb)\n  }\n\n  async diff (args) {\n    const specs = this.npm.config.get('diff').filter(d => d)\n    if (specs.length > 2) {\n      throw new TypeError(\n        'Can\\'t use more than two --diff arguments.\\n\\n' +\n        `Usage:\\n${this.usage}`\n      )\n    }\n\n    // diffWorkspaces may have set this already\n    if (!this.prefix)\n      this.prefix = this.npm.prefix\n\n    // this is the \"top\" directory, one up from node_modules\n    // in global mode we have to walk one up from globalDir because our\n    // node_modules is sometimes under ./lib, and in global mode we're only ever\n    // walking through node_modules (because we will have been given a package\n    // name already)\n    if (this.npm.config.get('global'))\n      this.top = resolve(this.npm.globalDir, '..')\n    else\n      this.top = this.prefix\n\n    const [a, b] = await this.retrieveSpecs(specs)\n    npmlog.info('diff', { src: a, dst: b })\n\n    const res = await libnpmdiff([a, b], {\n      ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.top,\n    })\n    return this.npm.output(res)\n  }\n\n  async diffWorkspaces (args, filters) {\n    await this.setWorkspaces(filters)\n    for (const workspacePath of this.workspacePaths) {\n      this.top = workspacePath\n      this.prefix = workspacePath\n      await this.diff(args)\n    }\n  }\n\n  // get the package name from the packument at `path`\n  // throws if no packument is present OR if it does not have `name` attribute\n  async packageName (path) {\n    let name\n    try {\n      name = await readPackageName(this.prefix)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n    }\n\n    if (!name)\n      throw this.usageError('Needs multiple arguments to compare or run from a project dir.\\n')\n\n    return name\n  }\n\n  async retrieveSpecs ([a, b]) {\n    if (a && b) {\n      const specs = await this.convertVersionsToSpecs([a, b])\n      return this.findVersionsByPackageName(specs)\n    }\n\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a) {\n      const pkgName = await this.packageName(this.prefix)\n      return [\n        `${pkgName}@${this.npm.config.get('tag')}`,\n        `file:${this.prefix}`,\n      ]\n    }\n\n    // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n    let noPackageJson\n    let pkgName\n    try {\n      pkgName = await readPackageName(this.prefix)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n      noPackageJson = true\n    }\n\n    const missingPackageJson = this.usageError('Needs multiple arguments to compare or run from a project dir.\\n')\n\n    // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n    if (semver.validRange(a)) {\n      if (!pkgName)\n        throw missingPackageJson\n      return [\n        `${pkgName}@${a}`,\n        `file:${this.prefix}`,\n      ]\n    }\n\n    // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n    const spec = npa(a)\n    if (spec.registry) {\n      let actualTree\n      let node\n      try {\n        const opts = {\n          ...this.npm.flatOptions,\n          path: this.top,\n        }\n        const arb = new Arborist(opts)\n        actualTree = await arb.loadActual(opts)\n        node = actualTree &&\n          actualTree.inventory.query('name', spec.name)\n            .values().next().value\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree')\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        if (noPackageJson)\n          throw missingPackageJson\n        return [\n          `${spec.name}@${spec.fetchSpec}`,\n          `file:${this.prefix}`,\n        ]\n      }\n\n      const tryRootNodeSpec = () =>\n        (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn)\n          return edge.spec\n      }\n\n      const aSpec = `file:${node.realpath}`\n\n      // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n      let bSpec\n      if (spec.rawSpec)\n        bSpec = spec.rawSpec\n      else {\n        const bTargetVersion =\n          tryRootNodeSpec()\n          || tryAnySpec()\n\n        // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n        const packument = await pacote.packument(spec, {\n          ...this.npm.flatOptions,\n          preferOnline: true,\n        })\n        bSpec = pickManifest(\n          packument,\n          bTargetVersion,\n          { ...this.npm.flatOptions }\n        ).version\n      }\n\n      return [\n        `${spec.name}@${aSpec}`,\n        `${spec.name}@${bSpec}`,\n      ]\n    } else if (spec.type === 'directory') {\n      return [\n        `file:${spec.fetchSpec}`,\n        `file:${this.prefix}`,\n      ]\n    } else\n      throw this.usageError(`Spec type ${spec.type} not supported.\\n`)\n  }\n\n  async convertVersionsToSpecs ([a, b]) {\n    const semverA = semver.validRange(a)\n    const semverB = semver.validRange(b)\n\n    // both specs are semver versions, assume current project dir name\n    if (semverA && semverB) {\n      let pkgName\n      try {\n        pkgName = await readPackageName(this.prefix)\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json')\n      }\n\n      if (!pkgName)\n        throw this.usageError('Needs to be run from a project dir in order to diff two versions.\\n')\n\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`]\n    }\n\n    // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n    if (!semverA && semverB)\n      return [a, `${npa(a).name}@${b}`]\n\n    if (semverA && !semverB)\n      return [`${npa(b).name}@${a}`, b]\n\n    // no valid semver ranges used\n    return [a, b]\n  }\n\n  async findVersionsByPackageName (specs) {\n    let actualTree\n    try {\n      const opts = {\n        ...this.npm.flatOptions,\n        path: this.top,\n      }\n      const arb = new Arborist(opts)\n      actualTree = await arb.loadActual(opts)\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree')\n    }\n\n    return specs.map(i => {\n      const spec = npa(i)\n      if (spec.rawSpec)\n        return i\n\n      const node = actualTree\n        && actualTree.inventory.query('name', spec.name)\n          .values().next().value\n\n      const res = !node || !node.package || !node.package.version\n        ? spec.fetchSpec\n        : `file:${node.realpath}`\n\n      return `${spec.name}@${res}`\n    })\n  }\n}\n\nmodule.exports = Diff\n"]},"metadata":{},"sourceType":"script"}