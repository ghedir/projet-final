{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst MiniPass = require('minipass');\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']; // TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n};\n\nconst ssriOpts = (opts = {}) => ({ ...defaultOpts,\n  ...opts\n});\n\nconst getOptString = options => !options || !options.length ? '' : `?${options.join('?')}`;\n\nconst _onEnd = Symbol('_onEnd');\n\nconst _getOptions = Symbol('_getOptions');\n\nclass IntegrityStream extends MiniPass {\n  constructor(opts) {\n    super();\n    this.size = 0;\n    this.opts = opts; // may be overridden later, but set now for class consistency\n\n    this[_getOptions](); // options used for calculating stream.  can't be changed.\n\n\n    const {\n      algorithms = defaultOpts.algorithms\n    } = opts;\n    this.algorithms = Array.from(new Set(algorithms.concat(this.algorithm ? [this.algorithm] : [])));\n    this.hashes = this.algorithms.map(crypto.createHash);\n  }\n\n  [_getOptions]() {\n    const {\n      integrity,\n      size,\n      options\n    } = { ...defaultOpts,\n      ...this.opts\n    }; // For verification\n\n    this.sri = integrity ? parse(integrity, this.opts) : null;\n    this.expectedSize = size;\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false;\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null;\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null;\n    this.optString = getOptString(options);\n  }\n\n  emit(ev, data) {\n    if (ev === 'end') this[_onEnd]();\n    return super.emit(ev, data);\n  }\n\n  write(data) {\n    this.size += data.length;\n    this.hashes.forEach(h => h.update(data));\n    return super.write(data);\n  }\n\n  [_onEnd]() {\n    if (!this.goodSri) {\n      this[_getOptions]();\n    }\n\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`;\n    }).join(' '), this.opts); // Integrity verification mode\n\n    const match = this.goodSri && newSri.match(this.sri, this.opts);\n\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`);\n      err.code = 'EBADSIZE';\n      err.found = this.size;\n      err.expected = this.expectedSize;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = this.digests;\n      err.algorithm = this.algorithm;\n      err.sri = this.sri;\n      this.emit('error', err);\n    } else {\n      this.emit('size', this.size);\n      this.emit('integrity', newSri);\n      match && this.emit('verified', match);\n    }\n  }\n\n}\n\nclass Hash {\n  get isHash() {\n    return true;\n  }\n\n  constructor(hash, opts) {\n    opts = ssriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim(); // set default values so that we make V8 happy to\n    // always see a familiar object template.\n\n    this.digest = '';\n    this.algorithm = '';\n    this.options = []; // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?');\n    }\n  }\n\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = ssriOpts(opts);\n\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!( // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      this.options.every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n\n}\n\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  isEmpty() {\n    return Object.keys(this).length === 0;\n  }\n\n  toString(opts) {\n    opts = ssriOpts(opts);\n    let sep = opts.sep || ' ';\n\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n\n  concat(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  } // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n\n\n  merge(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = parse(integrity, opts);\n\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity');\n        }\n      } else {\n        this[algo] = other[algo];\n      }\n    }\n  }\n\n  match(integrity, opts) {\n    opts = ssriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  pickAlgorithm(opts) {\n    opts = ssriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n\n}\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  if (!sri) return null;\n  opts = ssriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n  return hashes.isEmpty() ? null : hashes;\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = ssriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts);\n  const optString = getOptString(opts.options);\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = ssriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = ssriOpts(opts);\n  const istream = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = ssriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = ssriOpts(opts);\n  opts.integrity = sri;\n  sri = parse(sri, opts);\n\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(new Error('No valid integrity hashes to check against'), {\n      code: 'EINTEGRITY'\n    }));\n  }\n\n  const checker = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts = {}) {\n  return new IntegrityStream(opts);\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = ssriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = getOptString(opts.options);\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n\n          acc[algo].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/ssri/index.js"],"names":["crypto","require","MiniPass","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","defaultOpts","algorithms","error","options","pickAlgorithm","getPrioritizedHash","sep","single","strict","ssriOpts","opts","getOptString","length","join","_onEnd","Symbol","_getOptions","IntegrityStream","constructor","size","Array","from","Set","concat","algorithm","hashes","map","createHash","integrity","sri","parse","expectedSize","goodSri","Object","keys","digests","optString","emit","ev","data","write","forEach","h","update","newSri","i","digest","match","err","Error","code","found","expected","Hash","isHash","hash","source","trim","some","a","rawOpts","slice","split","hexDigest","Buffer","toString","toJSON","x","every","opt","Integrity","isIntegrity","isEmpty","replace","k","prototype","call","filter","other","stringify","merge","algo","find","otherhash","reduce","acc","module","exports","_parse","fullSri","string","push","obj","fromHex","fromData","fromStream","stream","istream","integrityStream","Promise","resolve","reject","pipe","on","s","checkData","assign","checkStream","checker","create","createIntegrity","chunk","enc","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst MiniPass = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n}\n\nconst ssriOpts = (opts = {}) => ({ ...defaultOpts, ...opts })\n\nconst getOptString = options => !options || !options.length\n  ? ''\n  : `?${options.join('?')}`\n\nconst _onEnd = Symbol('_onEnd')\nconst _getOptions = Symbol('_getOptions')\nclass IntegrityStream extends MiniPass {\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this[_getOptions]()\n\n    // options used for calculating stream.  can't be changed.\n    const { algorithms = defaultOpts.algorithms } = opts\n    this.algorithms = Array.from(\n      new Set(algorithms.concat(this.algorithm ? [this.algorithm] : []))\n    )\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  [_getOptions] () {\n    const {\n      integrity,\n      size,\n      options\n    } = { ...defaultOpts, ...this.opts }\n\n    // For verification\n    this.sri = integrity ? parse(integrity, this.opts) : null\n    this.expectedSize = size\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(options)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') this[_onEnd]()\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  [_onEnd] () {\n    if (!this.goodSri) {\n      this[_getOptions]()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.emit('size', this.size)\n      this.emit('integrity', newSri)\n      match && this.emit('verified', match)\n    }\n  }\n}\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = ssriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n      ? `?${this.options.join('?')}`\n      : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n\n  isEmpty () {\n    return Object.keys(this).length === 0\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n\n  concat (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  pickAlgorithm (opts) {\n    opts = ssriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  if (!sri) return null\n  opts = ssriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n  return hashes.isEmpty() ? null : hashes\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = ssriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts)\n  const optString = getOptString(opts.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = ssriOpts(opts)\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = ssriOpts(opts)\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = ssriOpts(opts)\n  opts.integrity = sri\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(\n      new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      }\n    ))\n  }\n  const checker = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts = {}) {\n  return new IntegrityStream(opts)\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n"]},"metadata":{},"sourceType":"script"}