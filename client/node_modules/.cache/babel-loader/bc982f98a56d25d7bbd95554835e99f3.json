{"ast":null,"code":"// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  existsSync\n} = require('fs');\n\nconst ssri = require('ssri');\n\nclass Diff {\n  constructor({\n    actual,\n    ideal,\n    filterSet,\n    shrinkwrapInflated\n  }) {\n    this.filterSet = filterSet;\n    this.shrinkwrapInflated = shrinkwrapInflated;\n    this.children = [];\n    this.actual = actual;\n    this.ideal = ideal;\n\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved;\n      this.integrity = this.ideal.integrity;\n    }\n\n    this.action = getAction(this);\n    this.parent = null; // the set of leaf nodes that we rake up to the top level\n\n    this.leaves = []; // the set of nodes that don't change in this branch of the tree\n\n    this.unchanged = []; // the set of nodes that will be removed in this branch of the tree\n\n    this.removed = [];\n  }\n\n  static calculate({\n    actual,\n    ideal,\n    filterNodes = [],\n    shrinkwrapInflated = new Set()\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set();\n    const extraneous = new Set();\n\n    for (const filterNode of filterNodes) {\n      const {\n        root\n      } = filterNode;\n\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree');\n      }\n\n      const rootTarget = root.target;\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode);\n      })[0];\n      filterSet.add(root);\n      filterSet.add(rootTarget);\n      filterSet.add(ideal);\n      filterSet.add(actual);\n\n      if (edge && edge.to) {\n        filterSet.add(edge.to);\n        filterSet.add(edge.to.target);\n      }\n\n      filterSet.add(filterNode);\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target;\n          const loc = node.location;\n          const idealNode = ideal.inventory.get(loc);\n          const ideals = !idealNode ? [] : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          const actualNode = actual.inventory.get(loc);\n          const actuals = !actualNode ? [] : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child);\n              }\n            }\n          }\n\n          return ideals.concat(actuals);\n        }\n      });\n    }\n\n    for (const extra of extraneous) {\n      filterSet.add(extra);\n    }\n\n    return depth({\n      tree: new Diff({\n        actual,\n        ideal,\n        filterSet,\n        shrinkwrapInflated\n      }),\n      getChildren,\n      leave\n    });\n  }\n\n}\n\nconst getAction = ({\n  actual,\n  ideal\n}) => {\n  if (!ideal) {\n    return 'REMOVE';\n  } // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n\n\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD';\n  } // always ignore the root node\n\n\n  if (ideal.isRoot && actual.isRoot) {\n    return null;\n  } // if the versions don't match, it's a change no matter what\n\n\n  if (ideal.version !== actual.version) {\n    return 'CHANGE';\n  }\n\n  const binsExist = ideal.binPaths.every(path => existsSync(path)); // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n\n  const noIntegrity = !ideal.integrity && !actual.integrity;\n  const noResolved = !ideal.resolved && !actual.resolved;\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved;\n\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null;\n  } // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n\n\n  const integrityMismatch = !ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity);\n\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE';\n  }\n\n  return null;\n};\n\nconst allChildren = node => {\n  if (!node) {\n    return new Map();\n  } // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n\n\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target);\n  }\n\n  const kids = new Map();\n\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid);\n    }\n  }\n\n  return kids;\n}; // functions for the walk options when we traverse the trees\n// to create the diff tree\n\n\nconst getChildren = diff => {\n  const children = [];\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated\n  } = diff; // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n\n  const actualKids = allChildren(actual);\n  const idealKids = allChildren(ideal);\n\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff);\n    return children;\n  }\n\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()]);\n\n  for (const path of paths) {\n    const actual = actualKids.get(path);\n    const ideal = idealKids.get(path);\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    });\n  }\n\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff);\n  }\n\n  return children;\n};\n\nconst diffNode = ({\n  actual,\n  ideal,\n  children,\n  unchanged,\n  removed,\n  filterSet,\n  shrinkwrapInflated\n}) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return;\n  }\n\n  const action = getAction({\n    actual,\n    ideal\n  }); // if it's a match, then get its children\n  // otherwise, this is the child diff node\n\n  if (action || !shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap) {\n    if (action === 'REMOVE') {\n      removed.push(actual);\n    }\n\n    children.push(new Diff({\n      actual,\n      ideal,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  } else {\n    unchanged.push(ideal); // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n\n    const bd = ideal.package.bundleDependencies;\n\n    if (actual && bd && bd.length) {\n      const bundledChildren = [];\n\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node);\n        }\n      }\n\n      for (const node of bundledChildren) {\n        node.parent = ideal;\n      }\n    }\n\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated\n    }));\n  }\n}; // set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\n\n\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff;\n    diff.leaves.push(...kid.leaves);\n    diff.unchanged.push(...kid.unchanged);\n    diff.removed.push(...kid.removed);\n  });\n  diff.children = children;\n  return diff;\n};\n\nmodule.exports = Diff;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/diff.js"],"names":["depth","require","existsSync","ssri","Diff","constructor","actual","ideal","filterSet","shrinkwrapInflated","children","resolved","integrity","action","getAction","parent","leaves","unchanged","removed","calculate","filterNodes","Set","extraneous","filterNode","root","Error","rootTarget","target","edge","edgesOut","values","filter","e","to","add","tree","visit","node","getChildren","loc","location","idealNode","inventory","get","ideals","map","actualNode","actuals","child","concat","extra","leave","inDepBundle","isRoot","version","binsExist","binPaths","every","path","noIntegrity","noResolved","resolvedMatch","integrityMismatch","parse","match","allChildren","Map","isLink","kids","n","fsChildren","kid","set","diff","actualKids","idealKids","hasShrinkwrap","has","push","paths","keys","diffNode","length","size","bd","package","bundleDependencies","bundledChildren","inBundle","forEach","module","exports"],"mappings":"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","sourcesContent":["// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\n\nconst {depth} = require('treeverse')\nconst {existsSync} = require('fs')\n\nconst ssri = require('ssri')\n\nclass Diff {\n  constructor ({actual, ideal, filterSet, shrinkwrapInflated}) {\n    this.filterSet = filterSet\n    this.shrinkwrapInflated = shrinkwrapInflated\n    this.children = []\n    this.actual = actual\n    this.ideal = ideal\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved\n      this.integrity = this.ideal.integrity\n    }\n    this.action = getAction(this)\n    this.parent = null\n    // the set of leaf nodes that we rake up to the top level\n    this.leaves = []\n    // the set of nodes that don't change in this branch of the tree\n    this.unchanged = []\n    // the set of nodes that will be removed in this branch of the tree\n    this.removed = []\n  }\n\n  static calculate ({\n    actual,\n    ideal,\n    filterNodes = [],\n    shrinkwrapInflated = new Set(),\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set()\n    const extraneous = new Set()\n    for (const filterNode of filterNodes) {\n      const { root } = filterNode\n      if (root !== ideal && root !== actual) {\n        throw new Error('invalid filterNode: outside idealTree/actualTree')\n      }\n      const rootTarget = root.target\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode)\n      })[0]\n      filterSet.add(root)\n      filterSet.add(rootTarget)\n      filterSet.add(ideal)\n      filterSet.add(actual)\n      if (edge && edge.to) {\n        filterSet.add(edge.to)\n        filterSet.add(edge.to.target)\n      }\n      filterSet.add(filterNode)\n\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target\n          const loc = node.location\n          const idealNode = ideal.inventory.get(loc)\n          const ideals = !idealNode ? []\n            : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          const actualNode = actual.inventory.get(loc)\n          const actuals = !actualNode ? []\n            : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          if (actualNode) {\n            for (const child of actualNode.children.values()) {\n              if (child.extraneous) {\n                extraneous.add(child)\n              }\n            }\n          }\n\n          return ideals.concat(actuals)\n        },\n      })\n    }\n    for (const extra of extraneous) {\n      filterSet.add(extra)\n    }\n\n    return depth({\n      tree: new Diff({actual, ideal, filterSet, shrinkwrapInflated}),\n      getChildren,\n      leave,\n    })\n  }\n}\n\nconst getAction = ({actual, ideal}) => {\n  if (!ideal) {\n    return 'REMOVE'\n  }\n\n  // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n  if (!actual) {\n    return ideal.inDepBundle ? null : 'ADD'\n  }\n\n  // always ignore the root node\n  if (ideal.isRoot && actual.isRoot) {\n    return null\n  }\n\n  // if the versions don't match, it's a change no matter what\n  if (ideal.version !== actual.version) {\n    return 'CHANGE'\n  }\n\n  const binsExist = ideal.binPaths.every((path) => existsSync(path))\n\n  // top nodes, links, and git deps won't have integrity, but do have resolved\n  // if neither node has integrity, the bins exist, and either (a) neither\n  // node has a resolved value or (b) they both do and match, then we can\n  // leave this one alone since we already know the versions match due to\n  // the condition above.  The \"neither has resolved\" case (a) cannot be\n  // treated as a 'mark CHANGE and refetch', because shrinkwraps, bundles,\n  // and link deps may lack this information, and we don't want to try to\n  // go to the registry for something that isn't there.\n  const noIntegrity = !ideal.integrity && !actual.integrity\n  const noResolved = !ideal.resolved && !actual.resolved\n  const resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved\n  if (noIntegrity && binsExist && (resolvedMatch || noResolved)) {\n    return null\n  }\n\n  // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n  const integrityMismatch = !ideal.integrity || !actual.integrity ||\n    !ssri.parse(ideal.integrity).match(actual.integrity)\n  if (integrityMismatch || !binsExist) {\n    return 'CHANGE'\n  }\n\n  return null\n}\n\nconst allChildren = node => {\n  if (!node) {\n    return new Map()\n  }\n\n  // if the node is root, and also a link, then what we really\n  // want is to traverse the target's children\n  if (node.isRoot && node.isLink) {\n    return allChildren(node.target)\n  }\n\n  const kids = new Map()\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) {\n      kids.set(kid.path, kid)\n    }\n  }\n  return kids\n}\n\n// functions for the walk options when we traverse the trees\n// to create the diff tree\nconst getChildren = diff => {\n  const children = []\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet,\n    shrinkwrapInflated,\n  } = diff\n\n  // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n  const actualKids = allChildren(actual)\n  const idealKids = allChildren(ideal)\n\n  if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) {\n    // Guaranteed to get a diff.leaves here, because we always\n    // be called with a proper Diff object when ideal has a shrinkwrap\n    // that has not been inflated.\n    diff.leaves.push(diff)\n    return children\n  }\n\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()])\n  for (const path of paths) {\n    const actual = actualKids.get(path)\n    const ideal = idealKids.get(path)\n    diffNode({\n      actual,\n      ideal,\n      children,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    })\n  }\n\n  if (diff.leaves && !children.length) {\n    diff.leaves.push(diff)\n  }\n\n  return children\n}\n\nconst diffNode = ({\n  actual,\n  ideal,\n  children,\n  unchanged,\n  removed,\n  filterSet,\n  shrinkwrapInflated,\n}) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) {\n    return\n  }\n\n  const action = getAction({actual, ideal})\n\n  // if it's a match, then get its children\n  // otherwise, this is the child diff node\n  if (action || (!shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap)) {\n    if (action === 'REMOVE') {\n      removed.push(actual)\n    }\n    children.push(new Diff({actual, ideal, filterSet, shrinkwrapInflated}))\n  } else {\n    unchanged.push(ideal)\n    // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n    const bd = ideal.package.bundleDependencies\n    if (actual && bd && bd.length) {\n      const bundledChildren = []\n      for (const node of actual.children.values()) {\n        if (node.inBundle) {\n          bundledChildren.push(node)\n        }\n      }\n      for (const node of bundledChildren) {\n        node.parent = ideal\n      }\n    }\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet,\n      shrinkwrapInflated,\n    }))\n  }\n}\n\n// set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff\n    diff.leaves.push(...kid.leaves)\n    diff.unchanged.push(...kid.unchanged)\n    diff.removed.push(...kid.removed)\n  })\n  diff.children = children\n  return diff\n}\n\nmodule.exports = Diff\n"]},"metadata":{},"sourceType":"script"}