{"ast":null,"code":"'use strict';\n\nconst errors = require('./errors.js');\n\nconst {\n  Response\n} = require('minipass-fetch');\n\nconst defaultOpts = require('./default-opts.js');\n\nconst checkResponse = async ({\n  method,\n  uri,\n  res,\n  registry,\n  startTime,\n  auth,\n  opts\n}) => {\n  opts = { ...defaultOpts,\n    ...opts\n  };\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) opts.log.notice('', res.headers.get('npm-notice'));\n\n  if (res.status >= 400) {\n    logRequest(method, res, startTime, opts);\n\n    if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {\n      // we didn't have auth for THIS request, but we do have auth for\n      // requests to the registry indicated by the spec's scope value.\n      // Warn the user.\n      opts.log.warn('registry', `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry`);\n    }\n\n    return checkErrors(method, res, startTime, opts);\n  } else {\n    res.body.on('end', () => logRequest(method, res, startTime, opts));\n\n    if (opts.ignoreBody) {\n      res.body.resume();\n      return new Response(null, res);\n    }\n\n    return res;\n  }\n};\n\nmodule.exports = checkResponse;\n\nfunction logRequest(method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime;\n  const attempt = res.headers.get('x-fetch-attempts');\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : '';\n  const cacheStatus = res.headers.get('x-local-cache-status');\n  const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : '';\n  let urlStr;\n\n  try {\n    const {\n      URL\n    } = require('url');\n\n    const url = new URL(res.url);\n    if (url.password) url.password = '***';\n    urlStr = url.toString();\n  } catch (er) {\n    urlStr = res.url;\n  }\n\n  opts.log.http('fetch', `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);\n}\n\nfunction checkErrors(method, res, startTime, opts) {\n  return res.buffer().catch(() => null).then(body => {\n    let parsed = body;\n\n    try {\n      parsed = JSON.parse(body.toString('utf8'));\n    } catch (e) {}\n\n    if (res.status === 401 && res.headers.get('www-authenticate')) {\n      const auth = res.headers.get('www-authenticate').split(/,\\s*/).map(s => s.toLowerCase());\n\n      if (auth.indexOf('ipaddress') !== -1) {\n        throw new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec);\n      } else if (auth.indexOf('otp') !== -1) {\n        throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n      } else {\n        throw new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);\n      }\n    } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n      // Heuristic for malformed OTP responses that don't include the\n      // www-authenticate header.\n      throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n    } else {\n      throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/npm-registry-fetch/check-response.js"],"names":["errors","require","Response","defaultOpts","checkResponse","method","uri","res","registry","startTime","auth","opts","headers","has","log","notice","get","status","logRequest","scopeAuthKey","token","warn","checkErrors","body","on","ignoreBody","resume","module","exports","elapsedTime","Date","now","attempt","attemptStr","cacheStatus","cacheStr","urlStr","URL","url","password","toString","er","http","toUpperCase","buffer","catch","then","parsed","JSON","parse","e","split","map","s","toLowerCase","indexOf","HttpErrorAuthIPAddress","spec","HttpErrorAuthOTP","HttpErrorAuthUnknown","test","HttpErrorGeneral"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errors = require('./errors.js')\nconst { Response } = require('minipass-fetch')\nconst defaultOpts = require('./default-opts.js')\n\nconst checkResponse =\n  async ({ method, uri, res, registry, startTime, auth, opts }) => {\n    opts = { ...defaultOpts, ...opts }\n    if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache'))\n      opts.log.notice('', res.headers.get('npm-notice'))\n\n    if (res.status >= 400) {\n      logRequest(method, res, startTime, opts)\n      if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {\n      // we didn't have auth for THIS request, but we do have auth for\n      // requests to the registry indicated by the spec's scope value.\n      // Warn the user.\n        opts.log.warn('registry', `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry`)\n      }\n      return checkErrors(method, res, startTime, opts)\n    } else {\n      res.body.on('end', () => logRequest(method, res, startTime, opts))\n      if (opts.ignoreBody) {\n        res.body.resume()\n        return new Response(null, res)\n      }\n      return res\n    }\n  }\nmodule.exports = checkResponse\n\nfunction logRequest (method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime\n  const attempt = res.headers.get('x-fetch-attempts')\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : ''\n  const cacheStatus = res.headers.get('x-local-cache-status')\n  const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : ''\n\n  let urlStr\n  try {\n    const { URL } = require('url')\n    const url = new URL(res.url)\n    if (url.password)\n      url.password = '***'\n\n    urlStr = url.toString()\n  } catch (er) {\n    urlStr = res.url\n  }\n\n  opts.log.http(\n    'fetch',\n    `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`\n  )\n}\n\nfunction checkErrors (method, res, startTime, opts) {\n  return res.buffer()\n    .catch(() => null)\n    .then(body => {\n      let parsed = body\n      try {\n        parsed = JSON.parse(body.toString('utf8'))\n      } catch (e) {}\n      if (res.status === 401 && res.headers.get('www-authenticate')) {\n        const auth = res.headers.get('www-authenticate')\n          .split(/,\\s*/)\n          .map(s => s.toLowerCase())\n        if (auth.indexOf('ipaddress') !== -1) {\n          throw new errors.HttpErrorAuthIPAddress(\n            method, res, parsed, opts.spec\n          )\n        } else if (auth.indexOf('otp') !== -1) {\n          throw new errors.HttpErrorAuthOTP(\n            method, res, parsed, opts.spec\n          )\n        } else {\n          throw new errors.HttpErrorAuthUnknown(\n            method, res, parsed, opts.spec\n          )\n        }\n      } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n        // Heuristic for malformed OTP responses that don't include the\n        // www-authenticate header.\n        throw new errors.HttpErrorAuthOTP(\n          method, res, parsed, opts.spec\n        )\n      } else {\n        throw new errors.HttpErrorGeneral(\n          method, res, parsed, opts.spec\n        )\n      }\n    })\n}\n"]},"metadata":{},"sourceType":"script"}