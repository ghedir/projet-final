{"ast":null,"code":"const cacache = require('cacache');\n\nconst {\n  promisify\n} = require('util');\n\nconst log = require('npmlog');\n\nconst pacote = require('pacote');\n\nconst path = require('path');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst semver = require('semver');\n\nconst BaseCommand = require('./base-command.js');\n\nconst npa = require('npm-package-arg');\n\nconst jsonParse = require('json-parse-even-better-errors');\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst searchCachePackage = async (path, spec, cacheKeys) => {\n  const parsed = npa(spec);\n  if (parsed.rawSpec !== '' && parsed.type === 'tag') throw new Error(`Cannot list cache keys for a tagged package.`);\n  const searchMFH = new RegExp(`^make-fetch-happen:request-cache:.*(?<!/[@a-zA-Z]+)/${parsed.name}/-/(${parsed.name}[^/]+.tgz)$`);\n  const searchPack = new RegExp(`^make-fetch-happen:request-cache:.*/${parsed.escapedName}$`);\n  const results = new Set();\n  cacheKeys = new Set(cacheKeys);\n\n  for (const key of cacheKeys) {\n    // match on the public key registry url format\n    if (searchMFH.test(key)) {\n      // extract the version from the filename\n      const filename = key.match(searchMFH)[1];\n      const noExt = filename.slice(0, -4);\n      const noScope = `${parsed.name.split('/').pop()}-`;\n      const ver = noExt.slice(noScope.length);\n      if (semver.satisfies(ver, parsed.rawSpec)) results.add(key);\n      continue;\n    } // is this key a packument?\n\n\n    if (!searchPack.test(key)) continue;\n    results.add(key);\n    let packument, details;\n\n    try {\n      details = await cacache.get(path, key);\n      packument = jsonParse(details.data);\n    } catch (_) {\n      // if we couldn't parse the packument, abort\n      continue;\n    }\n\n    if (!packument.versions || typeof packument.versions !== 'object') continue; // assuming this is a packument\n\n    for (const ver of Object.keys(packument.versions)) {\n      if (semver.satisfies(ver, parsed.rawSpec)) {\n        if (packument.versions[ver].dist && typeof packument.versions[ver].dist === 'object' && packument.versions[ver].dist.tarball !== undefined && cacheKeys.has(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`)) results.add(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`);\n      }\n    }\n  }\n\n  return results;\n};\n\nclass Cache extends BaseCommand {\n  static get description() {\n    return 'Manipulates packages cache';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'cache';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['cache'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['add <tarball file>', 'add <folder>', 'add <tarball url>', 'add <git url>', 'add <name>@<version>', 'clean [<key>]', 'ls [<name>@<version>]', 'verify'];\n  }\n\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n    if (argv.length === 2) return ['add', 'clean', 'verify', 'ls', 'delete']; // TODO - eventually...\n\n    switch (argv[2]) {\n      case 'verify':\n      case 'clean':\n      case 'add':\n      case 'ls':\n      case 'delete':\n        return [];\n    }\n  }\n\n  exec(args, cb) {\n    this.cache(args).then(() => cb()).catch(cb);\n  }\n\n  async cache(args) {\n    const cmd = args.shift();\n\n    switch (cmd) {\n      case 'rm':\n      case 'clear':\n      case 'clean':\n        return await this.clean(args);\n\n      case 'add':\n        return await this.add(args);\n\n      case 'verify':\n      case 'check':\n        return await this.verify();\n\n      case 'ls':\n        return await this.ls(args);\n\n      default:\n        throw Object.assign(new Error(this.usage), {\n          code: 'EUSAGE'\n        });\n    }\n  } // npm cache clean [pkg]*\n\n\n  async clean(args) {\n    const cachePath = path.join(this.npm.cache, '_cacache');\n\n    if (args.length === 0) {\n      if (!this.npm.config.get('force')) {\n        throw new Error(`As of npm@5, the npm cache self-heals from corruption issues\n  by treating integrity mismatches as cache misses.  As a result,\n  data extracted from the cache is guaranteed to be valid.  If you\n  want to make sure everything is consistent, use \\`npm cache verify\\`\n  instead.  Deleting the cache can only make npm go slower, and is\n  not likely to correct any problems you may be encountering!\n\n  On the other hand, if you're debugging an issue with the installer,\n  or race conditions that depend on the timing of writing to an empty\n  cache, you can use \\`npm install --cache /tmp/empty-cache\\` to use a\n  temporary cache instead of nuking the actual one.\n\n  If you're sure you want to delete the entire cache, rerun this command\n  with --force.`);\n      }\n\n      return rimraf(cachePath);\n    }\n\n    for (const key of args) {\n      let entry;\n\n      try {\n        entry = await cacache.get(cachePath, key);\n      } catch (err) {\n        this.npm.log.warn(`Not Found: ${key}`);\n        break;\n      }\n\n      this.npm.output(`Deleted: ${key}`);\n      await cacache.rm.entry(cachePath, key);\n      await cacache.rm.content(cachePath, entry.integrity);\n    }\n  } // npm cache add <tarball-url>...\n  // npm cache add <pkg> <ver>...\n  // npm cache add <tarball>...\n  // npm cache add <folder>...\n\n\n  async add(args) {\n    const usage = 'Usage:\\n' + '    npm cache add <tarball-url>...\\n' + '    npm cache add <pkg>@<ver>...\\n' + '    npm cache add <tarball>...\\n' + '    npm cache add <folder>...\\n';\n    log.silly('cache add', 'args', args);\n    if (args.length === 0) throw Object.assign(new Error(usage), {\n      code: 'EUSAGE'\n    });\n    return Promise.all(args.map(spec => {\n      log.silly('cache add', 'spec', spec); // we ask pacote for the thing, and then just throw the data\n      // away so that it tee-pipes it into the cache like it does\n      // for a normal request.\n\n      return pacote.tarball.stream(spec, stream => {\n        stream.resume();\n        return stream.promise();\n      }, this.npm.flatOptions);\n    }));\n  }\n\n  async verify() {\n    const cache = path.join(this.npm.cache, '_cacache');\n    const prefix = cache.indexOf(process.env.HOME) === 0 ? `~${cache.substr(process.env.HOME.length)}` : cache;\n    const stats = await cacache.verify(cache);\n    this.npm.output(`Cache verified and compressed (${prefix})`);\n    this.npm.output(`Content verified: ${stats.verifiedContent} (${stats.keptSize} bytes)`);\n    stats.badContentCount && this.npm.output(`Corrupted content removed: ${stats.badContentCount}`);\n    stats.reclaimedCount && this.npm.output(`Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`);\n    stats.missingContent && this.npm.output(`Missing content: ${stats.missingContent}`);\n    this.npm.output(`Index entries: ${stats.totalEntries}`);\n    this.npm.output(`Finished in ${stats.runTime.total / 1000}s`);\n  } // npm cache ls [--package <spec> ...]\n\n\n  async ls(specs) {\n    const cachePath = path.join(this.npm.cache, '_cacache');\n    const cacheKeys = Object.keys(await cacache.ls(cachePath));\n\n    if (specs.length > 0) {\n      // get results for each package spec specified\n      const results = new Set();\n\n      for (const spec of specs) {\n        const keySet = await searchCachePackage(cachePath, spec, cacheKeys);\n\n        for (const key of keySet) results.add(key);\n      }\n\n      [...results].sort(localeCompare).forEach(key => this.npm.output(key));\n      return;\n    }\n\n    cacheKeys.sort(localeCompare).forEach(key => this.npm.output(key));\n  }\n\n}\n\nmodule.exports = Cache;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/cache.js"],"names":["cacache","require","promisify","log","pacote","path","rimraf","semver","BaseCommand","npa","jsonParse","localeCompare","searchCachePackage","spec","cacheKeys","parsed","rawSpec","type","Error","searchMFH","RegExp","name","searchPack","escapedName","results","Set","key","test","filename","match","noExt","slice","noScope","split","pop","ver","length","satisfies","add","packument","details","get","data","_","versions","Object","keys","dist","tarball","undefined","has","Cache","description","params","usage","completion","opts","argv","conf","remain","exec","args","cb","cache","then","catch","cmd","shift","clean","verify","ls","assign","code","cachePath","join","npm","config","entry","err","warn","output","rm","content","integrity","silly","Promise","all","map","stream","resume","promise","flatOptions","prefix","indexOf","process","env","HOME","substr","stats","verifiedContent","keptSize","badContentCount","reclaimedCount","reclaimedSize","missingContent","totalEntries","runTime","total","specs","keySet","sort","forEach","module","exports"],"mappings":"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","sourcesContent":["const cacache = require('cacache')\nconst { promisify } = require('util')\nconst log = require('npmlog')\nconst pacote = require('pacote')\nconst path = require('path')\nconst rimraf = promisify(require('rimraf'))\nconst semver = require('semver')\nconst BaseCommand = require('./base-command.js')\nconst npa = require('npm-package-arg')\nconst jsonParse = require('json-parse-even-better-errors')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst searchCachePackage = async (path, spec, cacheKeys) => {\n  const parsed = npa(spec)\n  if (parsed.rawSpec !== '' && parsed.type === 'tag')\n    throw new Error(`Cannot list cache keys for a tagged package.`)\n  const searchMFH = new RegExp(`^make-fetch-happen:request-cache:.*(?<!/[@a-zA-Z]+)/${parsed.name}/-/(${parsed.name}[^/]+.tgz)$`)\n  const searchPack = new RegExp(`^make-fetch-happen:request-cache:.*/${parsed.escapedName}$`)\n  const results = new Set()\n  cacheKeys = new Set(cacheKeys)\n  for (const key of cacheKeys) {\n    // match on the public key registry url format\n    if (searchMFH.test(key)) {\n      // extract the version from the filename\n      const filename = key.match(searchMFH)[1]\n      const noExt = filename.slice(0, -4)\n      const noScope = `${parsed.name.split('/').pop()}-`\n      const ver = noExt.slice(noScope.length)\n      if (semver.satisfies(ver, parsed.rawSpec))\n        results.add(key)\n      continue\n    }\n    // is this key a packument?\n    if (!searchPack.test(key))\n      continue\n\n    results.add(key)\n    let packument, details\n    try {\n      details = await cacache.get(path, key)\n      packument = jsonParse(details.data)\n    } catch (_) {\n      // if we couldn't parse the packument, abort\n      continue\n    }\n    if (!packument.versions || typeof packument.versions !== 'object')\n      continue\n    // assuming this is a packument\n    for (const ver of Object.keys(packument.versions)) {\n      if (semver.satisfies(ver, parsed.rawSpec)) {\n        if (packument.versions[ver].dist\n          && typeof packument.versions[ver].dist === 'object'\n          && packument.versions[ver].dist.tarball !== undefined\n          && cacheKeys.has(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`))\n          results.add(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`)\n      }\n    }\n  }\n  return results\n}\n\nclass Cache extends BaseCommand {\n  static get description () {\n    return 'Manipulates packages cache'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'cache'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return ['cache']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      'add <tarball file>',\n      'add <folder>',\n      'add <tarball url>',\n      'add <git url>',\n      'add <name>@<version>',\n      'clean [<key>]',\n      'ls [<name>@<version>]',\n      'verify',\n    ]\n  }\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n    if (argv.length === 2)\n      return ['add', 'clean', 'verify', 'ls', 'delete']\n\n    // TODO - eventually...\n    switch (argv[2]) {\n      case 'verify':\n      case 'clean':\n      case 'add':\n      case 'ls':\n      case 'delete':\n        return []\n    }\n  }\n\n  exec (args, cb) {\n    this.cache(args).then(() => cb()).catch(cb)\n  }\n\n  async cache (args) {\n    const cmd = args.shift()\n    switch (cmd) {\n      case 'rm': case 'clear': case 'clean':\n        return await this.clean(args)\n      case 'add':\n        return await this.add(args)\n      case 'verify': case 'check':\n        return await this.verify()\n      case 'ls':\n        return await this.ls(args)\n      default:\n        throw Object.assign(new Error(this.usage), { code: 'EUSAGE' })\n    }\n  }\n\n  // npm cache clean [pkg]*\n  async clean (args) {\n    const cachePath = path.join(this.npm.cache, '_cacache')\n    if (args.length === 0) {\n      if (!this.npm.config.get('force')) {\n        throw new Error(`As of npm@5, the npm cache self-heals from corruption issues\n  by treating integrity mismatches as cache misses.  As a result,\n  data extracted from the cache is guaranteed to be valid.  If you\n  want to make sure everything is consistent, use \\`npm cache verify\\`\n  instead.  Deleting the cache can only make npm go slower, and is\n  not likely to correct any problems you may be encountering!\n\n  On the other hand, if you're debugging an issue with the installer,\n  or race conditions that depend on the timing of writing to an empty\n  cache, you can use \\`npm install --cache /tmp/empty-cache\\` to use a\n  temporary cache instead of nuking the actual one.\n\n  If you're sure you want to delete the entire cache, rerun this command\n  with --force.`)\n      }\n      return rimraf(cachePath)\n    }\n    for (const key of args) {\n      let entry\n      try {\n        entry = await cacache.get(cachePath, key)\n      } catch (err) {\n        this.npm.log.warn(`Not Found: ${key}`)\n        break\n      }\n      this.npm.output(`Deleted: ${key}`)\n      await cacache.rm.entry(cachePath, key)\n      await cacache.rm.content(cachePath, entry.integrity)\n    }\n  }\n\n  // npm cache add <tarball-url>...\n  // npm cache add <pkg> <ver>...\n  // npm cache add <tarball>...\n  // npm cache add <folder>...\n  async add (args) {\n    const usage = 'Usage:\\n' +\n      '    npm cache add <tarball-url>...\\n' +\n      '    npm cache add <pkg>@<ver>...\\n' +\n      '    npm cache add <tarball>...\\n' +\n      '    npm cache add <folder>...\\n'\n    log.silly('cache add', 'args', args)\n    if (args.length === 0)\n      throw Object.assign(new Error(usage), { code: 'EUSAGE' })\n\n    return Promise.all(args.map(spec => {\n      log.silly('cache add', 'spec', spec)\n      // we ask pacote for the thing, and then just throw the data\n      // away so that it tee-pipes it into the cache like it does\n      // for a normal request.\n      return pacote.tarball.stream(spec, stream => {\n        stream.resume()\n        return stream.promise()\n      }, this.npm.flatOptions)\n    }))\n  }\n\n  async verify () {\n    const cache = path.join(this.npm.cache, '_cacache')\n    const prefix = cache.indexOf(process.env.HOME) === 0\n      ? `~${cache.substr(process.env.HOME.length)}`\n      : cache\n    const stats = await cacache.verify(cache)\n    this.npm.output(`Cache verified and compressed (${prefix})`)\n    this.npm.output(`Content verified: ${stats.verifiedContent} (${stats.keptSize} bytes)`)\n    stats.badContentCount && this.npm.output(`Corrupted content removed: ${stats.badContentCount}`)\n    stats.reclaimedCount && this.npm.output(`Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`)\n    stats.missingContent && this.npm.output(`Missing content: ${stats.missingContent}`)\n    this.npm.output(`Index entries: ${stats.totalEntries}`)\n    this.npm.output(`Finished in ${stats.runTime.total / 1000}s`)\n  }\n\n  // npm cache ls [--package <spec> ...]\n  async ls (specs) {\n    const cachePath = path.join(this.npm.cache, '_cacache')\n    const cacheKeys = Object.keys(await cacache.ls(cachePath))\n    if (specs.length > 0) {\n      // get results for each package spec specified\n      const results = new Set()\n      for (const spec of specs) {\n        const keySet = await searchCachePackage(cachePath, spec, cacheKeys)\n        for (const key of keySet)\n          results.add(key)\n      }\n      [...results].sort(localeCompare).forEach(key => this.npm.output(key))\n      return\n    }\n    cacheKeys.sort(localeCompare).forEach(key => this.npm.output(key))\n  }\n}\n\nmodule.exports = Cache\n"]},"metadata":{},"sourceType":"script"}