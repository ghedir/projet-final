{"ast":null,"code":"const debug = require('./debug.js');\n\nconst relpath = require('./relpath.js');\n\nconst Node = require('./node.js');\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _target = Symbol.for('_target');\n\nconst {\n  dirname\n} = require('path'); // defined by Node class\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nclass Link extends Node {\n  constructor(options) {\n    const {\n      root,\n      realpath,\n      target,\n      parent,\n      fsParent\n    } = options;\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node');\n    }\n\n    super({ ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root : fsParent ? fsParent.root : target ? target.root : null)\n    });\n\n    if (target) {\n      this.target = target;\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root;\n    } else {\n      this.target = new Node({ ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root\n      });\n    }\n  }\n\n  get version() {\n    return this.target ? this.target.version : this.package.version || '';\n  }\n\n  get target() {\n    return this[_target];\n  }\n\n  set target(target) {\n    const current = this[_target];\n\n    if (target === current) {\n      return;\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath\n        });\n      });\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target;\n      target.then(node => {\n        this[_target] = null;\n        this.target = node;\n      });\n      return;\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this);\n      }\n\n      if (this.path) {\n        this[_delistFromMeta]();\n\n        this[_target] = null;\n        this.package = {};\n\n        this[_refreshLocation]();\n      } else {\n        this[_target] = null;\n      }\n\n      return;\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path;\n      } else {\n        target.path = target.realpath = this.realpath;\n      }\n\n      target.root = this.root;\n      this[_target] = target;\n      target.linksIn.add(this);\n      this.package = target.package;\n      return;\n    } // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n\n\n    this[_delistFromMeta]();\n\n    this.package = target.package;\n    this.realpath = target.path;\n\n    this[_refreshLocation]();\n\n    target.root = this.root;\n  } // a link always resolves to the relative path to its target\n\n\n  get resolved() {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath ? `file:${relpath(dirname(this.path), this.realpath)}` : null;\n  }\n\n  set resolved(r) {} // deps are resolved on the target, not the Link\n  // so this is a no-op\n\n\n  [_loadDeps]() {} // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n\n\n  get children() {\n    return new Map();\n  }\n\n  set children(c) {}\n\n  get isLink() {\n    return true;\n  }\n\n}\n\nmodule.exports = Link;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/link.js"],"names":["debug","require","relpath","Node","_loadDeps","Symbol","for","_target","dirname","_delistFromMeta","_refreshLocation","Link","constructor","options","root","realpath","target","parent","fsParent","path","TypeError","version","package","current","then","Object","assign","Error","node","linksIn","delete","add","resolved","r","children","Map","c","isLink","module","exports"],"mappings":"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","sourcesContent":["const debug = require('./debug.js')\nconst relpath = require('./relpath.js')\nconst Node = require('./node.js')\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _target = Symbol.for('_target')\nconst {dirname} = require('path')\n// defined by Node class\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nclass Link extends Node {\n  constructor (options) {\n    const { root, realpath, target, parent, fsParent } = options\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node')\n    }\n\n    super({\n      ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root\n      : fsParent ? fsParent.root\n      : target ? target.root\n      : null),\n    })\n\n    if (target) {\n      this.target = target\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root\n    } else {\n      this.target = new Node({\n        ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root,\n      })\n    }\n  }\n\n  get version () {\n    return this.target ? this.target.version : this.package.version || ''\n  }\n\n  get target () {\n    return this[_target]\n  }\n\n  set target (target) {\n    const current = this[_target]\n    if (target === current) {\n      return\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath,\n        })\n      })\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target\n      target.then(node => {\n        this[_target] = null\n        this.target = node\n      })\n      return\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this)\n      }\n      if (this.path) {\n        this[_delistFromMeta]()\n        this[_target] = null\n        this.package = {}\n        this[_refreshLocation]()\n      } else {\n        this[_target] = null\n      }\n      return\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path\n      } else {\n        target.path = target.realpath = this.realpath\n      }\n      target.root = this.root\n      this[_target] = target\n      target.linksIn.add(this)\n      this.package = target.package\n      return\n    }\n\n    // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n    this[_delistFromMeta]()\n    this.package = target.package\n    this.realpath = target.path\n    this[_refreshLocation]()\n\n    target.root = this.root\n  }\n\n  // a link always resolves to the relative path to its target\n  get resolved () {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath\n      ? `file:${relpath(dirname(this.path), this.realpath)}`\n      : null\n  }\n\n  set resolved (r) {}\n\n  // deps are resolved on the target, not the Link\n  // so this is a no-op\n  [_loadDeps] () {}\n\n  // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n  get children () {\n    return new Map()\n  }\n\n  set children (c) {}\n\n  get isLink () {\n    return true\n  }\n}\n\nmodule.exports = Link\n"]},"metadata":{},"sourceType":"script"}