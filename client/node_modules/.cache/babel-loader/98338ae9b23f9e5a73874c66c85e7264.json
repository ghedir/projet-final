{"ast":null,"code":"// get all the paths that are (or might be) installed for a given pkg\n// There's no guarantee that all of these will be installed, but if they\n// are present, then we can assume that they're associated.\nconst binTarget = require('./bin-target.js');\n\nconst manTarget = require('./man-target.js');\n\nconst {\n  resolve,\n  basename\n} = require('path');\n\nconst isWindows = require('./is-windows.js');\n\nmodule.exports = ({\n  path,\n  pkg,\n  global,\n  top\n}) => {\n  if (top && !global) return [];\n  const binSet = [];\n  const binTarg = binTarget({\n    path,\n    top\n  });\n\n  if (pkg.bin) {\n    for (const bin of Object.keys(pkg.bin)) {\n      const b = resolve(binTarg, bin);\n      binSet.push(b);\n\n      if (isWindows) {\n        binSet.push(b + '.cmd');\n        binSet.push(b + '.ps1');\n      }\n    }\n  }\n\n  const manTarg = manTarget({\n    path,\n    top\n  });\n  const manSet = [];\n\n  if (manTarg && pkg.man && Array.isArray(pkg.man) && pkg.man.length) {\n    for (const man of pkg.man) {\n      const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/); // invalid entries invalidate the entire man set\n\n      if (!parseMan) return binSet;\n      const stem = parseMan[1];\n      const sxn = parseMan[2];\n      const base = basename(stem);\n      const absFrom = resolve(path, man);\n      /* istanbul ignore if - should be impossible */\n\n      if (absFrom.indexOf(path) !== 0) return binSet;\n      manSet.push(resolve(manTarg, 'man' + sxn, base));\n    }\n  }\n\n  return manSet.length ? [...binSet, ...manSet] : binSet;\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/bin-links/lib/get-paths.js"],"names":["binTarget","require","manTarget","resolve","basename","isWindows","module","exports","path","pkg","global","top","binSet","binTarg","bin","Object","keys","b","push","manTarg","manSet","man","Array","isArray","length","parseMan","match","stem","sxn","base","absFrom","indexOf"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAM;AAACE,EAAAA,OAAD;AAAUC,EAAAA;AAAV,IAAsBH,OAAO,CAAC,MAAD,CAAnC;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,iBAAD,CAAzB;;AACAK,MAAM,CAACC,OAAP,GAAiB,CAAC;AAACC,EAAAA,IAAD;AAAOC,EAAAA,GAAP;AAAYC,EAAAA,MAAZ;AAAoBC,EAAAA;AAApB,CAAD,KAA8B;AAC7C,MAAIA,GAAG,IAAI,CAACD,MAAZ,EACE,OAAO,EAAP;AAEF,QAAME,MAAM,GAAG,EAAf;AACA,QAAMC,OAAO,GAAGb,SAAS,CAAC;AAACQ,IAAAA,IAAD;AAAOG,IAAAA;AAAP,GAAD,CAAzB;;AACA,MAAIF,GAAG,CAACK,GAAR,EAAa;AACX,SAAK,MAAMA,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYP,GAAG,CAACK,GAAhB,CAAlB,EAAwC;AACtC,YAAMG,CAAC,GAAGd,OAAO,CAACU,OAAD,EAAUC,GAAV,CAAjB;AACAF,MAAAA,MAAM,CAACM,IAAP,CAAYD,CAAZ;;AACA,UAAIZ,SAAJ,EAAe;AACbO,QAAAA,MAAM,CAACM,IAAP,CAAYD,CAAC,GAAG,MAAhB;AACAL,QAAAA,MAAM,CAACM,IAAP,CAAYD,CAAC,GAAG,MAAhB;AACD;AACF;AACF;;AAED,QAAME,OAAO,GAAGjB,SAAS,CAAC;AAACM,IAAAA,IAAD;AAAOG,IAAAA;AAAP,GAAD,CAAzB;AACA,QAAMS,MAAM,GAAG,EAAf;;AACA,MAAID,OAAO,IAAIV,GAAG,CAACY,GAAf,IAAsBC,KAAK,CAACC,OAAN,CAAcd,GAAG,CAACY,GAAlB,CAAtB,IAAgDZ,GAAG,CAACY,GAAJ,CAAQG,MAA5D,EAAoE;AAClE,SAAK,MAAMH,GAAX,IAAkBZ,GAAG,CAACY,GAAtB,EAA2B;AACzB,YAAMI,QAAQ,GAAGJ,GAAG,CAACK,KAAJ,CAAU,wBAAV,CAAjB,CADyB,CAEzB;;AACA,UAAI,CAACD,QAAL,EACE,OAAOb,MAAP;AAEF,YAAMe,IAAI,GAAGF,QAAQ,CAAC,CAAD,CAArB;AACA,YAAMG,GAAG,GAAGH,QAAQ,CAAC,CAAD,CAApB;AACA,YAAMI,IAAI,GAAGzB,QAAQ,CAACuB,IAAD,CAArB;AACA,YAAMG,OAAO,GAAG3B,OAAO,CAACK,IAAD,EAAOa,GAAP,CAAvB;AAEA;;AACA,UAAIS,OAAO,CAACC,OAAR,CAAgBvB,IAAhB,MAA0B,CAA9B,EACE,OAAOI,MAAP;AAEFQ,MAAAA,MAAM,CAACF,IAAP,CAAYf,OAAO,CAACgB,OAAD,EAAU,QAAQS,GAAlB,EAAuBC,IAAvB,CAAnB;AACD;AACF;;AAED,SAAOT,MAAM,CAACI,MAAP,GAAgB,CAAC,GAAGZ,MAAJ,EAAY,GAAGQ,MAAf,CAAhB,GAAyCR,MAAhD;AACD,CAxCD","sourcesContent":["// get all the paths that are (or might be) installed for a given pkg\n// There's no guarantee that all of these will be installed, but if they\n// are present, then we can assume that they're associated.\nconst binTarget = require('./bin-target.js')\nconst manTarget = require('./man-target.js')\nconst {resolve, basename} = require('path')\nconst isWindows = require('./is-windows.js')\nmodule.exports = ({path, pkg, global, top}) => {\n  if (top && !global)\n    return []\n\n  const binSet = []\n  const binTarg = binTarget({path, top})\n  if (pkg.bin) {\n    for (const bin of Object.keys(pkg.bin)) {\n      const b = resolve(binTarg, bin)\n      binSet.push(b)\n      if (isWindows) {\n        binSet.push(b + '.cmd')\n        binSet.push(b + '.ps1')\n      }\n    }\n  }\n\n  const manTarg = manTarget({path, top})\n  const manSet = []\n  if (manTarg && pkg.man && Array.isArray(pkg.man) && pkg.man.length) {\n    for (const man of pkg.man) {\n      const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n      // invalid entries invalidate the entire man set\n      if (!parseMan)\n        return binSet\n\n      const stem = parseMan[1]\n      const sxn = parseMan[2]\n      const base = basename(stem)\n      const absFrom = resolve(path, man)\n\n      /* istanbul ignore if - should be impossible */\n      if (absFrom.indexOf(path) !== 0)\n        return binSet\n\n      manSet.push(resolve(manTarg, 'man' + sxn, base))\n    }\n  }\n\n  return manSet.length ? [...binSet, ...manSet] : binSet\n}\n"]},"metadata":{},"sourceType":"script"}