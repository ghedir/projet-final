{"ast":null,"code":"// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node]);\n\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to);\n      }\n    }\n\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from);\n      }\n    }\n  }\n\n  const entrySets = new Map();\n\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // overridden, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue;\n      } // this is the entry point into the peer set\n\n\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer]);\n\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to);\n            }\n          }\n        } // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n\n\n        if (sub.has(node)) {\n          entrySets.set(edge, sub);\n        }\n      }\n    }\n  }\n\n  return entrySets;\n};\n\nmodule.exports = peerEntrySets;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/peer-entry-sets.js"],"names":["peerEntrySets","node","unionSet","Set","edge","edgesOut","values","valid","peer","to","add","edgesIn","from","entrySets","Map","isTop","sub","has","set","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,aAAa,GAAGC,IAAI,IAAI;AAC5B;AACA;AACA;AACA,QAAMC,QAAQ,GAAG,IAAIC,GAAJ,CAAQ,CAACF,IAAD,CAAR,CAAjB;;AACA,OAAK,MAAMA,IAAX,IAAmBC,QAAnB,EAA6B;AAC3B,SAAK,MAAME,IAAX,IAAmBH,IAAI,CAACI,QAAL,CAAcC,MAAd,EAAnB,EAA2C;AACzC,UAAIF,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAnB,IAA2BJ,IAAI,CAACK,EAApC,EAAwC;AACtCP,QAAAA,QAAQ,CAACQ,GAAT,CAAaN,IAAI,CAACK,EAAlB;AACD;AACF;;AACD,SAAK,MAAML,IAAX,IAAmBH,IAAI,CAACU,OAAxB,EAAiC;AAC/B,UAAIP,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAvB,EAA6B;AAC3BN,QAAAA,QAAQ,CAACQ,GAAT,CAAaN,IAAI,CAACQ,IAAlB;AACD;AACF;AACF;;AACD,QAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;;AACA,OAAK,MAAMN,IAAX,IAAmBN,QAAnB,EAA6B;AAC3B,SAAK,MAAME,IAAX,IAAmBI,IAAI,CAACG,OAAxB,EAAiC;AAC/B;AACA;AACA,UAAI,CAACP,IAAI,CAACG,KAAV,EAAiB;AACf;AACD,OAL8B,CAM/B;;;AACA,UAAI,CAACH,IAAI,CAACI,IAAN,IAAcJ,IAAI,CAACQ,IAAL,CAAUG,KAA5B,EAAmC;AACjC;AACA,cAAMC,GAAG,GAAG,IAAIb,GAAJ,CAAQ,CAACK,IAAD,CAAR,CAAZ;;AACA,aAAK,MAAMA,IAAX,IAAmBQ,GAAnB,EAAwB;AACtB,eAAK,MAAMZ,IAAX,IAAmBI,IAAI,CAACH,QAAL,CAAcC,MAAd,EAAnB,EAA2C;AACzC,gBAAIF,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAnB,IAA2BJ,IAAI,CAACK,EAApC,EAAwC;AACtCO,cAAAA,GAAG,CAACN,GAAJ,CAAQN,IAAI,CAACK,EAAb;AACD;AACF;AACF,SATgC,CAUjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAIO,GAAG,CAACC,GAAJ,CAAQhB,IAAR,CAAJ,EAAmB;AACjBY,UAAAA,SAAS,CAACK,GAAV,CAAcd,IAAd,EAAoBY,GAApB;AACD;AACF;AACF;AACF;;AAED,SAAOH,SAAP;AACD,CAhED;;AAkEAM,MAAM,CAACC,OAAP,GAAiBpB,aAAjB","sourcesContent":["// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\n\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node])\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to)\n      }\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from)\n      }\n    }\n  }\n  const entrySets = new Map()\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // overridden, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue\n      }\n      // this is the entry point into the peer set\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer])\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to)\n            }\n          }\n        }\n        // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n        if (sub.has(node)) {\n          entrySets.set(edge, sub)\n        }\n      }\n    }\n  }\n\n  return entrySets\n}\n\nmodule.exports = peerEntrySets\n"]},"metadata":{},"sourceType":"script"}