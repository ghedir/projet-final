{"ast":null,"code":"// given a starting node, what is the *deepest* target where name could go?\n// This is not on the Node class for the simple reason that we sometimes\n// need to check the deepest *potential* target for a Node that is not yet\n// added to the tree where we are checking.\nconst deepestNestingTarget = (start, name) => {\n  for (const target of start.ancestry()) {\n    // note: this will skip past the first target if edge is peer\n    if (target.isProjectRoot || !target.resolveParent || target.globalTop) {\n      return target;\n    }\n\n    const targetEdge = target.edgesOut.get(name);\n\n    if (!targetEdge || !targetEdge.peer) {\n      return target;\n    }\n  }\n};\n\nmodule.exports = deepestNestingTarget;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/deepest-nesting-target.js"],"names":["deepestNestingTarget","start","name","target","ancestry","isProjectRoot","resolveParent","globalTop","targetEdge","edgesOut","get","peer","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA,MAAMA,oBAAoB,GAAG,CAACC,KAAD,EAAQC,IAAR,KAAiB;AAC5C,OAAK,MAAMC,MAAX,IAAqBF,KAAK,CAACG,QAAN,EAArB,EAAuC;AACrC;AACA,QAAID,MAAM,CAACE,aAAP,IAAwB,CAACF,MAAM,CAACG,aAAhC,IAAiDH,MAAM,CAACI,SAA5D,EAAuE;AACrE,aAAOJ,MAAP;AACD;;AACD,UAAMK,UAAU,GAAGL,MAAM,CAACM,QAAP,CAAgBC,GAAhB,CAAoBR,IAApB,CAAnB;;AACA,QAAI,CAACM,UAAD,IAAe,CAACA,UAAU,CAACG,IAA/B,EAAqC;AACnC,aAAOR,MAAP;AACD;AACF;AACF,CAXD;;AAaAS,MAAM,CAACC,OAAP,GAAiBb,oBAAjB","sourcesContent":["// given a starting node, what is the *deepest* target where name could go?\n// This is not on the Node class for the simple reason that we sometimes\n// need to check the deepest *potential* target for a Node that is not yet\n// added to the tree where we are checking.\nconst deepestNestingTarget = (start, name) => {\n  for (const target of start.ancestry()) {\n    // note: this will skip past the first target if edge is peer\n    if (target.isProjectRoot || !target.resolveParent || target.globalTop) {\n      return target\n    }\n    const targetEdge = target.edgesOut.get(name)\n    if (!targetEdge || !targetEdge.peer) {\n      return target\n    }\n  }\n}\n\nmodule.exports = deepestNestingTarget\n"]},"metadata":{},"sourceType":"script"}