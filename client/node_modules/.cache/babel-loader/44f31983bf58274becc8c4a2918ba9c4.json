{"ast":null,"code":"// An object representing a vulnerability either as the result of an\n// advisory or due to the package in question depending exclusively on\n// vulnerable versions of a dep.\n//\n// - name: package name\n// - range: Set of vulnerable versions\n// - nodes: Set of nodes affected\n// - effects: Set of vulns triggered by this one\n// - advisories: Set of advisories (including metavulns) causing this vuln.\n//   All of the entries in via are vulnerability objects returned by\n//   @npmcli/metavuln-calculator\n// - via: dependency vulns which cause this one\nconst {\n  satisfies,\n  simplifyRange\n} = require('semver');\n\nconst semverOpt = {\n  loose: true,\n  includePrerelease: true\n};\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst npa = require('npm-package-arg');\n\nconst _range = Symbol('_range');\n\nconst _simpleRange = Symbol('_simpleRange');\n\nconst _fixAvailable = Symbol('_fixAvailable');\n\nconst severities = new Map([['info', 0], ['low', 1], ['moderate', 2], ['high', 3], ['critical', 4], [null, -1]]);\n\nfor (const [name, val] of severities.entries()) {\n  severities.set(val, name);\n}\n\nclass Vuln {\n  constructor({\n    name,\n    advisory\n  }) {\n    this.name = name;\n    this.via = new Set();\n    this.advisories = new Set();\n    this.severity = null;\n    this.effects = new Set();\n    this.topNodes = new Set();\n    this[_range] = null;\n    this[_simpleRange] = null;\n    this.nodes = new Set(); // assume a fix is available unless it hits a top node\n    // that locks it in place, setting this false or {isSemVerMajor, version}.\n\n    this[_fixAvailable] = true;\n    this.addAdvisory(advisory);\n    this.packument = advisory.packument;\n    this.versions = advisory.versions;\n  }\n\n  get fixAvailable() {\n    return this[_fixAvailable];\n  }\n\n  set fixAvailable(f) {\n    this[_fixAvailable] = f; // if there's a fix available for this at the top level, it means that\n    // it will also fix the vulns that led to it being there.  to get there,\n    // we set the vias to the most \"strict\" of fix availables.\n    // - false: no fix is available\n    // - {name, version, isSemVerMajor} fix requires -f, is semver major\n    // - {name, version} fix requires -f, not semver major\n    // - true: fix does not require -f\n\n    for (const v of this.via) {\n      // don't blow up on loops\n      if (v.fixAvailable === f) {\n        continue;\n      }\n\n      if (f === false) {\n        v.fixAvailable = f;\n      } else if (v.fixAvailable === true) {\n        v.fixAvailable = f;\n      } else if (typeof f === 'object' && (typeof v.fixAvailable !== 'object' || !v.fixAvailable.isSemVerMajor)) {\n        v.fixAvailable = f;\n      }\n    }\n  }\n\n  get isDirect() {\n    for (const node of this.nodes.values()) {\n      for (const edge of node.edgesIn) {\n        if (edge.from.isProjectRoot || edge.from.isWorkspace) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  testSpec(spec) {\n    const specObj = npa(spec);\n\n    if (!specObj.registry) {\n      return true;\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec;\n    }\n\n    for (const v of this.versions) {\n      if (satisfies(v, spec) && !satisfies(v, this.range, semverOpt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      severity: this.severity,\n      isDirect: this.isDirect,\n      // just loop over the advisories, since via is only Vuln objects,\n      // and calculated advisories have all the info we need\n      via: [...this.advisories].map(v => v.type === 'metavuln' ? v.dependency : { ...v,\n        versions: undefined,\n        vulnerableVersions: undefined,\n        id: undefined\n      }).sort((a, b) => localeCompare(String(a.source || a), String(b.source || b))),\n      effects: [...this.effects].map(v => v.name).sort(localeCompare),\n      range: this.simpleRange,\n      nodes: [...this.nodes].map(n => n.location).sort(localeCompare),\n      fixAvailable: this[_fixAvailable]\n    };\n  }\n\n  addVia(v) {\n    this.via.add(v);\n    v.effects.add(this); // call the setter since we might add vias _after_ setting fixAvailable\n\n    this.fixAvailable = this.fixAvailable;\n  }\n\n  deleteVia(v) {\n    this.via.delete(v);\n    v.effects.delete(this);\n  }\n\n  deleteAdvisory(advisory) {\n    this.advisories.delete(advisory); // make sure we have the max severity of all the vulns causing this one\n\n    this.severity = null;\n    this[_range] = null;\n    this[_simpleRange] = null; // refresh severity\n\n    for (const advisory of this.advisories) {\n      this.addAdvisory(advisory);\n    } // remove any effects that are no longer relevant\n\n\n    const vias = new Set([...this.advisories].map(a => a.dependency));\n\n    for (const via of this.via) {\n      if (!vias.has(via.name)) {\n        this.deleteVia(via);\n      }\n    }\n  }\n\n  addAdvisory(advisory) {\n    this.advisories.add(advisory);\n    const sev = severities.get(advisory.severity);\n    this[_range] = null;\n    this[_simpleRange] = null;\n\n    if (sev > severities.get(this.severity)) {\n      this.severity = advisory.severity;\n    }\n  }\n\n  get range() {\n    return this[_range] || (this[_range] = [...this.advisories].map(v => v.range).join(' || '));\n  }\n\n  get simpleRange() {\n    if (this[_simpleRange] && this[_simpleRange] === this[_range]) {\n      return this[_simpleRange];\n    }\n\n    const versions = [...this.advisories][0].versions;\n    const range = this.range;\n    const simple = simplifyRange(versions, range, semverOpt);\n    return this[_simpleRange] = this[_range] = simple;\n  }\n\n  isVulnerable(node) {\n    if (this.nodes.has(node)) {\n      return true;\n    }\n\n    const {\n      version\n    } = node.package;\n\n    if (!version) {\n      return false;\n    }\n\n    for (const v of this.advisories) {\n      if (v.testVersion(version)) {\n        this.nodes.add(node);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = Vuln;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/vuln.js"],"names":["satisfies","simplifyRange","require","semverOpt","loose","includePrerelease","localeCompare","npa","_range","Symbol","_simpleRange","_fixAvailable","severities","Map","name","val","entries","set","Vuln","constructor","advisory","via","Set","advisories","severity","effects","topNodes","nodes","addAdvisory","packument","versions","fixAvailable","f","v","isSemVerMajor","isDirect","node","values","edge","edgesIn","from","isProjectRoot","isWorkspace","testSpec","spec","specObj","registry","subSpec","rawSpec","range","toJSON","map","type","dependency","undefined","vulnerableVersions","id","sort","a","b","String","source","simpleRange","n","location","addVia","add","deleteVia","delete","deleteAdvisory","vias","has","sev","get","join","simple","isVulnerable","version","package","testVersion","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAM;AAACA,EAAAA,SAAD;AAAYC,EAAAA;AAAZ,IAA6BC,OAAO,CAAC,QAAD,CAA1C;;AACA,MAAMC,SAAS,GAAG;AAAEC,EAAAA,KAAK,EAAE,IAAT;AAAeC,EAAAA,iBAAiB,EAAE;AAAlC,CAAlB;;AAEA,MAAMC,aAAa,GAAGJ,OAAO,CAAC,+BAAD,CAAP,CAAyC,IAAzC,CAAtB;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMM,MAAM,GAAGC,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMC,YAAY,GAAGD,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAME,aAAa,GAAGF,MAAM,CAAC,eAAD,CAA5B;;AAEA,MAAMG,UAAU,GAAG,IAAIC,GAAJ,CAAQ,CACzB,CAAC,MAAD,EAAS,CAAT,CADyB,EAEzB,CAAC,KAAD,EAAQ,CAAR,CAFyB,EAGzB,CAAC,UAAD,EAAa,CAAb,CAHyB,EAIzB,CAAC,MAAD,EAAS,CAAT,CAJyB,EAKzB,CAAC,UAAD,EAAa,CAAb,CALyB,EAMzB,CAAC,IAAD,EAAO,CAAC,CAAR,CANyB,CAAR,CAAnB;;AASA,KAAK,MAAM,CAACC,IAAD,EAAOC,GAAP,CAAX,IAA0BH,UAAU,CAACI,OAAX,EAA1B,EAAgD;AAC9CJ,EAAAA,UAAU,CAACK,GAAX,CAAeF,GAAf,EAAoBD,IAApB;AACD;;AAED,MAAMI,IAAN,CAAW;AACTC,EAAAA,WAAW,CAAE;AAAEL,IAAAA,IAAF;AAAQM,IAAAA;AAAR,GAAF,EAAsB;AAC/B,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKO,GAAL,GAAW,IAAIC,GAAJ,EAAX;AACA,SAAKC,UAAL,GAAkB,IAAID,GAAJ,EAAlB;AACA,SAAKE,QAAL,GAAgB,IAAhB;AACA,SAAKC,OAAL,GAAe,IAAIH,GAAJ,EAAf;AACA,SAAKI,QAAL,GAAgB,IAAIJ,GAAJ,EAAhB;AACA,SAAKd,MAAL,IAAe,IAAf;AACA,SAAKE,YAAL,IAAqB,IAArB;AACA,SAAKiB,KAAL,GAAa,IAAIL,GAAJ,EAAb,CAT+B,CAU/B;AACA;;AACA,SAAKX,aAAL,IAAsB,IAAtB;AACA,SAAKiB,WAAL,CAAiBR,QAAjB;AACA,SAAKS,SAAL,GAAiBT,QAAQ,CAACS,SAA1B;AACA,SAAKC,QAAL,GAAgBV,QAAQ,CAACU,QAAzB;AACD;;AAEe,MAAZC,YAAY,GAAI;AAClB,WAAO,KAAKpB,aAAL,CAAP;AACD;;AAEe,MAAZoB,YAAY,CAAEC,CAAF,EAAK;AACnB,SAAKrB,aAAL,IAAsBqB,CAAtB,CADmB,CAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAK,MAAMC,CAAX,IAAgB,KAAKZ,GAArB,EAA0B;AACxB;AACA,UAAIY,CAAC,CAACF,YAAF,KAAmBC,CAAvB,EAA0B;AACxB;AACD;;AAED,UAAIA,CAAC,KAAK,KAAV,EAAiB;AACfC,QAAAA,CAAC,CAACF,YAAF,GAAiBC,CAAjB;AACD,OAFD,MAEO,IAAIC,CAAC,CAACF,YAAF,KAAmB,IAAvB,EAA6B;AAClCE,QAAAA,CAAC,CAACF,YAAF,GAAiBC,CAAjB;AACD,OAFM,MAEA,IAAI,OAAOA,CAAP,KAAa,QAAb,KACT,OAAOC,CAAC,CAACF,YAAT,KAA0B,QAA1B,IAAsC,CAACE,CAAC,CAACF,YAAF,CAAeG,aAD7C,CAAJ,EACiE;AACtED,QAAAA,CAAC,CAACF,YAAF,GAAiBC,CAAjB;AACD;AACF;AACF;;AAEW,MAARG,QAAQ,GAAI;AACd,SAAK,MAAMC,IAAX,IAAmB,KAAKT,KAAL,CAAWU,MAAX,EAAnB,EAAwC;AACtC,WAAK,MAAMC,IAAX,IAAmBF,IAAI,CAACG,OAAxB,EAAiC;AAC/B,YAAID,IAAI,CAACE,IAAL,CAAUC,aAAV,IAA2BH,IAAI,CAACE,IAAL,CAAUE,WAAzC,EAAsD;AACpD,iBAAO,IAAP;AACD;AACF;AACF;;AACD,WAAO,KAAP;AACD;;AAEDC,EAAAA,QAAQ,CAAEC,IAAF,EAAQ;AACd,UAAMC,OAAO,GAAGtC,GAAG,CAACqC,IAAD,CAAnB;;AACA,QAAI,CAACC,OAAO,CAACC,QAAb,EAAuB;AACrB,aAAO,IAAP;AACD;;AAED,QAAID,OAAO,CAACE,OAAZ,EAAqB;AACnBH,MAAAA,IAAI,GAAGC,OAAO,CAACE,OAAR,CAAgBC,OAAvB;AACD;;AAED,SAAK,MAAMf,CAAX,IAAgB,KAAKH,QAArB,EAA+B;AAC7B,UAAI9B,SAAS,CAACiC,CAAD,EAAIW,IAAJ,CAAT,IAAsB,CAAC5C,SAAS,CAACiC,CAAD,EAAI,KAAKgB,KAAT,EAAgB9C,SAAhB,CAApC,EAAgE;AAC9D,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED+C,EAAAA,MAAM,GAAI;AACR,WAAO;AACLpC,MAAAA,IAAI,EAAE,KAAKA,IADN;AAELU,MAAAA,QAAQ,EAAE,KAAKA,QAFV;AAGLW,MAAAA,QAAQ,EAAE,KAAKA,QAHV;AAIL;AACA;AACAd,MAAAA,GAAG,EAAE,CAAC,GAAG,KAAKE,UAAT,EAAqB4B,GAArB,CAAyBlB,CAAC,IAAIA,CAAC,CAACmB,IAAF,KAAW,UAAX,GAAwBnB,CAAC,CAACoB,UAA1B,GAAuC,EACxE,GAAGpB,CADqE;AAExEH,QAAAA,QAAQ,EAAEwB,SAF8D;AAGxEC,QAAAA,kBAAkB,EAAED,SAHoD;AAIxEE,QAAAA,EAAE,EAAEF;AAJoE,OAArE,EAKFG,IALE,CAKG,CAACC,CAAD,EAAIC,CAAJ,KACNrD,aAAa,CAACsD,MAAM,CAACF,CAAC,CAACG,MAAF,IAAYH,CAAb,CAAP,EAAwBE,MAAM,CAACD,CAAC,CAACE,MAAF,IAAYF,CAAb,CAA9B,CANV,CANA;AAaLlC,MAAAA,OAAO,EAAE,CAAC,GAAG,KAAKA,OAAT,EAAkB0B,GAAlB,CAAsBlB,CAAC,IAAIA,CAAC,CAACnB,IAA7B,EAAmC2C,IAAnC,CAAwCnD,aAAxC,CAbJ;AAcL2C,MAAAA,KAAK,EAAE,KAAKa,WAdP;AAeLnC,MAAAA,KAAK,EAAE,CAAC,GAAG,KAAKA,KAAT,EAAgBwB,GAAhB,CAAoBY,CAAC,IAAIA,CAAC,CAACC,QAA3B,EAAqCP,IAArC,CAA0CnD,aAA1C,CAfF;AAgBLyB,MAAAA,YAAY,EAAE,KAAKpB,aAAL;AAhBT,KAAP;AAkBD;;AAEDsD,EAAAA,MAAM,CAAEhC,CAAF,EAAK;AACT,SAAKZ,GAAL,CAAS6C,GAAT,CAAajC,CAAb;AACAA,IAAAA,CAAC,CAACR,OAAF,CAAUyC,GAAV,CAAc,IAAd,EAFS,CAGT;;AACA,SAAKnC,YAAL,GAAoB,KAAKA,YAAzB;AACD;;AAEDoC,EAAAA,SAAS,CAAElC,CAAF,EAAK;AACZ,SAAKZ,GAAL,CAAS+C,MAAT,CAAgBnC,CAAhB;AACAA,IAAAA,CAAC,CAACR,OAAF,CAAU2C,MAAV,CAAiB,IAAjB;AACD;;AAEDC,EAAAA,cAAc,CAAEjD,QAAF,EAAY;AACxB,SAAKG,UAAL,CAAgB6C,MAAhB,CAAuBhD,QAAvB,EADwB,CAExB;;AACA,SAAKI,QAAL,GAAgB,IAAhB;AACA,SAAKhB,MAAL,IAAe,IAAf;AACA,SAAKE,YAAL,IAAqB,IAArB,CALwB,CAMxB;;AACA,SAAK,MAAMU,QAAX,IAAuB,KAAKG,UAA5B,EAAwC;AACtC,WAAKK,WAAL,CAAiBR,QAAjB;AACD,KATuB,CAWxB;;;AACA,UAAMkD,IAAI,GAAG,IAAIhD,GAAJ,CAAQ,CAAC,GAAG,KAAKC,UAAT,EAAqB4B,GAArB,CAAyBO,CAAC,IAAIA,CAAC,CAACL,UAAhC,CAAR,CAAb;;AACA,SAAK,MAAMhC,GAAX,IAAkB,KAAKA,GAAvB,EAA4B;AAC1B,UAAI,CAACiD,IAAI,CAACC,GAAL,CAASlD,GAAG,CAACP,IAAb,CAAL,EAAyB;AACvB,aAAKqD,SAAL,CAAe9C,GAAf;AACD;AACF;AACF;;AAEDO,EAAAA,WAAW,CAAER,QAAF,EAAY;AACrB,SAAKG,UAAL,CAAgB2C,GAAhB,CAAoB9C,QAApB;AACA,UAAMoD,GAAG,GAAG5D,UAAU,CAAC6D,GAAX,CAAerD,QAAQ,CAACI,QAAxB,CAAZ;AACA,SAAKhB,MAAL,IAAe,IAAf;AACA,SAAKE,YAAL,IAAqB,IAArB;;AACA,QAAI8D,GAAG,GAAG5D,UAAU,CAAC6D,GAAX,CAAe,KAAKjD,QAApB,CAAV,EAAyC;AACvC,WAAKA,QAAL,GAAgBJ,QAAQ,CAACI,QAAzB;AACD;AACF;;AAEQ,MAALyB,KAAK,GAAI;AACX,WAAO,KAAKzC,MAAL,MACJ,KAAKA,MAAL,IAAe,CAAC,GAAG,KAAKe,UAAT,EAAqB4B,GAArB,CAAyBlB,CAAC,IAAIA,CAAC,CAACgB,KAAhC,EAAuCyB,IAAvC,CAA4C,MAA5C,CADX,CAAP;AAED;;AAEc,MAAXZ,WAAW,GAAI;AACjB,QAAI,KAAKpD,YAAL,KAAsB,KAAKA,YAAL,MAAuB,KAAKF,MAAL,CAAjD,EAA+D;AAC7D,aAAO,KAAKE,YAAL,CAAP;AACD;;AAED,UAAMoB,QAAQ,GAAG,CAAC,GAAG,KAAKP,UAAT,EAAqB,CAArB,EAAwBO,QAAzC;AACA,UAAMmB,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAM0B,MAAM,GAAG1E,aAAa,CAAC6B,QAAD,EAAWmB,KAAX,EAAkB9C,SAAlB,CAA5B;AACA,WAAO,KAAKO,YAAL,IAAqB,KAAKF,MAAL,IAAemE,MAA3C;AACD;;AAEDC,EAAAA,YAAY,CAAExC,IAAF,EAAQ;AAClB,QAAI,KAAKT,KAAL,CAAW4C,GAAX,CAAenC,IAAf,CAAJ,EAA0B;AACxB,aAAO,IAAP;AACD;;AAED,UAAM;AAAEyC,MAAAA;AAAF,QAAczC,IAAI,CAAC0C,OAAzB;;AACA,QAAI,CAACD,OAAL,EAAc;AACZ,aAAO,KAAP;AACD;;AAED,SAAK,MAAM5C,CAAX,IAAgB,KAAKV,UAArB,EAAiC;AAC/B,UAAIU,CAAC,CAAC8C,WAAF,CAAcF,OAAd,CAAJ,EAA4B;AAC1B,aAAKlD,KAAL,CAAWuC,GAAX,CAAe9B,IAAf;AACA,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AA/KQ;;AAkLX4C,MAAM,CAACC,OAAP,GAAiB/D,IAAjB","sourcesContent":["// An object representing a vulnerability either as the result of an\n// advisory or due to the package in question depending exclusively on\n// vulnerable versions of a dep.\n//\n// - name: package name\n// - range: Set of vulnerable versions\n// - nodes: Set of nodes affected\n// - effects: Set of vulns triggered by this one\n// - advisories: Set of advisories (including metavulns) causing this vuln.\n//   All of the entries in via are vulnerability objects returned by\n//   @npmcli/metavuln-calculator\n// - via: dependency vulns which cause this one\n\nconst {satisfies, simplifyRange} = require('semver')\nconst semverOpt = { loose: true, includePrerelease: true }\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst _range = Symbol('_range')\nconst _simpleRange = Symbol('_simpleRange')\nconst _fixAvailable = Symbol('_fixAvailable')\n\nconst severities = new Map([\n  ['info', 0],\n  ['low', 1],\n  ['moderate', 2],\n  ['high', 3],\n  ['critical', 4],\n  [null, -1],\n])\n\nfor (const [name, val] of severities.entries()) {\n  severities.set(val, name)\n}\n\nclass Vuln {\n  constructor ({ name, advisory }) {\n    this.name = name\n    this.via = new Set()\n    this.advisories = new Set()\n    this.severity = null\n    this.effects = new Set()\n    this.topNodes = new Set()\n    this[_range] = null\n    this[_simpleRange] = null\n    this.nodes = new Set()\n    // assume a fix is available unless it hits a top node\n    // that locks it in place, setting this false or {isSemVerMajor, version}.\n    this[_fixAvailable] = true\n    this.addAdvisory(advisory)\n    this.packument = advisory.packument\n    this.versions = advisory.versions\n  }\n\n  get fixAvailable () {\n    return this[_fixAvailable]\n  }\n\n  set fixAvailable (f) {\n    this[_fixAvailable] = f\n    // if there's a fix available for this at the top level, it means that\n    // it will also fix the vulns that led to it being there.  to get there,\n    // we set the vias to the most \"strict\" of fix availables.\n    // - false: no fix is available\n    // - {name, version, isSemVerMajor} fix requires -f, is semver major\n    // - {name, version} fix requires -f, not semver major\n    // - true: fix does not require -f\n    for (const v of this.via) {\n      // don't blow up on loops\n      if (v.fixAvailable === f) {\n        continue\n      }\n\n      if (f === false) {\n        v.fixAvailable = f\n      } else if (v.fixAvailable === true) {\n        v.fixAvailable = f\n      } else if (typeof f === 'object' && (\n        typeof v.fixAvailable !== 'object' || !v.fixAvailable.isSemVerMajor)) {\n        v.fixAvailable = f\n      }\n    }\n  }\n\n  get isDirect () {\n    for (const node of this.nodes.values()) {\n      for (const edge of node.edgesIn) {\n        if (edge.from.isProjectRoot || edge.from.isWorkspace) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  testSpec (spec) {\n    const specObj = npa(spec)\n    if (!specObj.registry) {\n      return true\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec\n    }\n\n    for (const v of this.versions) {\n      if (satisfies(v, spec) && !satisfies(v, this.range, semverOpt)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  toJSON () {\n    return {\n      name: this.name,\n      severity: this.severity,\n      isDirect: this.isDirect,\n      // just loop over the advisories, since via is only Vuln objects,\n      // and calculated advisories have all the info we need\n      via: [...this.advisories].map(v => v.type === 'metavuln' ? v.dependency : {\n        ...v,\n        versions: undefined,\n        vulnerableVersions: undefined,\n        id: undefined,\n      }).sort((a, b) =>\n        localeCompare(String(a.source || a), String(b.source || b))),\n      effects: [...this.effects].map(v => v.name).sort(localeCompare),\n      range: this.simpleRange,\n      nodes: [...this.nodes].map(n => n.location).sort(localeCompare),\n      fixAvailable: this[_fixAvailable],\n    }\n  }\n\n  addVia (v) {\n    this.via.add(v)\n    v.effects.add(this)\n    // call the setter since we might add vias _after_ setting fixAvailable\n    this.fixAvailable = this.fixAvailable\n  }\n\n  deleteVia (v) {\n    this.via.delete(v)\n    v.effects.delete(this)\n  }\n\n  deleteAdvisory (advisory) {\n    this.advisories.delete(advisory)\n    // make sure we have the max severity of all the vulns causing this one\n    this.severity = null\n    this[_range] = null\n    this[_simpleRange] = null\n    // refresh severity\n    for (const advisory of this.advisories) {\n      this.addAdvisory(advisory)\n    }\n\n    // remove any effects that are no longer relevant\n    const vias = new Set([...this.advisories].map(a => a.dependency))\n    for (const via of this.via) {\n      if (!vias.has(via.name)) {\n        this.deleteVia(via)\n      }\n    }\n  }\n\n  addAdvisory (advisory) {\n    this.advisories.add(advisory)\n    const sev = severities.get(advisory.severity)\n    this[_range] = null\n    this[_simpleRange] = null\n    if (sev > severities.get(this.severity)) {\n      this.severity = advisory.severity\n    }\n  }\n\n  get range () {\n    return this[_range] ||\n      (this[_range] = [...this.advisories].map(v => v.range).join(' || '))\n  }\n\n  get simpleRange () {\n    if (this[_simpleRange] && this[_simpleRange] === this[_range]) {\n      return this[_simpleRange]\n    }\n\n    const versions = [...this.advisories][0].versions\n    const range = this.range\n    const simple = simplifyRange(versions, range, semverOpt)\n    return this[_simpleRange] = this[_range] = simple\n  }\n\n  isVulnerable (node) {\n    if (this.nodes.has(node)) {\n      return true\n    }\n\n    const { version } = node.package\n    if (!version) {\n      return false\n    }\n\n    for (const v of this.advisories) {\n      if (v.testVersion(version)) {\n        this.nodes.add(node)\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Vuln\n"]},"metadata":{},"sourceType":"script"}