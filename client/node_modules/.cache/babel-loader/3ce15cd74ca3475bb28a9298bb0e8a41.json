{"ast":null,"code":"// mix-in implementing the loadActual method\nconst {\n  relative,\n  dirname,\n  resolve,\n  join,\n  normalize\n} = require('path');\n\nconst rpj = require('read-package-json-fast');\n\nconst {\n  promisify\n} = require('util');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst walkUp = require('walk-up-path');\n\nconst ancestorPath = require('common-ancestor-path');\n\nconst treeCheck = require('../tree-check.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst realpath = require('../realpath.js');\n\nconst _loadFSNode = Symbol('loadFSNode');\n\nconst _newNode = Symbol('newNode');\n\nconst _newLink = Symbol('newLink');\n\nconst _loadFSTree = Symbol('loadFSTree');\n\nconst _loadFSChildren = Symbol('loadFSChildren');\n\nconst _findMissingEdges = Symbol('findMissingEdges');\n\nconst _findFSParents = Symbol('findFSParents');\n\nconst _resetDepFlags = Symbol('resetDepFlags');\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _topNodes = Symbol('linkTargets');\n\nconst _cache = Symbol('nodeLoadingCache');\n\nconst _loadActual = Symbol('loadActual');\n\nconst _loadActualVirtually = Symbol('loadActualVirtually');\n\nconst _loadActualActually = Symbol('loadActualActually');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets');\n\nconst _actualTreePromise = Symbol('actualTreePromise');\n\nconst _actualTree = Symbol('actualTree');\n\nconst _transplant = Symbol('transplant');\n\nconst _transplantFilter = Symbol('transplantFilter');\n\nconst _filter = Symbol('filter');\n\nconst _global = Symbol.for('global');\n\nconst _changePath = Symbol.for('_changePath');\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor(options) {\n    super(options);\n    this[_global] = !!options.global; // the tree of nodes on disk\n\n    this.actualTree = options.actualTree; // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n\n    this[_actualTreeLoaded] = new Set(); // caches for cached realpath calls\n\n    const cwd = process.cwd(); // assume that the cwd is real enough for our purposes\n\n    this[_rpcache] = new Map([[cwd, cwd]]);\n    this[_stcache] = new Map(); // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n\n    this[_cache] = new Map(); // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n\n    this[_topNodes] = new Set();\n  }\n\n  [_resetDepFlags](tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true;\n      }\n    } // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n\n\n    calcDepFlags(tree, !root);\n    return tree;\n  } // public method\n\n\n  async loadActual(options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options,\n      ...options\n    }; // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n\n    return this.actualTree ? this.actualTree : this[_actualTreePromise] ? this[_actualTreePromise] : this[_actualTreePromise] = this[_loadActual](options).then(tree => this[_resetDepFlags](tree, options.root)).then(tree => this.actualTree = treeCheck(tree));\n  }\n\n  async [_loadActual](options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false\n    } = options;\n    this[_filter] = filter;\n    this[_transplantFilter] = transplantFilter;\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n      const newNodeOrLink = this.path === real ? _newNode : _newLink;\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global\n      });\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing,\n        global\n      });\n    } // not in global mode, hidden lockfile is allowed, load root pkg too\n\n\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache])\n    }); // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true\n    });\n\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta;\n      return this[_loadActualVirtually]({\n        root\n      });\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path\n      });\n      this[_actualTree].meta = meta;\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing\n      });\n    }\n  }\n\n  async [_loadActualVirtually]({\n    root\n  }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({ ...this.options\n    }).loadVirtual({\n      root: this[_actualTree]\n    });\n    await this[_loadWorkspaces](this[_actualTree]);\n\n    this[_transplant](root);\n\n    return this[_actualTree];\n  }\n\n  async [_loadActualActually]({\n    root,\n    ignoreMissing,\n    global\n  }) {\n    await this[_loadFSTree](this[_actualTree]);\n    await this[_loadWorkspaces](this[_actualTree]);\n    await this[_loadWorkspaceTargets](this[_actualTree]);\n\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]();\n    }\n\n    this[_findFSParents]();\n\n    this[_transplant](root);\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree];\n      const actualRoot = tree.isLink ? tree.target : tree;\n      const {\n        dependencies = {}\n      } = actualRoot.package;\n\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath}` : '*';\n        dependencies[name] = dependencies[name] || def;\n      }\n\n      actualRoot.package = { ...actualRoot.package,\n        dependencies\n      };\n    }\n\n    return this[_actualTree];\n  } // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n\n\n  async [_loadWorkspaceTargets](tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return;\n    }\n\n    const promises = [];\n\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({\n          path,\n          root: this[_actualTree]\n        }).then(node => this[_loadFSTree](node));\n\n        promises.push(p);\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n  [_transplant](root) {\n    if (!root || root === this[_actualTree]) {\n      return;\n    }\n\n    this[_actualTree][_changePath](root.path);\n\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null;\n      }\n    }\n\n    root.replace(this[_actualTree]);\n\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null;\n    }\n\n    this[_actualTree] = root;\n  }\n\n  [_loadFSNode]({\n    path,\n    parent,\n    real,\n    root\n  }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache]).then(real => this[_loadFSNode]({\n        path,\n        parent,\n        real,\n        root\n      }), // if realpath fails, just provide a dummy error node\n      error => new Node({\n        error,\n        path,\n        realpath: path,\n        parent,\n        root\n      }));\n    } // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n\n\n    const cached = this[_cache].get(path);\n\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent;\n        return node;\n      });\n    }\n\n    const p = rpj(join(real, 'package.json')) // soldier on if read-package-json raises an error\n    .then(pkg => [pkg, null], error => [null, error]).then(([pkg, error]) => {\n      return this[normalize(path) === real ? _newNode : _newLink]({\n        legacyPeerDeps: this.legacyPeerDeps,\n        path,\n        realpath: real,\n        pkg,\n        error,\n        parent,\n        root\n      });\n    }).then(node => {\n      this[_cache].set(path, node);\n\n      return node;\n    });\n\n    this[_cache].set(path, p);\n\n    return p;\n  } // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n\n\n  [_newNode](options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const {\n      parent,\n      realpath\n    } = options;\n\n    if (!parent) {\n      this[_topNodes].add(realpath);\n    }\n\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1' ? new Promise(res => setTimeout(() => res(new Node(options)), 100)) : new Node(options);\n  }\n\n  [_newLink](options) {\n    const {\n      realpath\n    } = options;\n\n    this[_topNodes].add(realpath);\n\n    const target = this[_cache].get(realpath);\n\n    const link = new Link({ ...options,\n      target\n    });\n\n    if (!target) {\n      this[_cache].set(realpath, link.target); // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n\n\n      return this[_loadFSTree](link.target).then(() => link);\n    } else if (target.then) {\n      target.then(node => link.target = node);\n    }\n\n    return link;\n  }\n\n  [_loadFSTree](node) {\n    const did = this[_actualTreeLoaded];\n    node = node.target; // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node));\n    } // impossible except in pathological ELOOP cases\n\n    /* istanbul ignore if */\n\n\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node);\n    }\n\n    did.add(node.realpath);\n    return this[_loadFSChildren](node).then(() => Promise.all([...node.children.entries()].filter(([name, kid]) => !did.has(kid.realpath)).map(([name, kid]) => this[_loadFSTree](kid))));\n  } // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n\n\n  [_loadFSChildren](node) {\n    const nm = resolve(node.realpath, 'node_modules');\n    return readdir(nm).then(kids => {\n      return Promise.all( // ignore . dirs and retired scoped package folders\n      kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid)).filter(kid => this[_filter](node, kid)).map(kid => this[_loadFSNode]({\n        parent: node,\n        path: resolve(nm, kid)\n      })));\n    }, // error in the readdir is not fatal, just means no kids\n    () => {});\n  }\n\n  async [_findMissingEdges]() {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map();\n    const tree = this[_actualTree];\n\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path);\n      const depPromises = [];\n\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node));\n\n        if (notMissing) {\n          continue;\n        } // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n\n\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break;\n          }\n\n          const entries = nmContents.get(p) || (await readdir(p + '/node_modules').catch(() => []));\n          nmContents.set(p, entries);\n\n          if (!entries.includes(name)) {\n            continue;\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p) : new Node({\n            path: p,\n            root: node.root,\n            dummy: true\n          });\n\n          this[_cache].set(p, d);\n\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`;\n\n            const cached = this[_cache].get(depPath);\n\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d\n              }).then(node => this[_loadFSTree](node)));\n            }\n          }\n\n          break;\n        }\n      }\n\n      await Promise.all(depPromises);\n    }\n  } // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n\n\n  [_findFSParents]() {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path);\n\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-actual.js"],"names":["relative","dirname","resolve","join","normalize","require","rpj","promisify","readdir","walkUp","ancestorPath","treeCheck","Shrinkwrap","calcDepFlags","Node","Link","realpath","_loadFSNode","Symbol","_newNode","_newLink","_loadFSTree","_loadFSChildren","_findMissingEdges","_findFSParents","_resetDepFlags","_actualTreeLoaded","_rpcache","for","_stcache","_topNodes","_cache","_loadActual","_loadActualVirtually","_loadActualActually","_loadWorkspaces","_loadWorkspaceTargets","_actualTreePromise","_actualTree","_transplant","_transplantFilter","_filter","_global","_changePath","module","exports","cls","ActualLoader","constructor","options","global","actualTree","Set","cwd","process","Map","tree","root","node","inventory","values","extraneous","loadActual","then","filter","transplantFilter","ignoreMissing","real","path","newNodeOrLink","pkg","meta","load","hiddenLockfile","loadedFromDisk","loadVirtual","actualRoot","isLink","target","dependencies","package","name","kid","children","entries","def","workspaces","size","promises","has","p","push","Promise","all","replace","fsChildren","parent","error","cached","get","dummy","legacyPeerDeps","set","add","env","_TEST_ARBORIST_SLOW_LINK_TARGET_","res","setTimeout","link","did","map","nm","kids","test","nmContents","ancestor","depPromises","edge","edgesOut","notMissing","missing","to","catch","includes","d","depPath","fsParent"],"mappings":"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","sourcesContent":["// mix-in implementing the loadActual method\n\nconst {relative, dirname, resolve, join, normalize} = require('path')\n\nconst rpj = require('read-package-json-fast')\nconst {promisify} = require('util')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst walkUp = require('walk-up-path')\nconst ancestorPath = require('common-ancestor-path')\nconst treeCheck = require('../tree-check.js')\n\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst realpath = require('../realpath.js')\n\nconst _loadFSNode = Symbol('loadFSNode')\nconst _newNode = Symbol('newNode')\nconst _newLink = Symbol('newLink')\nconst _loadFSTree = Symbol('loadFSTree')\nconst _loadFSChildren = Symbol('loadFSChildren')\nconst _findMissingEdges = Symbol('findMissingEdges')\nconst _findFSParents = Symbol('findFSParents')\nconst _resetDepFlags = Symbol('resetDepFlags')\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _topNodes = Symbol('linkTargets')\nconst _cache = Symbol('nodeLoadingCache')\nconst _loadActual = Symbol('loadActual')\nconst _loadActualVirtually = Symbol('loadActualVirtually')\nconst _loadActualActually = Symbol('loadActualActually')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets')\nconst _actualTreePromise = Symbol('actualTreePromise')\nconst _actualTree = Symbol('actualTree')\nconst _transplant = Symbol('transplant')\nconst _transplantFilter = Symbol('transplantFilter')\n\nconst _filter = Symbol('filter')\nconst _global = Symbol.for('global')\nconst _changePath = Symbol.for('_changePath')\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    this[_global] = !!options.global\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set()\n\n    // caches for cached realpath calls\n    const cwd = process.cwd()\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]])\n    this[_stcache] = new Map()\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map()\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set()\n  }\n\n  [_resetDepFlags] (tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true\n      }\n    }\n\n    // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n    calcDepFlags(tree, !root)\n    return tree\n  }\n\n  // public method\n  async loadActual (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree\n      : this[_actualTreePromise] ? this[_actualTreePromise]\n      : this[_actualTreePromise] = this[_loadActual](options)\n        .then(tree => this[_resetDepFlags](tree, options.root))\n        .then(tree => this.actualTree = treeCheck(tree))\n  }\n\n  async [_loadActual] (options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n    } = options\n    this[_filter] = filter\n    this[_transplantFilter] = transplantFilter\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache])\n      const newNodeOrLink = this.path === real ? _newNode : _newLink\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n      })\n      return this[_loadActualActually]({root, ignoreMissing, global})\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n    })\n\n    // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true,\n    })\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta\n      return this[_loadActualVirtually]({ root })\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n      })\n      this[_actualTree].meta = meta\n      return this[_loadActualActually]({ root, ignoreMissing })\n    }\n  }\n\n  async [_loadActualVirtually] ({ root }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({...this.options}).loadVirtual({\n      root: this[_actualTree],\n    })\n    await this[_loadWorkspaces](this[_actualTree])\n\n    this[_transplant](root)\n    return this[_actualTree]\n  }\n\n  async [_loadActualActually] ({ root, ignoreMissing, global }) {\n    await this[_loadFSTree](this[_actualTree])\n    await this[_loadWorkspaces](this[_actualTree])\n    await this[_loadWorkspaceTargets](this[_actualTree])\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]()\n    }\n    this[_findFSParents]()\n    this[_transplant](root)\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree]\n      const actualRoot = tree.isLink ? tree.target : tree\n      const { dependencies = {} } = actualRoot.package\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath}` : '*'\n        dependencies[name] = dependencies[name] || def\n      }\n      actualRoot.package = { ...actualRoot.package, dependencies }\n    }\n    return this[_actualTree]\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets] (tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return\n    }\n\n    const promises = []\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({ path, root: this[_actualTree] })\n          .then(node => this[_loadFSTree](node))\n        promises.push(p)\n      }\n    }\n    await Promise.all(promises)\n  }\n\n  [_transplant] (root) {\n    if (!root || root === this[_actualTree]) {\n      return\n    }\n\n    this[_actualTree][_changePath](root.path)\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null\n      }\n    }\n\n    root.replace(this[_actualTree])\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null\n    }\n\n    this[_actualTree] = root\n  }\n\n  [_loadFSNode] ({ path, parent, real, root }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache])\n        .then(\n          real => this[_loadFSNode]({ path, parent, real, root }),\n          // if realpath fails, just provide a dummy error node\n          error => new Node({ error, path, realpath: path, parent, root })\n        )\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path)\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent\n        return node\n      })\n    }\n\n    const p = rpj(join(real, 'package.json'))\n      // soldier on if read-package-json raises an error\n      .then(pkg => [pkg, null], error => [null, error])\n      .then(([pkg, error]) => {\n        return this[normalize(path) === real ? _newNode : _newLink]({\n          legacyPeerDeps: this.legacyPeerDeps,\n          path,\n          realpath: real,\n          pkg,\n          error,\n          parent,\n          root,\n        })\n      })\n      .then(node => {\n        this[_cache].set(path, node)\n        return node\n      })\n\n    this[_cache].set(path, p)\n    return p\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode] (options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const { parent, realpath } = options\n    if (!parent) {\n      this[_topNodes].add(realpath)\n    }\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1'\n      ? new Promise(res => setTimeout(() => res(new Node(options)), 100))\n      : new Node(options)\n  }\n\n  [_newLink] (options) {\n    const { realpath } = options\n    this[_topNodes].add(realpath)\n    const target = this[_cache].get(realpath)\n    const link = new Link({ ...options, target })\n\n    if (!target) {\n      this[_cache].set(realpath, link.target)\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link)\n    } else if (target.then) {\n      target.then(node => link.target = node)\n    }\n\n    return link\n  }\n\n  [_loadFSTree] (node) {\n    const did = this[_actualTreeLoaded]\n    node = node.target\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node))\n    }\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node)\n    }\n\n    did.add(node.realpath)\n    return this[_loadFSChildren](node)\n      .then(() => Promise.all(\n        [...node.children.entries()]\n          .filter(([name, kid]) => !did.has(kid.realpath))\n          .map(([name, kid]) => this[_loadFSTree](kid))))\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren] (node) {\n    const nm = resolve(node.realpath, 'node_modules')\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n        kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid))\n          .filter(kid => this[_filter](node, kid))\n          .map(kid => this[_loadFSNode]({\n            parent: node,\n            path: resolve(nm, kid),\n          })))\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {})\n  }\n\n  async [_findMissingEdges] () {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map()\n    const tree = this[_actualTree]\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path)\n\n      const depPromises = []\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing &&\n          !(edge.to && (edge.to.dummy || edge.to.parent !== node))\n        if (notMissing) {\n          continue\n        }\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break\n          }\n\n          const entries = nmContents.get(p) ||\n            await readdir(p + '/node_modules').catch(() => [])\n          nmContents.set(p, entries)\n          if (!entries.includes(name)) {\n            continue\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p)\n            : new Node({ path: p, root: node.root, dummy: true })\n          this[_cache].set(p, d)\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`\n            const cached = this[_cache].get(depPath)\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d,\n              }).then(node => this[_loadFSTree](node)))\n            }\n          }\n          break\n        }\n      }\n      await Promise.all(depPromises)\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents] () {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path)\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p)\n            break\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}