{"ast":null,"code":"// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst log = require('proc-log');\n\nconst deepestNestingTarget = require('./deepest-nesting-target.js');\n\nconst CanPlaceDep = require('./can-place-dep.js');\n\nconst {\n  KEEP,\n  CONFLICT\n} = CanPlaceDep;\n\nconst debug = require('./debug.js');\n\nconst Link = require('./link.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst peerEntrySets = require('./peer-entry-sets.js');\n\nclass PlaceDep {\n  constructor(options) {\n    const {\n      dep,\n      edge,\n      parent = null\n    } = options;\n    this.name = edge.name;\n    this.dep = dep;\n    this.edge = edge;\n    this.canPlace = null;\n    this.target = null;\n    this.placed = null; // inherit all these fields from the parent to ensure consistency.\n\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    } = parent || options;\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle\n    });\n    this.children = [];\n    this.parent = parent;\n    this.peerConflict = null;\n    this.needEvaluation = new Set();\n    this.checks = new Map();\n    this.place();\n  }\n\n  place() {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks\n    } = this; // nothing to do if the edge is fine as it is\n\n    if (edge.to && !edge.error && !explicitRequest && !updateNames.includes(edge.name) && !this.isVulnerable(edge.to)) {\n      return;\n    } // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n\n\n    const start = this.getStartNode();\n    let canPlace = null;\n    let canPlaceSelf = null;\n\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name);\n\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue;\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest\n      });\n      checks.set(target, cpd); // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd;\n      } // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n\n\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd;\n      } else {\n        break;\n      } // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n\n\n      if (dep.errors.length) {\n        break;\n      } // nest packages like npm v1 and v2\n      // very disk-inefficient\n\n\n      if (legacyBundling) {\n        break;\n      } // when installing globally, or just in global style, we never place\n      // deps above the first level.\n\n\n      if (globalStyle) {\n        const rp = target.resolveParent;\n\n        if (rp && rp.isProjectRoot) {\n          break;\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf\n    });\n    this.current = edge.to; // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict();\n      } // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n\n\n      if (!canPlaceSelf) {\n        this.warnPeerConflict();\n        return;\n      }\n\n      this.canPlace = canPlaceSelf;\n    } // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n\n\n    this.placeInTree();\n  }\n\n  placeInTree() {\n    const {\n      dep,\n      canPlace,\n      edge\n    } = this;\n    /* istanbul ignore next */\n\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree');\n      });\n      return;\n    }\n\n    const {\n      target\n    } = canPlace;\n    log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description, `for: ${this.edge.from.package._id || this.edge.from.location}`, `want: ${edge.spec || '*'}`);\n    const placementType = canPlace.canPlace === CONFLICT ? canPlace.canPlaceSelf : canPlace.canPlace; // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict();\n      } // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n\n\n      this.pruneDedupable(target);\n      return;\n    } // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n\n\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({\n          parent: target,\n          target: p\n        });\n        return;\n      }\n    } // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n\n    const virtualRoot = dep.parent;\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? {\n        target: dep.target,\n        realpath: dep.realpath\n      } : {})\n    });\n    this.oldDep = target.children.get(this.name);\n\n    if (this.oldDep) {\n      this.replaceOldDep();\n    } else {\n      this.placed.parent = target;\n    } // if it's an overridden peer dep, warn about it\n\n\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict();\n    } // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n\n\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false);\n    } // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n\n\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false); // only walk the direct children of the ones we kept\n\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false);\n          }\n        }\n      }\n    } // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n\n\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue;\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name); // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n\n      if (!peer) {\n        continue;\n      } // overridden peerEdge, just accept what's there already\n\n\n      if (!peer.satisfies(peerEdge)) {\n        continue;\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge\n      }));\n    }\n  }\n\n  replaceOldDep() {\n    const target = this.oldDep.parent; // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n\n    const oldDeps = [];\n\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n    } // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n\n\n    const prunePeerSets = [];\n\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) || !edge.peer || edge.from.parent !== target || edge.overridden) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue;\n      }\n\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as overridden and warned about.  If the entryEdge comes in from\n        // the root, then we have to leave it alone, and in that case, it\n        // will have already warned or crashed by getting to this point.\n        const entryNode = entryEdge.to;\n        const deepestTarget = deepestNestingTarget(entryNode);\n\n        if (deepestTarget !== target && !entryEdge.from.isRoot) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.overridden;\n          }));\n        } else {\n          this.warnPeerConflict(edge, this.dep);\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep);\n    this.pruneForReplacement(this.placed, oldDeps);\n\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from);\n      }\n\n      dep.root = null;\n    }\n  }\n\n  pruneForReplacement(node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n\n      for (const dep of set) {\n        invalidDeps.add(dep);\n      }\n    } // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n\n\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid); // now just delete whatever's left, because it's junk\n\n    for (const dep of deps) {\n      dep.root = null;\n    }\n  } // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n\n\n  pruneDedupable(node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid);\n\n      for (const node of deps) {\n        node.root = null;\n      }\n\n      return;\n    }\n\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location);\n\n      const children = [...node.children.values()].sort(nodeSort);\n\n      for (const child of children) {\n        this.pruneDedupable(child);\n      }\n\n      const fsChildren = [...node.fsChildren].sort(nodeSort);\n\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort);\n\n        for (const child of children) {\n          this.pruneDedupable(child);\n        }\n      }\n    }\n  }\n\n  get conflictOk() {\n    return this.force || !this.isMine && !this.strictPeerDeps;\n  }\n\n  get isMine() {\n    const {\n      edge\n    } = this.top;\n    const {\n      from: node\n    } = edge;\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true;\n    }\n\n    if (!edge.peer) {\n      return false;\n    } // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n\n\n    let hasPeerEdges = false;\n\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true;\n        continue;\n      }\n\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true;\n      }\n    }\n\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  warnPeerConflict(edge, dep) {\n    edge = edge || this.edge;\n    dep = dep || this.dep;\n    edge.overridden = true;\n    const expl = this.explainPeerConflict(edge, dep);\n    log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  }\n\n  failPeerConflict(edge, dep) {\n    edge = edge || this.top.edge;\n    dep = dep || this.top.dep;\n    const expl = this.explainPeerConflict(edge, dep);\n    throw Object.assign(new Error('could not resolve'), expl);\n  }\n\n  explainPeerConflict(edge, dep) {\n    const {\n      from: node\n    } = edge;\n    const curNode = node.resolve(edge.name);\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge)\n    };\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge);\n      expl.peerConflict = this.current && this.current.explain(this.edge);\n    } else {\n      expl.current = curNode && curNode.explain();\n\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf;\n\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge)\n            };\n            break;\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge)\n        };\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine\n    } = this;\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine\n    }); // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n\n    return expl;\n  }\n\n  getStartNode() {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from;\n    return deepestNestingTarget(from, this.name);\n  }\n\n  get top() {\n    return this.parent ? this.parent.top : this;\n  }\n\n  isVulnerable(node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  get allChildren() {\n    const set = new Set(this.children);\n\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild);\n      }\n    }\n\n    return [...set];\n  }\n\n}\n\nmodule.exports = PlaceDep;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/place-dep.js"],"names":["localeCompare","require","log","deepestNestingTarget","CanPlaceDep","KEEP","CONFLICT","debug","Link","gatherDepSet","peerEntrySets","PlaceDep","constructor","options","dep","edge","parent","name","canPlace","target","placed","preferDedupe","force","explicitRequest","updateNames","auditReport","legacyBundling","strictPeerDeps","legacyPeerDeps","globalStyle","Object","assign","children","peerConflict","needEvaluation","Set","checks","Map","place","to","error","includes","isVulnerable","start","getStartNode","canPlaceSelf","ancestry","targetEdge","edgesOut","get","isTop","peer","cpd","set","errors","length","rp","resolveParent","isProjectRoot","current","conflictOk","failPeerConflict","warnPeerConflict","placeInTree","Error","silly","location","version","description","from","package","_id","spec","placementType","valid","pruneDedupable","p","matches","virtualRoot","pkg","resolved","integrity","isLink","realpath","oldDep","replaceOldDep","satisfies","node","root","inventory","query","isDescendantOf","kid","values","peerEdge","overridden","push","oldDeps","entries","has","e","prunePeerSets","edgesIn","entryEdge","keys","entryNode","deepestTarget","isRoot","replace","pruneForReplacement","add","invalidDeps","filter","map","deps","descend","canDedupe","nodeSort","a","b","sort","child","fsChildren","topNode","isMine","top","isWorkspace","hasPeerEdges","expl","explainPeerConflict","warn","curNode","resolve","code","explain","cps","conflictChildren","allChildren","grandchild","module","exports"],"mappings":"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","sourcesContent":["// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst log = require('proc-log')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\nconst CanPlaceDep = require('./can-place-dep.js')\nconst {\n  KEEP,\n  CONFLICT,\n} = CanPlaceDep\nconst debug = require('./debug.js')\n\nconst Link = require('./link.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\n\nclass PlaceDep {\n  constructor (options) {\n    const {\n      dep,\n      edge,\n      parent = null,\n    } = options\n    this.name = edge.name\n    this.dep = dep\n    this.edge = edge\n    this.canPlace = null\n\n    this.target = null\n    this.placed = null\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    } = parent || options\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    })\n\n    this.children = []\n    this.parent = parent\n    this.peerConflict = null\n\n    this.needEvaluation = new Set()\n\n    this.checks = new Map()\n\n    this.place()\n  }\n\n  place () {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks,\n    } = this\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to &&\n        !edge.error &&\n        !explicitRequest &&\n        !updateNames.includes(edge.name) &&\n        !this.isVulnerable(edge.to)) {\n      return\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode()\n\n    let canPlace = null\n    let canPlaceSelf = null\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name)\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest,\n      })\n      checks.set(target, cpd)\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd\n      } else {\n        break\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent\n        if (rp && rp.isProjectRoot) {\n          break\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf,\n    })\n    this.current = edge.to\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict()\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict()\n        return\n      }\n\n      this.canPlace = canPlaceSelf\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree()\n  }\n\n  placeInTree () {\n    const {\n      dep,\n      canPlace,\n      edge,\n    } = this\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree')\n      })\n      return\n    }\n\n    const { target } = canPlace\n\n    log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description,\n      `for: ${this.edge.from.package._id || this.edge.from.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    const placementType = canPlace.canPlace === CONFLICT\n      ? canPlace.canPlaceSelf\n      : canPlace.canPlace\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was an overridden peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict()\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target)\n      return\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({ parent: target, target: p })\n        return\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.isLink ? { target: dep.target, realpath: dep.realpath } : {}),\n    })\n\n    this.oldDep = target.children.get(this.name)\n    if (this.oldDep) {\n      this.replaceOldDep()\n    } else {\n      this.placed.parent = target\n    }\n\n    // if it's an overridden peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict()\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false)\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false)\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false)\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.overridden) {\n        continue\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue\n      }\n\n      // overridden peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge,\n      }))\n    }\n  }\n\n  replaceOldDep () {\n    const target = this.oldDep.parent\n\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = []\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n    }\n\n    // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n    const prunePeerSets = []\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) ||\n          !edge.peer ||\n          edge.from.parent !== target ||\n          edge.overridden) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue\n      }\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as overridden and warned about.  If the entryEdge comes in from\n        // the root, then we have to leave it alone, and in that case, it\n        // will have already warned or crashed by getting to this point.\n        const entryNode = entryEdge.to\n        const deepestTarget = deepestNestingTarget(entryNode)\n        if (deepestTarget !== target && !entryEdge.from.isRoot) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.overridden\n          }))\n        } else {\n          this.warnPeerConflict(edge, this.dep)\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep)\n    this.pruneForReplacement(this.placed, oldDeps)\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from)\n      }\n      dep.root = null\n    }\n  }\n\n  pruneForReplacement (node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set) {\n        invalidDeps.add(dep)\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable (node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid)\n      for (const node of deps) {\n        node.root = null\n      }\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location)\n\n      const children = [...node.children.values()].sort(nodeSort)\n      for (const child of children) {\n        this.pruneDedupable(child)\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children) {\n          this.pruneDedupable(child)\n        }\n      }\n    }\n  }\n\n  get conflictOk () {\n    return this.force || (!this.isMine && !this.strictPeerDeps)\n  }\n\n  get isMine () {\n    const { edge } = this.top\n    const { from: node } = edge\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true\n    }\n\n    if (!edge.peer) {\n      return false\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true\n        continue\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  warnPeerConflict (edge, dep) {\n    edge = edge || this.edge\n    dep = dep || this.dep\n    edge.overridden = true\n    const expl = this.explainPeerConflict(edge, dep)\n    log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  failPeerConflict (edge, dep) {\n    edge = edge || this.top.edge\n    dep = dep || this.top.dep\n    const expl = this.explainPeerConflict(edge, dep)\n    throw Object.assign(new Error('could not resolve'), expl)\n  }\n\n  explainPeerConflict (edge, dep) {\n    const { from: node } = edge\n    const curNode = node.resolve(edge.name)\n\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge),\n    }\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge)\n      expl.peerConflict = this.current && this.current.explain(this.edge)\n    } else {\n      expl.current = curNode && curNode.explain()\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge),\n            }\n            break\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge),\n        }\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine,\n    } = this\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine,\n    })\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl\n  }\n\n  getStartNode () {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from\n    return deepestNestingTarget(from, this.name)\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  isVulnerable (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n}\n\nmodule.exports = PlaceDep\n"]},"metadata":{},"sourceType":"script"}