{"ast":null,"code":"const objectAssign = require('object-assign');\n\nconst Cell = require('./cell');\n\nconst {\n  ColSpanCell,\n  RowSpanCell\n} = Cell;\n\n(function () {\n  function layoutTable(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell, columnIndex) {\n        cell.y = rowIndex;\n        cell.x = columnIndex;\n\n        for (let y = rowIndex; y >= 0; y--) {\n          let row2 = table[y];\n          let xMax = y === rowIndex ? columnIndex : row2.length;\n\n          for (let x = 0; x < xMax; x++) {\n            let cell2 = row2[x];\n\n            while (cellsConflict(cell, cell2)) {\n              cell.x++;\n            }\n          }\n        }\n      });\n    });\n  }\n\n  function maxWidth(table) {\n    let mw = 0;\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        mw = Math.max(mw, cell.x + (cell.colSpan || 1));\n      });\n    });\n    return mw;\n  }\n\n  function maxHeight(table) {\n    return table.length;\n  }\n\n  function cellsConflict(cell1, cell2) {\n    let yMin1 = cell1.y;\n    let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);\n    let yMin2 = cell2.y;\n    let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);\n    let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);\n    let xMin1 = cell1.x;\n    let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);\n    let xMin2 = cell2.x;\n    let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);\n    let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);\n    return yConflict && xConflict;\n  }\n\n  function conflictExists(rows, x, y) {\n    let i_max = Math.min(rows.length - 1, y);\n    let cell = {\n      x: x,\n      y: y\n    };\n\n    for (let i = 0; i <= i_max; i++) {\n      let row = rows[i];\n\n      for (let j = 0; j < row.length; j++) {\n        if (cellsConflict(cell, row[j])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function allBlank(rows, y, xMin, xMax) {\n    for (let x = xMin; x < xMax; x++) {\n      if (conflictExists(rows, x, y)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function addRowSpanCells(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell) {\n        for (let i = 1; i < cell.rowSpan; i++) {\n          let rowSpanCell = new RowSpanCell(cell);\n          rowSpanCell.x = cell.x;\n          rowSpanCell.y = cell.y + i;\n          rowSpanCell.colSpan = cell.colSpan;\n          insertCell(rowSpanCell, table[rowIndex + i]);\n        }\n      });\n    });\n  }\n\n  function addColSpanCells(cellRows) {\n    for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {\n      let cellColumns = cellRows[rowIndex];\n\n      for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {\n        let cell = cellColumns[columnIndex];\n\n        for (let k = 1; k < cell.colSpan; k++) {\n          let colSpanCell = new ColSpanCell();\n          colSpanCell.x = cell.x + k;\n          colSpanCell.y = cell.y;\n          cellColumns.splice(columnIndex + 1, 0, colSpanCell);\n        }\n      }\n    }\n  }\n\n  function insertCell(cell, row) {\n    let x = 0;\n\n    while (x < row.length && row[x].x < cell.x) {\n      x++;\n    }\n\n    row.splice(x, 0, cell);\n  }\n\n  function fillInTable(table) {\n    let h_max = maxHeight(table);\n    let w_max = maxWidth(table);\n\n    for (let y = 0; y < h_max; y++) {\n      for (let x = 0; x < w_max; x++) {\n        if (!conflictExists(table, x, y)) {\n          let opts = {\n            x: x,\n            y: y,\n            colSpan: 1,\n            rowSpan: 1\n          };\n          x++;\n\n          while (x < w_max && !conflictExists(table, x, y)) {\n            opts.colSpan++;\n            x++;\n          }\n\n          let y2 = y + 1;\n\n          while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {\n            opts.rowSpan++;\n            y2++;\n          }\n\n          let cell = new Cell(opts);\n          cell.x = opts.x;\n          cell.y = opts.y;\n          insertCell(cell, table[y]);\n        }\n      }\n    }\n  }\n\n  function generateCells(rows) {\n    return rows.map(function (row) {\n      if (!Array.isArray(row)) {\n        let key = Object.keys(row)[0];\n        row = row[key];\n\n        if (Array.isArray(row)) {\n          row = row.slice();\n          row.unshift(key);\n        } else {\n          row = [key, row];\n        }\n      }\n\n      return row.map(function (cell) {\n        return new Cell(cell);\n      });\n    });\n  }\n\n  function makeTableLayout(rows) {\n    let cellRows = generateCells(rows);\n    layoutTable(cellRows);\n    fillInTable(cellRows);\n    addRowSpanCells(cellRows);\n    addColSpanCells(cellRows);\n    return cellRows;\n  }\n\n  module.exports = {\n    makeTableLayout: makeTableLayout,\n    layoutTable: layoutTable,\n    addRowSpanCells: addRowSpanCells,\n    maxWidth: maxWidth,\n    fillInTable: fillInTable,\n    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),\n    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1)\n  };\n})();\n\nfunction makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {\n  return function (vals, table) {\n    let result = [];\n    let spanners = [];\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        if ((cell[colSpan] || 1) > 1) {\n          spanners.push(cell);\n        } else {\n          result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);\n        }\n      });\n    });\n    vals.forEach(function (val, index) {\n      if (typeof val === 'number') {\n        result[index] = val;\n      }\n    }); //spanners.forEach(function(cell){\n\n    for (let k = spanners.length - 1; k >= 0; k--) {\n      let cell = spanners[k];\n      let span = cell[colSpan];\n      let col = cell[x];\n      let existingWidth = result[col];\n      let editableCols = typeof vals[col] === 'number' ? 0 : 1;\n\n      for (let i = 1; i < span; i++) {\n        existingWidth += 1 + result[col + i];\n\n        if (typeof vals[col + i] !== 'number') {\n          editableCols++;\n        }\n      }\n\n      if (cell[desiredWidth] > existingWidth) {\n        let i = 0;\n\n        while (editableCols > 0 && cell[desiredWidth] > existingWidth) {\n          if (typeof vals[col + i] !== 'number') {\n            let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);\n            existingWidth += dif;\n            result[col + i] += dif;\n            editableCols--;\n          }\n\n          i++;\n        }\n      }\n    }\n\n    objectAssign(vals, result);\n\n    for (let j = 0; j < vals.length; j++) {\n      vals[j] = Math.max(forcedMin, vals[j] || 0);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/cli-table3/src/layout-manager.js"],"names":["objectAssign","require","Cell","ColSpanCell","RowSpanCell","layoutTable","table","forEach","row","rowIndex","cell","columnIndex","y","x","row2","xMax","length","cell2","cellsConflict","maxWidth","mw","Math","max","colSpan","maxHeight","cell1","yMin1","yMax1","rowSpan","yMin2","yMax2","yConflict","xMin1","xMax1","xMin2","xMax2","xConflict","conflictExists","rows","i_max","min","i","j","allBlank","xMin","addRowSpanCells","rowSpanCell","insertCell","addColSpanCells","cellRows","cellColumns","k","colSpanCell","splice","fillInTable","h_max","w_max","opts","y2","generateCells","map","Array","isArray","key","Object","keys","slice","unshift","makeTableLayout","module","exports","computeWidths","makeComputeWidths","computeHeights","desiredWidth","forcedMin","vals","result","spanners","push","val","index","span","col","existingWidth","editableCols","dif","round"],"mappings":"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","sourcesContent":["const objectAssign = require('object-assign');\nconst Cell = require('./cell');\nconst { ColSpanCell, RowSpanCell } = Cell;\n\n(function () {\n  function layoutTable(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell, columnIndex) {\n        cell.y = rowIndex;\n        cell.x = columnIndex;\n        for (let y = rowIndex; y >= 0; y--) {\n          let row2 = table[y];\n          let xMax = y === rowIndex ? columnIndex : row2.length;\n          for (let x = 0; x < xMax; x++) {\n            let cell2 = row2[x];\n            while (cellsConflict(cell, cell2)) {\n              cell.x++;\n            }\n          }\n        }\n      });\n    });\n  }\n\n  function maxWidth(table) {\n    let mw = 0;\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        mw = Math.max(mw, cell.x + (cell.colSpan || 1));\n      });\n    });\n    return mw;\n  }\n\n  function maxHeight(table) {\n    return table.length;\n  }\n\n  function cellsConflict(cell1, cell2) {\n    let yMin1 = cell1.y;\n    let yMax1 = cell1.y - 1 + (cell1.rowSpan || 1);\n    let yMin2 = cell2.y;\n    let yMax2 = cell2.y - 1 + (cell2.rowSpan || 1);\n    let yConflict = !(yMin1 > yMax2 || yMin2 > yMax1);\n\n    let xMin1 = cell1.x;\n    let xMax1 = cell1.x - 1 + (cell1.colSpan || 1);\n    let xMin2 = cell2.x;\n    let xMax2 = cell2.x - 1 + (cell2.colSpan || 1);\n    let xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);\n\n    return yConflict && xConflict;\n  }\n\n  function conflictExists(rows, x, y) {\n    let i_max = Math.min(rows.length - 1, y);\n    let cell = { x: x, y: y };\n    for (let i = 0; i <= i_max; i++) {\n      let row = rows[i];\n      for (let j = 0; j < row.length; j++) {\n        if (cellsConflict(cell, row[j])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  function allBlank(rows, y, xMin, xMax) {\n    for (let x = xMin; x < xMax; x++) {\n      if (conflictExists(rows, x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function addRowSpanCells(table) {\n    table.forEach(function (row, rowIndex) {\n      row.forEach(function (cell) {\n        for (let i = 1; i < cell.rowSpan; i++) {\n          let rowSpanCell = new RowSpanCell(cell);\n          rowSpanCell.x = cell.x;\n          rowSpanCell.y = cell.y + i;\n          rowSpanCell.colSpan = cell.colSpan;\n          insertCell(rowSpanCell, table[rowIndex + i]);\n        }\n      });\n    });\n  }\n\n  function addColSpanCells(cellRows) {\n    for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {\n      let cellColumns = cellRows[rowIndex];\n      for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {\n        let cell = cellColumns[columnIndex];\n        for (let k = 1; k < cell.colSpan; k++) {\n          let colSpanCell = new ColSpanCell();\n          colSpanCell.x = cell.x + k;\n          colSpanCell.y = cell.y;\n          cellColumns.splice(columnIndex + 1, 0, colSpanCell);\n        }\n      }\n    }\n  }\n\n  function insertCell(cell, row) {\n    let x = 0;\n    while (x < row.length && row[x].x < cell.x) {\n      x++;\n    }\n    row.splice(x, 0, cell);\n  }\n\n  function fillInTable(table) {\n    let h_max = maxHeight(table);\n    let w_max = maxWidth(table);\n    for (let y = 0; y < h_max; y++) {\n      for (let x = 0; x < w_max; x++) {\n        if (!conflictExists(table, x, y)) {\n          let opts = { x: x, y: y, colSpan: 1, rowSpan: 1 };\n          x++;\n          while (x < w_max && !conflictExists(table, x, y)) {\n            opts.colSpan++;\n            x++;\n          }\n          let y2 = y + 1;\n          while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) {\n            opts.rowSpan++;\n            y2++;\n          }\n\n          let cell = new Cell(opts);\n          cell.x = opts.x;\n          cell.y = opts.y;\n          insertCell(cell, table[y]);\n        }\n      }\n    }\n  }\n\n  function generateCells(rows) {\n    return rows.map(function (row) {\n      if (!Array.isArray(row)) {\n        let key = Object.keys(row)[0];\n        row = row[key];\n        if (Array.isArray(row)) {\n          row = row.slice();\n          row.unshift(key);\n        } else {\n          row = [key, row];\n        }\n      }\n      return row.map(function (cell) {\n        return new Cell(cell);\n      });\n    });\n  }\n\n  function makeTableLayout(rows) {\n    let cellRows = generateCells(rows);\n    layoutTable(cellRows);\n    fillInTable(cellRows);\n    addRowSpanCells(cellRows);\n    addColSpanCells(cellRows);\n    return cellRows;\n  }\n\n  module.exports = {\n    makeTableLayout: makeTableLayout,\n    layoutTable: layoutTable,\n    addRowSpanCells: addRowSpanCells,\n    maxWidth: maxWidth,\n    fillInTable: fillInTable,\n    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),\n    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1),\n  };\n})();\n\nfunction makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {\n  return function (vals, table) {\n    let result = [];\n    let spanners = [];\n    table.forEach(function (row) {\n      row.forEach(function (cell) {\n        if ((cell[colSpan] || 1) > 1) {\n          spanners.push(cell);\n        } else {\n          result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);\n        }\n      });\n    });\n\n    vals.forEach(function (val, index) {\n      if (typeof val === 'number') {\n        result[index] = val;\n      }\n    });\n\n    //spanners.forEach(function(cell){\n    for (let k = spanners.length - 1; k >= 0; k--) {\n      let cell = spanners[k];\n      let span = cell[colSpan];\n      let col = cell[x];\n      let existingWidth = result[col];\n      let editableCols = typeof vals[col] === 'number' ? 0 : 1;\n      for (let i = 1; i < span; i++) {\n        existingWidth += 1 + result[col + i];\n        if (typeof vals[col + i] !== 'number') {\n          editableCols++;\n        }\n      }\n      if (cell[desiredWidth] > existingWidth) {\n        let i = 0;\n        while (editableCols > 0 && cell[desiredWidth] > existingWidth) {\n          if (typeof vals[col + i] !== 'number') {\n            let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);\n            existingWidth += dif;\n            result[col + i] += dif;\n            editableCols--;\n          }\n          i++;\n        }\n      }\n    }\n\n    objectAssign(vals, result);\n    for (let j = 0; j < vals.length; j++) {\n      vals[j] = Math.max(forcedMin, vals[j] || 0);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}