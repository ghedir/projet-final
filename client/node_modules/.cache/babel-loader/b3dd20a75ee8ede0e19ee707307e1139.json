{"ast":null,"code":"const path = require('path');\n\nconst libaccess = require('libnpmaccess');\n\nconst readPackageJson = require('read-package-json-fast');\n\nconst otplease = require('./utils/otplease.js');\n\nconst getIdentity = require('./utils/get-identity.js');\n\nconst BaseCommand = require('./base-command.js');\n\nconst subcommands = ['public', 'restricted', 'grant', 'revoke', 'ls-packages', 'ls-collaborators', 'edit', '2fa-required', '2fa-not-required'];\n\nclass Access extends BaseCommand {\n  static get description() {\n    return 'Set access level on published packages';\n  }\n\n  static get name() {\n    return 'access';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['registry', 'otp'];\n  }\n\n  static get usage() {\n    return ['public [<package>]', 'restricted [<package>]', 'grant <read-only|read-write> <scope:team> [<package>]', 'revoke <scope:team> [<package>]', '2fa-required [<package>]', '2fa-not-required [<package>]', 'ls-packages [<user>|<scope>|<scope:team>]', 'ls-collaborators [<package> [<user>]]', 'edit [<package>]'];\n  }\n\n  async completion(opts) {\n    const argv = opts.conf.argv.remain;\n    if (argv.length === 2) return subcommands;\n\n    switch (argv[2]) {\n      case 'grant':\n        if (argv.length === 3) return ['read-only', 'read-write'];else return [];\n\n      case 'public':\n      case 'restricted':\n      case 'ls-packages':\n      case 'ls-collaborators':\n      case 'edit':\n      case '2fa-required':\n      case '2fa-not-required':\n      case 'revoke':\n        return [];\n\n      default:\n        throw new Error(argv[2] + ' not recognized');\n    }\n  }\n\n  exec(args, cb) {\n    this.access(args).then(() => cb()).catch(cb);\n  }\n\n  async access([cmd, ...args]) {\n    if (!cmd) throw this.usageError('Subcommand is required.');\n    if (!subcommands.includes(cmd) || !this[cmd]) throw this.usageError(`${cmd} is not a recognized subcommand.`);\n    return this[cmd](args, this.npm.flatOptions);\n  }\n\n  public([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.public);\n  }\n\n  restricted([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.restricted);\n  }\n\n  async grant([perms, scopeteam, pkg], opts) {\n    if (!perms || perms !== 'read-only' && perms !== 'read-write') throw this.usageError('First argument must be either `read-only` or `read-write`.');\n    if (!scopeteam) throw this.usageError('`<scope:team>` argument is required.');\n    const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];\n\n    if (!scope && !team) {\n      throw this.usageError('Second argument used incorrect format.\\n' + 'Example: @example:developers');\n    }\n\n    return this.modifyPackage(pkg, opts, (pkgName, opts) => libaccess.grant(pkgName, scopeteam, perms, opts), false);\n  }\n\n  async revoke([scopeteam, pkg], opts) {\n    if (!scopeteam) throw this.usageError('`<scope:team>` argument is required.');\n    const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];\n\n    if (!scope || !team) {\n      throw this.usageError('First argument used incorrect format.\\n' + 'Example: @example:developers');\n    }\n\n    return this.modifyPackage(pkg, opts, (pkgName, opts) => libaccess.revoke(pkgName, scopeteam, opts));\n  }\n\n  get ['2fa-required']() {\n    return this.tfaRequired;\n  }\n\n  tfaRequired([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.tfaRequired, false);\n  }\n\n  get ['2fa-not-required']() {\n    return this.tfaNotRequired;\n  }\n\n  tfaNotRequired([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.tfaNotRequired, false);\n  }\n\n  get ['ls-packages']() {\n    return this.lsPackages;\n  }\n\n  async lsPackages([owner], opts) {\n    if (!owner) owner = await getIdentity(this.npm, opts);\n    const pkgs = await libaccess.lsPackages(owner, opts); // TODO - print these out nicely (breaking change)\n\n    this.npm.output(JSON.stringify(pkgs, null, 2));\n  }\n\n  get ['ls-collaborators']() {\n    return this.lsCollaborators;\n  }\n\n  async lsCollaborators([pkg, usr], opts) {\n    const pkgName = await this.getPackage(pkg, false);\n    const collabs = await libaccess.lsCollaborators(pkgName, usr, opts); // TODO - print these out nicely (breaking change)\n\n    this.npm.output(JSON.stringify(collabs, null, 2));\n  }\n\n  async edit() {\n    throw new Error('edit subcommand is not implemented yet');\n  }\n\n  modifyPackage(pkg, opts, fn, requireScope = true) {\n    return this.getPackage(pkg, requireScope).then(pkgName => otplease(opts, opts => fn(pkgName, opts)));\n  }\n\n  async getPackage(name, requireScope) {\n    if (name && name.trim()) return name.trim();else {\n      try {\n        const pkg = await readPackageJson(path.resolve(this.npm.prefix, 'package.json'));\n        name = pkg.name;\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          throw new Error('no package name passed to command and no package.json found');\n        } else throw err;\n      }\n\n      if (requireScope && !name.match(/^@[^/]+\\/.*$/)) throw this.usageError('This command is only available for scoped packages.');else return name;\n    }\n  }\n\n}\n\nmodule.exports = Access;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/access.js"],"names":["path","require","libaccess","readPackageJson","otplease","getIdentity","BaseCommand","subcommands","Access","description","name","params","usage","completion","opts","argv","conf","remain","length","Error","exec","args","cb","access","then","catch","cmd","usageError","includes","npm","flatOptions","public","pkg","modifyPackage","restricted","grant","perms","scopeteam","scope","team","match","pkgName","revoke","tfaRequired","tfaNotRequired","lsPackages","owner","pkgs","output","JSON","stringify","lsCollaborators","usr","getPackage","collabs","edit","fn","requireScope","trim","resolve","prefix","err","code","module","exports"],"mappings":"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","sourcesContent":["const path = require('path')\n\nconst libaccess = require('libnpmaccess')\nconst readPackageJson = require('read-package-json-fast')\n\nconst otplease = require('./utils/otplease.js')\nconst getIdentity = require('./utils/get-identity.js')\nconst BaseCommand = require('./base-command.js')\n\nconst subcommands = [\n  'public',\n  'restricted',\n  'grant',\n  'revoke',\n  'ls-packages',\n  'ls-collaborators',\n  'edit',\n  '2fa-required',\n  '2fa-not-required',\n]\n\nclass Access extends BaseCommand {\n  static get description () {\n    return 'Set access level on published packages'\n  }\n\n  static get name () {\n    return 'access'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'registry',\n      'otp',\n    ]\n  }\n\n  static get usage () {\n    return [\n      'public [<package>]',\n      'restricted [<package>]',\n      'grant <read-only|read-write> <scope:team> [<package>]',\n      'revoke <scope:team> [<package>]',\n      '2fa-required [<package>]',\n      '2fa-not-required [<package>]',\n      'ls-packages [<user>|<scope>|<scope:team>]',\n      'ls-collaborators [<package> [<user>]]',\n      'edit [<package>]',\n    ]\n  }\n\n  async completion (opts) {\n    const argv = opts.conf.argv.remain\n    if (argv.length === 2)\n      return subcommands\n\n    switch (argv[2]) {\n      case 'grant':\n        if (argv.length === 3)\n          return ['read-only', 'read-write']\n        else\n          return []\n\n      case 'public':\n      case 'restricted':\n      case 'ls-packages':\n      case 'ls-collaborators':\n      case 'edit':\n      case '2fa-required':\n      case '2fa-not-required':\n      case 'revoke':\n        return []\n      default:\n        throw new Error(argv[2] + ' not recognized')\n    }\n  }\n\n  exec (args, cb) {\n    this.access(args).then(() => cb()).catch(cb)\n  }\n\n  async access ([cmd, ...args]) {\n    if (!cmd)\n      throw this.usageError('Subcommand is required.')\n\n    if (!subcommands.includes(cmd) || !this[cmd])\n      throw this.usageError(`${cmd} is not a recognized subcommand.`)\n\n    return this[cmd](args, this.npm.flatOptions)\n  }\n\n  public ([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.public)\n  }\n\n  restricted ([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.restricted)\n  }\n\n  async grant ([perms, scopeteam, pkg], opts) {\n    if (!perms || (perms !== 'read-only' && perms !== 'read-write'))\n      throw this.usageError('First argument must be either `read-only` or `read-write`.')\n\n    if (!scopeteam)\n      throw this.usageError('`<scope:team>` argument is required.')\n\n    const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || []\n\n    if (!scope && !team) {\n      throw this.usageError(\n        'Second argument used incorrect format.\\n' +\n        'Example: @example:developers'\n      )\n    }\n\n    return this.modifyPackage(pkg, opts, (pkgName, opts) =>\n      libaccess.grant(pkgName, scopeteam, perms, opts), false)\n  }\n\n  async revoke ([scopeteam, pkg], opts) {\n    if (!scopeteam)\n      throw this.usageError('`<scope:team>` argument is required.')\n\n    const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || []\n\n    if (!scope || !team) {\n      throw this.usageError(\n        'First argument used incorrect format.\\n' +\n        'Example: @example:developers'\n      )\n    }\n\n    return this.modifyPackage(pkg, opts, (pkgName, opts) =>\n      libaccess.revoke(pkgName, scopeteam, opts))\n  }\n\n  get ['2fa-required'] () {\n    return this.tfaRequired\n  }\n\n  tfaRequired ([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.tfaRequired, false)\n  }\n\n  get ['2fa-not-required'] () {\n    return this.tfaNotRequired\n  }\n\n  tfaNotRequired ([pkg], opts) {\n    return this.modifyPackage(pkg, opts, libaccess.tfaNotRequired, false)\n  }\n\n  get ['ls-packages'] () {\n    return this.lsPackages\n  }\n\n  async lsPackages ([owner], opts) {\n    if (!owner)\n      owner = await getIdentity(this.npm, opts)\n\n    const pkgs = await libaccess.lsPackages(owner, opts)\n\n    // TODO - print these out nicely (breaking change)\n    this.npm.output(JSON.stringify(pkgs, null, 2))\n  }\n\n  get ['ls-collaborators'] () {\n    return this.lsCollaborators\n  }\n\n  async lsCollaborators ([pkg, usr], opts) {\n    const pkgName = await this.getPackage(pkg, false)\n    const collabs = await libaccess.lsCollaborators(pkgName, usr, opts)\n\n    // TODO - print these out nicely (breaking change)\n    this.npm.output(JSON.stringify(collabs, null, 2))\n  }\n\n  async edit () {\n    throw new Error('edit subcommand is not implemented yet')\n  }\n\n  modifyPackage (pkg, opts, fn, requireScope = true) {\n    return this.getPackage(pkg, requireScope)\n      .then(pkgName => otplease(opts, opts => fn(pkgName, opts)))\n  }\n\n  async getPackage (name, requireScope) {\n    if (name && name.trim())\n      return name.trim()\n    else {\n      try {\n        const pkg = await readPackageJson(path.resolve(this.npm.prefix, 'package.json'))\n        name = pkg.name\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          throw new Error(\n            'no package name passed to command and no package.json found'\n          )\n        } else\n          throw err\n      }\n\n      if (requireScope && !name.match(/^@[^/]+\\/.*$/))\n        throw this.usageError('This command is only available for scoped packages.')\n      else\n        return name\n    }\n  }\n}\n\nmodule.exports = Access\n"]},"metadata":{},"sourceType":"script"}