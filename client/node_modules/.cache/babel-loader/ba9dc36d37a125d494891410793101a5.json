{"ast":null,"code":"'use strict';\n\nconst npa = require('npm-package-arg');\n\nconst semver = require('semver');\n\nconst {\n  checkEngine\n} = require('npm-install-checks');\n\nconst normalizeBin = require('npm-normalize-package-bin');\n\nconst engineOk = (manifest, npmVersion, nodeVersion) => {\n  try {\n    checkEngine(manifest, npmVersion, nodeVersion);\n    return true;\n  } catch (_) {\n    return false;\n  }\n};\n\nconst isBefore = (verTimes, ver, time) => !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time;\n\nconst avoidSemverOpt = {\n  includePrerelease: true,\n  loose: true\n};\n\nconst shouldAvoid = (ver, avoid) => avoid && semver.satisfies(ver, avoid, avoidSemverOpt);\n\nconst decorateAvoid = (result, avoid) => result && shouldAvoid(result.version, avoid) ? { ...result,\n  _shouldAvoid: true\n} : result;\n\nconst pickManifest = (packument, wanted, opts) => {\n  const {\n    defaultTag = 'latest',\n    before = null,\n    nodeVersion = process.version,\n    npmVersion = null,\n    includeStaged = false,\n    avoid = null,\n    avoidStrict = false\n  } = opts;\n  const {\n    name,\n    time: verTimes\n  } = packument;\n  const versions = packument.versions || {};\n\n  if (avoidStrict) {\n    const looseOpts = { ...opts,\n      avoidStrict: false\n    };\n    const result = pickManifest(packument, wanted, looseOpts);\n\n    if (!result || !result._shouldAvoid) {\n      return result;\n    }\n\n    const caret = pickManifest(packument, `^${result.version}`, looseOpts);\n\n    if (!caret || !caret._shouldAvoid) {\n      return { ...caret,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: false\n      };\n    }\n\n    const star = pickManifest(packument, '*', looseOpts);\n\n    if (!star || !star._shouldAvoid) {\n      return { ...star,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: true\n      };\n    }\n\n    throw Object.assign(new Error(`No avoidable versions for ${name}`), {\n      code: 'ETARGET',\n      name,\n      wanted,\n      avoid,\n      before,\n      versions: Object.keys(versions)\n    });\n  }\n\n  const staged = includeStaged && packument.stagedVersions && packument.stagedVersions.versions || {};\n  const restricted = packument.policyRestrictions && packument.policyRestrictions.versions || {};\n  const time = before && verTimes ? +new Date(before) : Infinity;\n  const spec = npa.resolve(name, wanted || defaultTag);\n  const type = spec.type;\n  const distTags = packument['dist-tags'] || {};\n\n  if (type !== 'tag' && type !== 'version' && type !== 'range') {\n    throw new Error('Only tag, version, and range are supported');\n  } // if the type is 'tag', and not just the implicit default, then it must\n  // be that exactly, or nothing else will do.\n\n\n  if (wanted && type === 'tag') {\n    const ver = distTags[wanted]; // if the version in the dist-tags is before the before date, then\n    // we use that.  Otherwise, we get the highest precedence version\n    // prior to the dist-tag.\n\n    if (isBefore(verTimes, ver, time)) {\n      return decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid);\n    } else {\n      return pickManifest(packument, `<=${ver}`, opts);\n    }\n  } // similarly, if a specific version, then only that version will do\n\n\n  if (wanted && type === 'version') {\n    const ver = semver.clean(wanted, {\n      loose: true\n    });\n    const mani = versions[ver] || staged[ver] || restricted[ver];\n    return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null;\n  } // ok, sort based on our heuristics, and pick the best fit\n\n\n  const range = type === 'range' ? wanted : '*'; // if the range is *, then we prefer the 'latest' if available\n  // but skip this if it should be avoided, in that case we have\n  // to try a little harder.\n\n  const defaultVer = distTags[defaultTag];\n\n  if (defaultVer && (range === '*' || semver.satisfies(defaultVer, range, {\n    loose: true\n  })) && !shouldAvoid(defaultVer, avoid)) {\n    const mani = versions[defaultVer];\n\n    if (mani && isBefore(verTimes, defaultVer, time)) {\n      return mani;\n    }\n  } // ok, actually have to sort the list and take the winner\n\n\n  const allEntries = Object.entries(versions).concat(Object.entries(staged)).concat(Object.entries(restricted)).filter(([ver, mani]) => isBefore(verTimes, ver, time));\n\n  if (!allEntries.length) {\n    throw Object.assign(new Error(`No versions available for ${name}`), {\n      code: 'ENOVERSIONS',\n      name,\n      type,\n      wanted,\n      before,\n      versions: Object.keys(versions)\n    });\n  }\n\n  const sortSemverOpt = {\n    loose: true\n  };\n  const entries = allEntries.filter(([ver, mani]) => semver.satisfies(ver, range, {\n    loose: true\n  })).sort((a, b) => {\n    const [vera, mania] = a;\n    const [verb, manib] = b;\n    const notavoida = !shouldAvoid(vera, avoid);\n    const notavoidb = !shouldAvoid(verb, avoid);\n    const notrestra = !restricted[a];\n    const notrestrb = !restricted[b];\n    const notstagea = !staged[a];\n    const notstageb = !staged[b];\n    const notdepra = !mania.deprecated;\n    const notdeprb = !manib.deprecated;\n    const enginea = engineOk(mania, npmVersion, nodeVersion);\n    const engineb = engineOk(manib, npmVersion, nodeVersion); // sort by:\n    // - not an avoided version\n    // - not restricted\n    // - not staged\n    // - not deprecated and engine ok\n    // - engine ok\n    // - not deprecated\n    // - semver\n\n    return notavoidb - notavoida || notrestrb - notrestra || notstageb - notstagea || (notdeprb && engineb) - (notdepra && enginea) || engineb - enginea || notdeprb - notdepra || semver.rcompare(vera, verb, sortSemverOpt);\n  });\n  return decorateAvoid(entries[0] && entries[0][1], avoid);\n};\n\nmodule.exports = (packument, wanted, opts = {}) => {\n  const mani = pickManifest(packument, wanted, opts);\n  const picked = mani && normalizeBin(mani);\n  const policyRestrictions = packument.policyRestrictions;\n  const restricted = policyRestrictions && policyRestrictions.versions || {};\n\n  if (picked && !restricted[picked.version]) {\n    return picked;\n  }\n\n  const {\n    before = null,\n    defaultTag = 'latest'\n  } = opts;\n  const bstr = before ? new Date(before).toLocaleString() : '';\n  const {\n    name\n  } = packument;\n  const pckg = `${name}@${wanted}` + (before ? ` with a date before ${bstr}` : '');\n  const isForbidden = picked && !!restricted[picked.version];\n  const polMsg = isForbidden ? policyRestrictions.message : '';\n  const msg = !isForbidden ? `No matching version found for ${pckg}.` : `Could not download ${pckg} due to policy violations:\\n${polMsg}`;\n  const code = isForbidden ? 'E403' : 'ETARGET';\n  throw Object.assign(new Error(msg), {\n    code,\n    type: npa.resolve(packument.name, wanted).type,\n    wanted,\n    versions: Object.keys(packument.versions),\n    name,\n    distTags: packument['dist-tags'],\n    defaultTag\n  });\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/npm-pick-manifest/index.js"],"names":["npa","require","semver","checkEngine","normalizeBin","engineOk","manifest","npmVersion","nodeVersion","_","isBefore","verTimes","ver","time","Date","parse","avoidSemverOpt","includePrerelease","loose","shouldAvoid","avoid","satisfies","decorateAvoid","result","version","_shouldAvoid","pickManifest","packument","wanted","opts","defaultTag","before","process","includeStaged","avoidStrict","name","versions","looseOpts","caret","_outsideDependencyRange","_isSemVerMajor","star","Object","assign","Error","code","keys","staged","stagedVersions","restricted","policyRestrictions","Infinity","spec","resolve","type","distTags","clean","mani","range","defaultVer","allEntries","entries","concat","filter","length","sortSemverOpt","sort","a","b","vera","mania","verb","manib","notavoida","notavoidb","notrestra","notrestrb","notstagea","notstageb","notdepra","deprecated","notdeprb","enginea","engineb","rcompare","module","exports","picked","bstr","toLocaleString","pckg","isForbidden","polMsg","message","msg"],"mappings":"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","sourcesContent":["'use strict'\n\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { checkEngine } = require('npm-install-checks')\nconst normalizeBin = require('npm-normalize-package-bin')\n\nconst engineOk = (manifest, npmVersion, nodeVersion) => {\n  try {\n    checkEngine(manifest, npmVersion, nodeVersion)\n    return true\n  } catch (_) {\n    return false\n  }\n}\n\nconst isBefore = (verTimes, ver, time) =>\n  !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time\n\nconst avoidSemverOpt = { includePrerelease: true, loose: true }\nconst shouldAvoid = (ver, avoid) =>\n  avoid && semver.satisfies(ver, avoid, avoidSemverOpt)\n\nconst decorateAvoid = (result, avoid) =>\n  result && shouldAvoid(result.version, avoid)\n    ? { ...result, _shouldAvoid: true }\n    : result\n\nconst pickManifest = (packument, wanted, opts) => {\n  const {\n    defaultTag = 'latest',\n    before = null,\n    nodeVersion = process.version,\n    npmVersion = null,\n    includeStaged = false,\n    avoid = null,\n    avoidStrict = false\n  } = opts\n\n  const { name, time: verTimes } = packument\n  const versions = packument.versions || {}\n\n  if (avoidStrict) {\n    const looseOpts = {\n      ...opts,\n      avoidStrict: false\n    }\n\n    const result = pickManifest(packument, wanted, looseOpts)\n    if (!result || !result._shouldAvoid) {\n      return result\n    }\n\n    const caret = pickManifest(packument, `^${result.version}`, looseOpts)\n    if (!caret || !caret._shouldAvoid) {\n      return {\n        ...caret,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: false\n      }\n    }\n\n    const star = pickManifest(packument, '*', looseOpts)\n    if (!star || !star._shouldAvoid) {\n      return {\n        ...star,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: true\n      }\n    }\n\n    throw Object.assign(new Error(`No avoidable versions for ${name}`), {\n      code: 'ETARGET',\n      name,\n      wanted,\n      avoid,\n      before,\n      versions: Object.keys(versions)\n    })\n  }\n\n  const staged = (includeStaged && packument.stagedVersions &&\n    packument.stagedVersions.versions) || {}\n  const restricted = (packument.policyRestrictions &&\n    packument.policyRestrictions.versions) || {}\n\n  const time = before && verTimes ? +(new Date(before)) : Infinity\n  const spec = npa.resolve(name, wanted || defaultTag)\n  const type = spec.type\n  const distTags = packument['dist-tags'] || {}\n\n  if (type !== 'tag' && type !== 'version' && type !== 'range') {\n    throw new Error('Only tag, version, and range are supported')\n  }\n\n  // if the type is 'tag', and not just the implicit default, then it must\n  // be that exactly, or nothing else will do.\n  if (wanted && type === 'tag') {\n    const ver = distTags[wanted]\n    // if the version in the dist-tags is before the before date, then\n    // we use that.  Otherwise, we get the highest precedence version\n    // prior to the dist-tag.\n    if (isBefore(verTimes, ver, time)) {\n      return decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid)\n    } else {\n      return pickManifest(packument, `<=${ver}`, opts)\n    }\n  }\n\n  // similarly, if a specific version, then only that version will do\n  if (wanted && type === 'version') {\n    const ver = semver.clean(wanted, { loose: true })\n    const mani = versions[ver] || staged[ver] || restricted[ver]\n    return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null\n  }\n\n  // ok, sort based on our heuristics, and pick the best fit\n  const range = type === 'range' ? wanted : '*'\n\n  // if the range is *, then we prefer the 'latest' if available\n  // but skip this if it should be avoided, in that case we have\n  // to try a little harder.\n  const defaultVer = distTags[defaultTag]\n  if (defaultVer &&\n      (range === '*' || semver.satisfies(defaultVer, range, { loose: true })) &&\n      !shouldAvoid(defaultVer, avoid)) {\n    const mani = versions[defaultVer]\n    if (mani && isBefore(verTimes, defaultVer, time)) {\n      return mani\n    }\n  }\n\n  // ok, actually have to sort the list and take the winner\n  const allEntries = Object.entries(versions)\n    .concat(Object.entries(staged))\n    .concat(Object.entries(restricted))\n    .filter(([ver, mani]) => isBefore(verTimes, ver, time))\n\n  if (!allEntries.length) {\n    throw Object.assign(new Error(`No versions available for ${name}`), {\n      code: 'ENOVERSIONS',\n      name,\n      type,\n      wanted,\n      before,\n      versions: Object.keys(versions)\n    })\n  }\n\n  const sortSemverOpt = { loose: true }\n  const entries = allEntries.filter(([ver, mani]) =>\n    semver.satisfies(ver, range, { loose: true }))\n    .sort((a, b) => {\n      const [vera, mania] = a\n      const [verb, manib] = b\n      const notavoida = !shouldAvoid(vera, avoid)\n      const notavoidb = !shouldAvoid(verb, avoid)\n      const notrestra = !restricted[a]\n      const notrestrb = !restricted[b]\n      const notstagea = !staged[a]\n      const notstageb = !staged[b]\n      const notdepra = !mania.deprecated\n      const notdeprb = !manib.deprecated\n      const enginea = engineOk(mania, npmVersion, nodeVersion)\n      const engineb = engineOk(manib, npmVersion, nodeVersion)\n      // sort by:\n      // - not an avoided version\n      // - not restricted\n      // - not staged\n      // - not deprecated and engine ok\n      // - engine ok\n      // - not deprecated\n      // - semver\n      return (notavoidb - notavoida) ||\n        (notrestrb - notrestra) ||\n        (notstageb - notstagea) ||\n        ((notdeprb && engineb) - (notdepra && enginea)) ||\n        (engineb - enginea) ||\n        (notdeprb - notdepra) ||\n        semver.rcompare(vera, verb, sortSemverOpt)\n    })\n\n  return decorateAvoid(entries[0] && entries[0][1], avoid)\n}\n\nmodule.exports = (packument, wanted, opts = {}) => {\n  const mani = pickManifest(packument, wanted, opts)\n  const picked = mani && normalizeBin(mani)\n  const policyRestrictions = packument.policyRestrictions\n  const restricted = (policyRestrictions && policyRestrictions.versions) || {}\n\n  if (picked && !restricted[picked.version]) {\n    return picked\n  }\n\n  const { before = null, defaultTag = 'latest' } = opts\n  const bstr = before ? new Date(before).toLocaleString() : ''\n  const { name } = packument\n  const pckg = `${name}@${wanted}` +\n    (before ? ` with a date before ${bstr}` : '')\n\n  const isForbidden = picked && !!restricted[picked.version]\n  const polMsg = isForbidden ? policyRestrictions.message : ''\n\n  const msg = !isForbidden ? `No matching version found for ${pckg}.`\n    : `Could not download ${pckg} due to policy violations:\\n${polMsg}`\n\n  const code = isForbidden ? 'E403' : 'ETARGET'\n  throw Object.assign(new Error(msg), {\n    code,\n    type: npa.resolve(packument.name, wanted).type,\n    wanted,\n    versions: Object.keys(packument.versions),\n    name,\n    distTags: packument['dist-tags'],\n    defaultTag\n  })\n}\n"]},"metadata":{},"sourceType":"script"}