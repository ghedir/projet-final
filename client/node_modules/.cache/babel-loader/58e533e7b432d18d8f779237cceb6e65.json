{"ast":null,"code":"// a class to manage an inventory and set of indexes of\n// a set of objects based on specific fields.\n// primary is the primary index key.\n// keys is the set of fields to be able to query.\nconst _primaryKey = Symbol('_primaryKey');\n\nconst _index = Symbol('_index');\n\nconst defaultKeys = ['name', 'license', 'funding', 'realpath', 'packageName'];\nconst {\n  hasOwnProperty\n} = Object.prototype;\n\nconst debug = require('./debug.js'); // handling for the outdated \"licenses\" array, just pick the first one\n// also support the alternative spelling \"licence\"\n\n\nconst getLicense = pkg => {\n  if (pkg) {\n    const lic = pkg.license || pkg.licence;\n\n    if (lic) {\n      return lic;\n    }\n\n    const lics = pkg.licenses || pkg.licences;\n\n    if (Array.isArray(lics)) {\n      return lics[0];\n    }\n  }\n};\n\nclass Inventory extends Map {\n  constructor(opt = {}) {\n    const {\n      primary,\n      keys\n    } = opt;\n    super();\n    this[_primaryKey] = primary || 'location';\n    this[_index] = (keys || defaultKeys).reduce((index, i) => {\n      index.set(i, new Map());\n      return index;\n    }, new Map());\n  }\n\n  get primaryKey() {\n    return this[_primaryKey];\n  }\n\n  get indexes() {\n    return [...this[_index].keys()];\n  }\n\n  *filter(fn) {\n    for (const node of this.values()) {\n      if (fn(node)) {\n        yield node;\n      }\n    }\n  }\n\n  add(node) {\n    const root = super.get('');\n\n    if (root && node.root !== root && node.root !== root.root) {\n      debug(() => {\n        throw Object.assign(new Error('adding external node to inventory'), {\n          root: root.path,\n          node: node.path,\n          nodeRoot: node.root.path\n        });\n      });\n      return;\n    }\n\n    const current = super.get(node[this.primaryKey]);\n\n    if (current) {\n      if (current === node) {\n        return;\n      }\n\n      this.delete(current);\n    }\n\n    super.set(node[this.primaryKey], node);\n\n    for (const [key, map] of this[_index].entries()) {\n      // if the node has the value, but it's false, then use that\n      const val_ = hasOwnProperty.call(node, key) ? node[key] : key === 'license' ? getLicense(node.package) : node[key] ? node[key] : node.package && node.package[key];\n      const val = typeof val_ === 'string' ? val_ : !val_ || typeof val_ !== 'object' ? val_ : key === 'license' ? val_.type : key === 'funding' ? val_.url :\n      /* istanbul ignore next - not used */\n      val_;\n      const set = map.get(val) || new Set();\n      set.add(node);\n      map.set(val, set);\n    }\n  }\n\n  delete(node) {\n    if (!this.has(node)) {\n      return;\n    }\n\n    super.delete(node[this.primaryKey]);\n\n    for (const [key, map] of this[_index].entries()) {\n      const val = node[key] !== undefined ? node[key] : node[key] || node.package && node.package[key];\n      const set = map.get(val);\n\n      if (set) {\n        set.delete(node);\n\n        if (set.size === 0) {\n          map.delete(node[key]);\n        }\n      }\n    }\n  }\n\n  query(key, val) {\n    const map = this[_index].get(key);\n\n    return map && (arguments.length === 2 ? map.get(val) : map.keys()) || new Set();\n  }\n\n  has(node) {\n    return super.get(node[this.primaryKey]) === node;\n  }\n\n  set(k, v) {\n    throw new Error('direct set() not supported, use inventory.add(node)');\n  }\n\n}\n\nmodule.exports = Inventory;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/inventory.js"],"names":["_primaryKey","Symbol","_index","defaultKeys","hasOwnProperty","Object","prototype","debug","require","getLicense","pkg","lic","license","licence","lics","licenses","licences","Array","isArray","Inventory","Map","constructor","opt","primary","keys","reduce","index","i","set","primaryKey","indexes","filter","fn","node","values","add","root","get","assign","Error","path","nodeRoot","current","delete","key","map","entries","val_","call","package","val","type","url","Set","has","undefined","size","query","arguments","length","k","v","module","exports"],"mappings":"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","sourcesContent":["// a class to manage an inventory and set of indexes of\n// a set of objects based on specific fields.\n// primary is the primary index key.\n// keys is the set of fields to be able to query.\nconst _primaryKey = Symbol('_primaryKey')\nconst _index = Symbol('_index')\nconst defaultKeys = ['name', 'license', 'funding', 'realpath', 'packageName']\nconst { hasOwnProperty } = Object.prototype\nconst debug = require('./debug.js')\n\n// handling for the outdated \"licenses\" array, just pick the first one\n// also support the alternative spelling \"licence\"\nconst getLicense = pkg => {\n  if (pkg) {\n    const lic = pkg.license || pkg.licence\n    if (lic) {\n      return lic\n    }\n    const lics = pkg.licenses || pkg.licences\n    if (Array.isArray(lics)) {\n      return lics[0]\n    }\n  }\n}\n\nclass Inventory extends Map {\n  constructor (opt = {}) {\n    const { primary, keys } = opt\n    super()\n    this[_primaryKey] = primary || 'location'\n    this[_index] = (keys || defaultKeys).reduce((index, i) => {\n      index.set(i, new Map())\n      return index\n    }, new Map())\n  }\n\n  get primaryKey () {\n    return this[_primaryKey]\n  }\n\n  get indexes () {\n    return [...this[_index].keys()]\n  }\n\n  * filter (fn) {\n    for (const node of this.values()) {\n      if (fn(node)) {\n        yield node\n      }\n    }\n  }\n\n  add (node) {\n    const root = super.get('')\n    if (root && node.root !== root && node.root !== root.root) {\n      debug(() => {\n        throw Object.assign(new Error('adding external node to inventory'), {\n          root: root.path,\n          node: node.path,\n          nodeRoot: node.root.path,\n        })\n      })\n      return\n    }\n\n    const current = super.get(node[this.primaryKey])\n    if (current) {\n      if (current === node) {\n        return\n      }\n      this.delete(current)\n    }\n    super.set(node[this.primaryKey], node)\n    for (const [key, map] of this[_index].entries()) {\n      // if the node has the value, but it's false, then use that\n      const val_ = hasOwnProperty.call(node, key) ? node[key]\n        : key === 'license' ? getLicense(node.package)\n        : node[key] ? node[key]\n        : node.package && node.package[key]\n      const val = typeof val_ === 'string' ? val_\n        : !val_ || typeof val_ !== 'object' ? val_\n        : key === 'license' ? val_.type\n        : key === 'funding' ? val_.url\n        : /* istanbul ignore next - not used */ val_\n      const set = map.get(val) || new Set()\n      set.add(node)\n      map.set(val, set)\n    }\n  }\n\n  delete (node) {\n    if (!this.has(node)) {\n      return\n    }\n\n    super.delete(node[this.primaryKey])\n    for (const [key, map] of this[_index].entries()) {\n      const val = node[key] !== undefined ? node[key]\n        : (node[key] || (node.package && node.package[key]))\n      const set = map.get(val)\n      if (set) {\n        set.delete(node)\n        if (set.size === 0) {\n          map.delete(node[key])\n        }\n      }\n    }\n  }\n\n  query (key, val) {\n    const map = this[_index].get(key)\n    return map && (arguments.length === 2 ? map.get(val) : map.keys()) ||\n      new Set()\n  }\n\n  has (node) {\n    return super.get(node[this.primaryKey]) === node\n  }\n\n  set (k, v) {\n    throw new Error('direct set() not supported, use inventory.add(node)')\n  }\n}\n\nmodule.exports = Inventory\n"]},"metadata":{},"sourceType":"script"}