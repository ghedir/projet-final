{"ast":null,"code":"// put javascript in here\n'use strict';\n\nconst Parser = require('jsonparse');\n\nconst Minipass = require('minipass');\n\nclass JSONStreamError extends Error {\n  constructor(err, caller) {\n    super(err.message);\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n\n  get name() {\n    return 'JSONStreamError';\n  }\n\n  set name(n) {}\n\n}\n\nconst check = (x, y) => typeof x === 'string' ? String(y) === x : x && typeof x.test === 'function' ? x.test(y) : typeof x === 'boolean' || typeof x === 'object' ? x : typeof x === 'function' ? x(y) : false;\n\nconst _parser = Symbol('_parser');\n\nconst _onValue = Symbol('_onValue');\n\nconst _onTokenOriginal = Symbol('_onTokenOriginal');\n\nconst _onToken = Symbol('_onToken');\n\nconst _onError = Symbol('_onError');\n\nconst _count = Symbol('_count');\n\nconst _path = Symbol('_path');\n\nconst _map = Symbol('_map');\n\nconst _root = Symbol('_root');\n\nconst _header = Symbol('_header');\n\nconst _footer = Symbol('_footer');\n\nconst _setHeaderFooter = Symbol('_setHeaderFooter');\n\nconst _ending = Symbol('_ending');\n\nclass JSONStream extends Minipass {\n  constructor(opts = {}) {\n    super({ ...opts,\n      objectMode: true\n    });\n    this[_ending] = false;\n    const parser = this[_parser] = new Parser();\n\n    parser.onValue = value => this[_onValue](value);\n\n    this[_onTokenOriginal] = parser.onToken;\n\n    parser.onToken = (token, value) => this[_onToken](token, value);\n\n    parser.onError = er => this[_onError](er);\n\n    this[_count] = 0;\n    this[_path] = typeof opts.path === 'string' ? opts.path.split('.').map(e => e === '$*' ? {\n      emitKey: true\n    } : e === '*' ? true : e === '' ? {\n      recurse: true\n    } : e) : Array.isArray(opts.path) && opts.path.length ? opts.path : null;\n    this[_map] = typeof opts.map === 'function' ? opts.map : null;\n    this[_root] = null;\n    this[_header] = null;\n    this[_footer] = null;\n    this[_count] = 0;\n  }\n\n  [_setHeaderFooter](key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {};\n      this[_header][key] = value;\n    } // footer has not been emitted yet but header has\n\n\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {};\n      this[_footer][key] = value;\n    }\n  }\n\n  [_onError](er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write;\n    this[_ending] = false;\n    return this.emit('error', new JSONStreamError(er, caller));\n  }\n\n  [_onToken](token, value) {\n    const parser = this[_parser];\n\n    this[_onTokenOriginal].call(parser, token, value);\n\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root];\n        if (!this[_path]) super.write(root);\n        this[_root] = null;\n        this[_count] = 0;\n      }\n    }\n  }\n\n  [_onValue](value) {\n    const parser = this[_parser]; // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n\n    this[_root] = value;\n    if (!this[_path]) return;\n    let i = 0; // iterates on path\n\n    let j = 0; // iterates on stack\n\n    let emitKey = false;\n    let emitPath = false;\n\n    while (i < this[_path].length) {\n      const key = this[_path][i];\n      j++;\n\n      if (key && !key.recurse) {\n        const c = j === parser.stack.length ? parser : parser.stack[j];\n        if (!c) return;\n\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value);\n\n          return;\n        }\n\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        if (i >= this[_path].length) return;\n        const nextKey = this[_path][i];\n        if (!nextKey) return;\n\n        while (true) {\n          const c = j === parser.stack.length ? parser : parser.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(parser.stack[j])) parser.stack[j].value = null;\n            break;\n          } else {\n            this[_setHeaderFooter](c.key, value);\n          }\n\n          j++;\n        }\n      }\n    } // emit header\n\n\n    if (this[_header]) {\n      const header = this[_header];\n      this[_header] = false;\n      this.emit('header', header);\n    }\n\n    if (j !== parser.stack.length) return;\n    this[_count]++;\n    const actualPath = parser.stack.slice(1).map(e => e.key).concat([parser.key]);\n\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value;\n\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? {\n          value: data\n        } : data;\n        if (emitKey) emit.key = parser.key;\n        if (emitPath) emit.path = actualPath;\n        super.write(emit);\n      }\n    }\n\n    if (parser.value) delete parser.value[parser.key];\n\n    for (const k of parser.stack) {\n      k.value = null;\n    }\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);else if (!Buffer.isBuffer(chunk)) return this.emit('error', new TypeError('Can only parse JSON from string or buffer input'));\n\n    this[_parser].write(chunk);\n\n    if (cb) cb();\n    return this.flowing;\n  }\n\n  end(chunk, encoding, cb) {\n    this[_ending] = true;\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    const h = this[_header];\n    this[_header] = null;\n    const f = this[_footer];\n    this[_footer] = null;\n    if (h) this.emit('header', h);\n    if (f) this.emit('footer', f);\n    return super.end();\n  }\n\n  static get JSONStreamError() {\n    return JSONStreamError;\n  }\n\n  static parse(path, map) {\n    return new JSONStream({\n      path,\n      map\n    });\n  }\n\n}\n\nmodule.exports = JSONStream;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/minipass-json-stream/index.js"],"names":["Parser","require","Minipass","JSONStreamError","Error","constructor","err","caller","message","captureStackTrace","name","n","check","x","y","String","test","_parser","Symbol","_onValue","_onTokenOriginal","_onToken","_onError","_count","_path","_map","_root","_header","_footer","_setHeaderFooter","_ending","JSONStream","opts","objectMode","parser","onValue","value","onToken","token","onError","er","path","split","map","e","emitKey","recurse","Array","isArray","length","key","end","write","emit","call","stack","root","i","j","emitPath","c","nextKey","Object","isFrozen","header","actualPath","slice","concat","undefined","data","k","chunk","encoding","cb","Buffer","from","isBuffer","TypeError","flowing","once","h","f","parse","module","exports"],"mappings":"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","sourcesContent":["// put javascript in here\n'use strict'\n\nconst Parser = require('jsonparse')\nconst Minipass = require('minipass')\n\nclass JSONStreamError extends Error {\n  constructor (err, caller) {\n    super(err.message)\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () {\n    return 'JSONStreamError'\n  }\n  set name (n) {}\n}\n\nconst check = (x, y) =>\n  typeof x === 'string' ? String(y) === x\n  : x && typeof x.test === 'function' ? x.test(y)\n  : typeof x === 'boolean' || typeof x === 'object' ? x\n  : typeof x === 'function' ? x(y)\n  : false\n\nconst _parser = Symbol('_parser')\nconst _onValue = Symbol('_onValue')\nconst _onTokenOriginal = Symbol('_onTokenOriginal')\nconst _onToken = Symbol('_onToken')\nconst _onError = Symbol('_onError')\nconst _count = Symbol('_count')\nconst _path = Symbol('_path')\nconst _map = Symbol('_map')\nconst _root = Symbol('_root')\nconst _header = Symbol('_header')\nconst _footer = Symbol('_footer')\nconst _setHeaderFooter = Symbol('_setHeaderFooter')\nconst _ending = Symbol('_ending')\n\nclass JSONStream extends Minipass {\n  constructor (opts = {}) {\n    super({\n      ...opts,\n      objectMode: true,\n    })\n\n    this[_ending] = false\n    const parser = this[_parser] = new Parser()\n    parser.onValue = value => this[_onValue](value)\n    this[_onTokenOriginal] = parser.onToken\n    parser.onToken = (token, value) => this[_onToken](token, value)\n    parser.onError = er => this[_onError](er)\n\n    this[_count] = 0\n    this[_path] = typeof opts.path === 'string'\n      ? opts.path.split('.').map(e =>\n          e === '$*' ? { emitKey: true }\n          : e === '*' ? true\n          : e === '' ? { recurse: true }\n          : e)\n      : Array.isArray(opts.path) && opts.path.length ? opts.path\n      : null\n\n    this[_map] = typeof opts.map === 'function' ? opts.map : null\n    this[_root] = null\n    this[_header] = null\n    this[_footer] = null\n    this[_count] = 0\n  }\n\n  [_setHeaderFooter] (key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {}\n      this[_header][key] = value\n    }\n\n    // footer has not been emitted yet but header has\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {}\n      this[_footer][key] = value\n    }\n  }\n\n  [_onError] (er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write\n    this[_ending] = false\n    return this.emit('error', new JSONStreamError(er, caller))\n  }\n\n  [_onToken] (token, value) {\n    const parser = this[_parser]\n    this[_onTokenOriginal].call(parser, token, value)\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root]\n        if (!this[_path])\n          super.write(root)\n        this[_root] = null\n        this[_count] = 0\n      }\n    }\n  }\n\n  [_onValue] (value) {\n    const parser = this[_parser]\n    // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n    this[_root] = value\n\n    if(!this[_path]) return\n\n    let i = 0 // iterates on path\n    let j  = 0 // iterates on stack\n    let emitKey = false\n    let emitPath = false\n    while (i < this[_path].length) {\n      const key = this[_path][i]\n      j++\n\n      if (key && !key.recurse) {\n        const c = (j === parser.stack.length) ? parser : parser.stack[j]\n        if (!c) return\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value)\n          return\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++\n      } else {\n        i++\n        if (i >= this[_path].length)\n          return\n        const nextKey = this[_path][i]\n        if (!nextKey)\n          return\n        while (true) {\n          const c = (j === parser.stack.length) ? parser : parser.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) {\n            i++\n            if (!Object.isFrozen(parser.stack[j]))\n              parser.stack[j].value = null\n            break\n          } else {\n            this[_setHeaderFooter](c.key, value)\n          }\n          j++\n        }\n      }\n    }\n\n    // emit header\n    if (this[_header]) {\n      const header = this[_header]\n      this[_header] = false\n      this.emit('header', header)\n    }\n    if (j !== parser.stack.length) return\n\n    this[_count] ++\n    const actualPath = parser.stack.slice(1)\n      .map(e => e.key).concat([parser.key])\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? { value: data } : data\n        if (emitKey)\n          emit.key = parser.key\n        if (emitPath)\n          emit.path = actualPath\n        super.write(emit)\n      }\n    }\n\n    if (parser.value)\n      delete parser.value[parser.key]\n\n    for (const k of parser.stack) {\n      k.value = null\n    }\n  }\n\n  write (chunk, encoding, cb) {\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n    else if (!Buffer.isBuffer(chunk))\n      return this.emit('error', new TypeError(\n        'Can only parse JSON from string or buffer input'))\n    this[_parser].write(chunk)\n    if (cb)\n      cb()\n    return this.flowing\n  }\n\n  end (chunk, encoding, cb) {\n    this[_ending] = true\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n\n    const h = this[_header]\n    this[_header] = null\n    const f = this[_footer]\n    this[_footer] = null\n    if (h)\n      this.emit('header', h)\n    if (f)\n      this.emit('footer', f)\n    return super.end()\n  }\n\n  static get JSONStreamError () { return JSONStreamError }\n  static parse (path, map) {\n    return new JSONStream({path, map})\n  }\n}\n\nmodule.exports = JSONStream\n"]},"metadata":{},"sourceType":"script"}