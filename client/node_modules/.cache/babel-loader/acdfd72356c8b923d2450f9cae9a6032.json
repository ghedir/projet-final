{"ast":null,"code":"const {\n  delimiter,\n  dirname,\n  resolve\n} = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst read = promisify(require('read'));\n\nconst Arborist = require('@npmcli/arborist');\n\nconst ciDetect = require('@npmcli/ci-detect');\n\nconst logger = require('proc-log');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst readPackageJson = require('read-package-json-fast');\n\nconst cacheInstallDir = require('./cache-install-dir.js');\n\nconst {\n  fileExists,\n  localFileExists\n} = require('./file-exists.js');\n\nconst getBinFromManifest = require('./get-bin-from-manifest.js');\n\nconst manifestMissing = require('./manifest-missing.js');\n\nconst noTTY = require('./no-tty.js');\n\nconst runScript = require('./run-script.js');\n\nconst isWindows = require('./is-windows.js');\n/* istanbul ignore next */\n\n\nconst PATH = (process.env.PATH || process.env.Path || process.env.path).split(delimiter);\n\nconst exec = async opts => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    output,\n    packages: _packages = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts;\n  const log = flatOptions.log || logger; // dereferences values because we manipulate it later\n\n  const packages = [..._packages];\n  const pathArr = [...PATH];\n\n  const _run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    log,\n    output,\n    path,\n    pathArr,\n    runPath,\n    scriptShell\n  }); // nothing to maybe install, skip the arborist dance\n\n\n  if (!call && !args.length && !packages.length) return await _run();\n  const needPackageCommandSwap = args.length && !packages.length; // if there's an argument and no package has been explicitly asked for\n  // check the local and global bin paths for a binary named the same as\n  // the argument and run it if it exists, otherwise fall through to\n  // the behavior of treating the single argument as a package name\n\n  if (needPackageCommandSwap) {\n    let binExists = false;\n    const dir = dirname(dirname(localBin));\n    const localBinPath = await localFileExists(dir, args[0]);\n\n    if (localBinPath) {\n      pathArr.unshift(localBinPath);\n      binExists = true;\n    } else if (await fileExists(`${globalBin}/${args[0]}`)) {\n      pathArr.unshift(globalBin);\n      binExists = true;\n    }\n\n    if (binExists) return await _run();\n    packages.push(args[0]);\n  } // If we do `npm exec foo`, and have a `foo` locally, then we'll\n  // always use that, so we don't really need to fetch the manifest.\n  // So: run npa on each packages entry, and if it is a name with a\n  // rawSpec==='', then try to readPackageJson at\n  // node_modules/${name}/package.json, and only pacote fetch if\n  // that fails.\n\n\n  const manis = await Promise.all(packages.map(async p => {\n    const spec = npa(p, path);\n\n    if (spec.type === 'tag' && spec.rawSpec === '') {\n      // fall through to the pacote.manifest() approach\n      try {\n        const pj = resolve(path, 'node_modules', spec.name, 'package.json');\n        return await readPackageJson(pj);\n      } catch (er) {}\n    } // Force preferOnline to true so we are making sure to pull in the latest\n    // This is especially useful if the user didn't give us a version, and\n    // they expect to be running @latest\n\n\n    return await pacote.manifest(p, { ...flatOptions,\n      preferOnline: true\n    });\n  }));\n  if (needPackageCommandSwap) args[0] = getBinFromManifest(manis[0]); // figure out whether we need to install stuff, or if local is fine\n\n  const localArb = new Arborist({ ...flatOptions,\n    path\n  });\n  const tree = await localArb.loadActual(); // do we have all the packages in manifest list?\n\n  const needInstall = manis.some(manifest => manifestMissing({\n    tree,\n    manifest\n  }));\n\n  if (needInstall) {\n    const {\n      npxCache\n    } = flatOptions;\n    const installDir = cacheInstallDir({\n      npxCache,\n      packages\n    });\n    await mkdirp(installDir);\n    const arb = new Arborist({ ...flatOptions,\n      path: installDir\n    });\n    const tree = await arb.loadActual(); // at this point, we have to ensure that we get the exact same\n    // version, because it's something that has only ever been installed\n    // by npm exec in the cache install directory\n\n    const add = manis.filter(mani => manifestMissing({\n      tree,\n      manifest: { ...mani,\n        _from: `${mani.name}@${mani.version}`\n      }\n    })).map(mani => mani._from).sort((a, b) => a.localeCompare(b, 'en')); // no need to install if already present\n\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false) throw new Error('canceled');\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${add.length === 1 ? ' was' : 's were'} not found and will be installed: ${add.map(pkg => pkg.replace(/@$/, '')).join(', ')}`);\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`).join('\\n') + '\\n';\n          const prompt = `Need to install the following packages:\\n${addList}Ok to proceed? `;\n          if (typeof log.clearProgress === 'function') log.clearProgress();\n          const confirm = await read({\n            prompt,\n            default: 'y'\n          });\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y') throw new Error('canceled');\n        }\n      }\n\n      await arb.reify({ ...flatOptions,\n        add\n      });\n    }\n\n    pathArr.unshift(resolve(installDir, 'node_modules/.bin'));\n  }\n\n  return await _run();\n};\n\nmodule.exports = exec;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/libnpmexec/lib/index.js"],"names":["delimiter","dirname","resolve","require","promisify","read","Arborist","ciDetect","logger","mkdirp","npa","pacote","readPackageJson","cacheInstallDir","fileExists","localFileExists","getBinFromManifest","manifestMissing","noTTY","runScript","isWindows","PATH","process","env","Path","path","split","exec","opts","args","call","color","localBin","locationMsg","undefined","globalBin","output","packages","_packages","runPath","scriptShell","ComSpec","yes","flatOptions","log","pathArr","_run","length","needPackageCommandSwap","binExists","dir","localBinPath","unshift","push","manis","Promise","all","map","p","spec","type","rawSpec","pj","name","er","manifest","preferOnline","localArb","tree","loadActual","needInstall","some","npxCache","installDir","arb","add","filter","mani","_from","version","sort","a","b","localeCompare","Error","warn","pkg","replace","join","addList","prompt","clearProgress","confirm","default","trim","toLowerCase","charAt","reify","module","exports"],"mappings":"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","sourcesContent":["const { delimiter, dirname, resolve } = require('path')\nconst { promisify } = require('util')\nconst read = promisify(require('read'))\n\nconst Arborist = require('@npmcli/arborist')\nconst ciDetect = require('@npmcli/ci-detect')\nconst logger = require('proc-log')\nconst mkdirp = require('mkdirp-infer-owner')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst readPackageJson = require('read-package-json-fast')\n\nconst cacheInstallDir = require('./cache-install-dir.js')\nconst { fileExists, localFileExists } = require('./file-exists.js')\nconst getBinFromManifest = require('./get-bin-from-manifest.js')\nconst manifestMissing = require('./manifest-missing.js')\nconst noTTY = require('./no-tty.js')\nconst runScript = require('./run-script.js')\nconst isWindows = require('./is-windows.js')\n\n/* istanbul ignore next */\nconst PATH = (\n  process.env.PATH || process.env.Path || process.env.path\n).split(delimiter)\n\nconst exec = async (opts) => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    output,\n    packages: _packages = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts\n  const log = flatOptions.log || logger\n\n  // dereferences values because we manipulate it later\n  const packages = [..._packages]\n  const pathArr = [...PATH]\n  const _run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    log,\n    output,\n    path,\n    pathArr,\n    runPath,\n    scriptShell,\n  })\n\n  // nothing to maybe install, skip the arborist dance\n  if (!call && !args.length && !packages.length)\n    return await _run()\n\n  const needPackageCommandSwap = args.length && !packages.length\n  // if there's an argument and no package has been explicitly asked for\n  // check the local and global bin paths for a binary named the same as\n  // the argument and run it if it exists, otherwise fall through to\n  // the behavior of treating the single argument as a package name\n  if (needPackageCommandSwap) {\n    let binExists = false\n    const dir = dirname(dirname(localBin))\n    const localBinPath = await localFileExists(dir, args[0])\n    if (localBinPath) {\n      pathArr.unshift(localBinPath)\n      binExists = true\n    } else if (await fileExists(`${globalBin}/${args[0]}`)) {\n      pathArr.unshift(globalBin)\n      binExists = true\n    }\n\n    if (binExists)\n      return await _run()\n\n    packages.push(args[0])\n  }\n\n  // If we do `npm exec foo`, and have a `foo` locally, then we'll\n  // always use that, so we don't really need to fetch the manifest.\n  // So: run npa on each packages entry, and if it is a name with a\n  // rawSpec==='', then try to readPackageJson at\n  // node_modules/${name}/package.json, and only pacote fetch if\n  // that fails.\n  const manis = await Promise.all(packages.map(async p => {\n    const spec = npa(p, path)\n    if (spec.type === 'tag' && spec.rawSpec === '') {\n      // fall through to the pacote.manifest() approach\n      try {\n        const pj = resolve(path, 'node_modules', spec.name, 'package.json')\n        return await readPackageJson(pj)\n      } catch (er) {}\n    }\n    // Force preferOnline to true so we are making sure to pull in the latest\n    // This is especially useful if the user didn't give us a version, and\n    // they expect to be running @latest\n    return await pacote.manifest(p, {\n      ...flatOptions,\n      preferOnline: true,\n    })\n  }))\n\n  if (needPackageCommandSwap)\n    args[0] = getBinFromManifest(manis[0])\n\n  // figure out whether we need to install stuff, or if local is fine\n  const localArb = new Arborist({\n    ...flatOptions,\n    path,\n  })\n  const tree = await localArb.loadActual()\n\n  // do we have all the packages in manifest list?\n  const needInstall =\n    manis.some(manifest => manifestMissing({ tree, manifest }))\n\n  if (needInstall) {\n    const { npxCache } = flatOptions\n    const installDir = cacheInstallDir({ npxCache, packages })\n    await mkdirp(installDir)\n    const arb = new Arborist({\n      ...flatOptions,\n      path: installDir,\n    })\n    const tree = await arb.loadActual()\n\n    // at this point, we have to ensure that we get the exact same\n    // version, because it's something that has only ever been installed\n    // by npm exec in the cache install directory\n    const add = manis.filter(mani => manifestMissing({\n      tree,\n      manifest: {\n        ...mani,\n        _from: `${mani.name}@${mani.version}`,\n      },\n    }))\n      .map(mani => mani._from)\n      .sort((a, b) => a.localeCompare(b, 'en'))\n\n    // no need to install if already present\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false)\n          throw new Error('canceled')\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${\n            add.length === 1 ? ' was' : 's were'\n          } not found and will be installed: ${\n            add.map((pkg) => pkg.replace(/@$/, '')).join(', ')\n          }`)\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`)\n            .join('\\n') + '\\n'\n          const prompt = `Need to install the following packages:\\n${\n          addList\n        }Ok to proceed? `\n          if (typeof log.clearProgress === 'function')\n            log.clearProgress()\n          const confirm = await read({ prompt, default: 'y' })\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y')\n            throw new Error('canceled')\n        }\n      }\n      await arb.reify({\n        ...flatOptions,\n        add,\n      })\n    }\n    pathArr.unshift(resolve(installDir, 'node_modules/.bin'))\n  }\n\n  return await _run()\n}\n\nmodule.exports = exec\n"]},"metadata":{},"sourceType":"script"}