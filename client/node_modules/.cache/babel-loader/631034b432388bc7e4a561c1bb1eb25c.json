{"ast":null,"code":"const Minipass = require('minipass');\n\nclass SizeError extends Error {\n  constructor(found, expect) {\n    super(`Bad data size: expected ${expect} bytes, but got ${found}`);\n    this.expect = expect;\n    this.found = found;\n    this.code = 'EBADSIZE';\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  get name() {\n    return 'SizeError';\n  }\n\n}\n\nclass MinipassSized extends Minipass {\n  constructor(options = {}) {\n    super(options);\n    if (options.objectMode) throw new TypeError(`${this.constructor.name} streams only work with string and buffer data`);\n    this.found = 0;\n    this.expect = options.size;\n    if (typeof this.expect !== 'number' || this.expect > Number.MAX_SAFE_INTEGER || isNaN(this.expect) || this.expect < 0 || !isFinite(this.expect) || this.expect !== Math.floor(this.expect)) throw new Error('invalid expected size: ' + this.expect);\n  }\n\n  write(chunk, encoding, cb) {\n    const buffer = Buffer.isBuffer(chunk) ? chunk : typeof chunk === 'string' ? Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8') : chunk;\n\n    if (!Buffer.isBuffer(buffer)) {\n      this.emit('error', new TypeError(`${this.constructor.name} streams only work with string and buffer data`));\n      return false;\n    }\n\n    this.found += buffer.length;\n    if (this.found > this.expect) this.emit('error', new SizeError(this.found, this.expect));\n    return super.write(chunk, encoding, cb);\n  }\n\n  emit(ev, ...data) {\n    if (ev === 'end') {\n      if (this.found !== this.expect) this.emit('error', new SizeError(this.found, this.expect));\n    }\n\n    return super.emit(ev, ...data);\n  }\n\n}\n\nMinipassSized.SizeError = SizeError;\nmodule.exports = MinipassSized;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/minipass-sized/index.js"],"names":["Minipass","require","SizeError","Error","constructor","found","expect","code","captureStackTrace","name","MinipassSized","options","objectMode","TypeError","size","Number","MAX_SAFE_INTEGER","isNaN","isFinite","Math","floor","write","chunk","encoding","cb","buffer","Buffer","isBuffer","from","emit","length","ev","data","module","exports"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AAEA,MAAMC,SAAN,SAAwBC,KAAxB,CAA8B;AAC5BC,EAAAA,WAAW,CAAEC,KAAF,EAASC,MAAT,EAAiB;AAC1B,UAAO,2BAA0BA,MAAO,mBAAkBD,KAAM,EAAhE;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKE,IAAL,GAAY,UAAZ;AACDJ,IAAAA,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8B,KAAKJ,WAAnC;AACA;;AACO,MAAJK,IAAI,GAAI;AACV,WAAO,WAAP;AACD;;AAV2B;;AAa9B,MAAMC,aAAN,SAA4BV,QAA5B,CAAqC;AACnCI,EAAAA,WAAW,CAAEO,OAAO,GAAG,EAAZ,EAAgB;AACzB,UAAMA,OAAN;AAEA,QAAIA,OAAO,CAACC,UAAZ,EACE,MAAM,IAAIC,SAAJ,CAAe,GACnB,KAAKT,WAAL,CAAiBK,IAClB,gDAFK,CAAN;AAIF,SAAKJ,KAAL,GAAa,CAAb;AACA,SAAKC,MAAL,GAAcK,OAAO,CAACG,IAAtB;AACA,QAAI,OAAO,KAAKR,MAAZ,KAAuB,QAAvB,IACA,KAAKA,MAAL,GAAcS,MAAM,CAACC,gBADrB,IAEAC,KAAK,CAAC,KAAKX,MAAN,CAFL,IAGA,KAAKA,MAAL,GAAc,CAHd,IAIA,CAACY,QAAQ,CAAC,KAAKZ,MAAN,CAJT,IAKA,KAAKA,MAAL,KAAgBa,IAAI,CAACC,KAAL,CAAW,KAAKd,MAAhB,CALpB,EAME,MAAM,IAAIH,KAAJ,CAAU,4BAA4B,KAAKG,MAA3C,CAAN;AACH;;AAEDe,EAAAA,KAAK,CAAEC,KAAF,EAASC,QAAT,EAAmBC,EAAnB,EAAuB;AAC1B,UAAMC,MAAM,GAAGC,MAAM,CAACC,QAAP,CAAgBL,KAAhB,IAAyBA,KAAzB,GACX,OAAOA,KAAP,KAAiB,QAAjB,GACAI,MAAM,CAACE,IAAP,CAAYN,KAAZ,EAAmB,OAAOC,QAAP,KAAoB,QAApB,GAA+BA,QAA/B,GAA0C,MAA7D,CADA,GAEAD,KAHJ;;AAKA,QAAI,CAACI,MAAM,CAACC,QAAP,CAAgBF,MAAhB,CAAL,EAA8B;AAC5B,WAAKI,IAAL,CAAU,OAAV,EAAmB,IAAIhB,SAAJ,CAAe,GAChC,KAAKT,WAAL,CAAiBK,IAClB,gDAFkB,CAAnB;AAGA,aAAO,KAAP;AACD;;AAED,SAAKJ,KAAL,IAAcoB,MAAM,CAACK,MAArB;AACA,QAAI,KAAKzB,KAAL,GAAa,KAAKC,MAAtB,EACE,KAAKuB,IAAL,CAAU,OAAV,EAAmB,IAAI3B,SAAJ,CAAc,KAAKG,KAAnB,EAA0B,KAAKC,MAA/B,CAAnB;AAEF,WAAO,MAAMe,KAAN,CAAYC,KAAZ,EAAmBC,QAAnB,EAA6BC,EAA7B,CAAP;AACD;;AAEDK,EAAAA,IAAI,CAAEE,EAAF,EAAM,GAAGC,IAAT,EAAe;AACjB,QAAID,EAAE,KAAK,KAAX,EAAkB;AAChB,UAAI,KAAK1B,KAAL,KAAe,KAAKC,MAAxB,EACE,KAAKuB,IAAL,CAAU,OAAV,EAAmB,IAAI3B,SAAJ,CAAc,KAAKG,KAAnB,EAA0B,KAAKC,MAA/B,CAAnB;AACH;;AACD,WAAO,MAAMuB,IAAN,CAAWE,EAAX,EAAe,GAAGC,IAAlB,CAAP;AACD;;AA9CkC;;AAiDrCtB,aAAa,CAACR,SAAd,GAA0BA,SAA1B;AAEA+B,MAAM,CAACC,OAAP,GAAiBxB,aAAjB","sourcesContent":["const Minipass = require('minipass')\n\nclass SizeError extends Error {\n  constructor (found, expect) {\n    super(`Bad data size: expected ${expect} bytes, but got ${found}`)\n    this.expect = expect\n    this.found = found\n    this.code = 'EBADSIZE'\n\t  Error.captureStackTrace(this, this.constructor)\n  }\n  get name () {\n    return 'SizeError'\n  }\n}\n\nclass MinipassSized extends Minipass {\n  constructor (options = {}) {\n    super(options)\n\n    if (options.objectMode)\n      throw new TypeError(`${\n        this.constructor.name\n      } streams only work with string and buffer data`)\n\n    this.found = 0\n    this.expect = options.size\n    if (typeof this.expect !== 'number' ||\n        this.expect > Number.MAX_SAFE_INTEGER ||\n        isNaN(this.expect) ||\n        this.expect < 0 ||\n        !isFinite(this.expect) ||\n        this.expect !== Math.floor(this.expect))\n      throw new Error('invalid expected size: ' + this.expect)\n  }\n\n  write (chunk, encoding, cb) {\n    const buffer = Buffer.isBuffer(chunk) ? chunk\n      : typeof chunk === 'string' ?\n        Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8')\n      : chunk\n\n    if (!Buffer.isBuffer(buffer)) {\n      this.emit('error', new TypeError(`${\n        this.constructor.name\n      } streams only work with string and buffer data`))\n      return false\n    }\n\n    this.found += buffer.length\n    if (this.found > this.expect)\n      this.emit('error', new SizeError(this.found, this.expect))\n\n    return super.write(chunk, encoding, cb)\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'end') {\n      if (this.found !== this.expect)\n        this.emit('error', new SizeError(this.found, this.expect))\n    }\n    return super.emit(ev, ...data)\n  }\n}\n\nMinipassSized.SizeError = SizeError\n\nmodule.exports = MinipassSized\n"]},"metadata":{},"sourceType":"script"}