{"ast":null,"code":"'use strict';\n\nconst Minipass = require('minipass');\n\nconst MinipassSized = require('minipass-sized');\n\nconst Blob = require('./blob.js');\n\nconst {\n  BUFFER\n} = Blob;\n\nconst FetchError = require('./fetch-error.js'); // optional dependency on 'encoding'\n\n\nlet convert;\n\ntry {\n  convert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\nconst CONSUME_BODY = Symbol('consumeBody');\n\nclass Body {\n  constructor(bodyArg, options = {}) {\n    const {\n      size = 0,\n      timeout = 0\n    } = options;\n    const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].body;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n\n  arrayBuffer() {\n    return this[CONSUME_BODY]().then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  }\n\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return this[CONSUME_BODY]().then(buf => Object.assign(new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  }\n\n  json() {\n    return this[CONSUME_BODY]().then(buf => {\n      try {\n        return JSON.parse(buf.toString());\n      } catch (er) {\n        return Promise.reject(new FetchError(`invalid json response body at ${this.url} reason: ${er.message}`, 'invalid-json'));\n      }\n    });\n  }\n\n  text() {\n    return this[CONSUME_BODY]().then(buf => buf.toString());\n  }\n\n  buffer() {\n    return this[CONSUME_BODY]();\n  }\n\n  textConverted() {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers));\n  }\n\n  [CONSUME_BODY]() {\n    if (this[INTERNALS].disturbed) return Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) return Promise.reject(this[INTERNALS].error); // body is null\n\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n\n    if (Buffer.isBuffer(this.body)) return Promise.resolve(this.body);\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body;\n    /* istanbul ignore if: should never happen */\n\n    if (!Minipass.isStream(upstream)) return Promise.resolve(Buffer.alloc(0));\n    const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({\n      size: this.size\n    }) : new Minipass(); // allow timeout on slow response body\n\n    const resTimeout = this.timeout ? setTimeout(() => {\n      stream.emit('error', new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n    }, this.timeout) : null; // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n\n    if (resTimeout) {\n      resTimeout.unref();\n    } // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n\n\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er));\n        upstream.pipe(stream);\n      }\n\n      resolve();\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout);\n      return buf;\n    }).catch(er => {\n      clearTimeout(resTimeout); // request was aborted, reject with this Error\n\n      if (er.name === 'AbortError' || er.name === 'FetchError') throw er;else if (er.name === 'RangeError') throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, 'system', er);else // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n    });\n  }\n\n  static clone(instance) {\n    if (instance.bodyUsed) throw new Error('cannot clone body after it is used');\n    const body = instance.body; // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass();\n      const p1 = new Minipass();\n      const p2 = new Minipass();\n      tee.on('error', er => {\n        p1.emit('error', er);\n        p2.emit('error', er);\n      });\n      body.on('error', er => tee.emit('error', er));\n      tee.pipe(p1);\n      tee.pipe(p2);\n      body.pipe(tee); // set instance body to one fork, return the other\n\n      instance[INTERNALS].body = p1;\n      return p2;\n    } else return instance.body;\n  }\n\n  static extractContentType(body) {\n    return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';\n  }\n\n  static getTotalBytes(instance) {\n    const {\n      body\n    } = instance;\n    return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && ( // detect form data input from form-data module\n    body._lengthRetrievers &&\n    /* istanbul ignore next */\n    body._lengthRetrievers.length == 0 || // 1.x\n    body.hasKnownLength && body.hasKnownLength()) // 2.x\n    ? body.getLengthSync() : null;\n  }\n\n  static writeToStream(dest, instance) {\n    const {\n      body\n    } = instance;\n    if (body === null || body === undefined) dest.end();else if (Buffer.isBuffer(body) || typeof body === 'string') dest.end(body);else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body;\n      stream.on('error', er => dest.emit('error', er)).pipe(dest);\n    }\n    return dest;\n  }\n\n}\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n\nconst isURLSearchParams = obj => // Duck-typing as a necessary condition.\ntypeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false // Brand-checking and more duck-typing as optional condition.\n: obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n\nconst isBlob = obj => typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  const ct = headers && headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str; // header\n\n  if (ct) res = /charset=([^;]*)/i.exec(ct); // no charset in content type, peek at response body for at most 1024 bytes\n\n  str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str); // html4\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n      if (res) res.pop(); // drop last quote\n    }\n\n    if (res) res = /charset=(.*)/i.exec(res.pop());\n  } // xml\n\n\n  if (!res && str) res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str); // found charset\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') charset = 'gb18030';\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n};\n\nmodule.exports = Body;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/minipass-fetch/lib/body.js"],"names":["Minipass","require","MinipassSized","Blob","BUFFER","FetchError","convert","e","INTERNALS","Symbol","CONSUME_BODY","Body","constructor","bodyArg","options","size","timeout","body","undefined","isURLSearchParams","Buffer","from","toString","isBlob","isBuffer","Object","prototype","call","ArrayBuffer","isView","buffer","byteOffset","byteLength","isStream","String","disturbed","error","on","er","name","url","message","bodyUsed","arrayBuffer","then","buf","slice","blob","ct","headers","get","assign","type","toLowerCase","json","JSON","parse","Promise","reject","text","textConverted","convertBody","TypeError","resolve","alloc","upstream","stream","resTimeout","setTimeout","emit","unref","pipe","concat","clearTimeout","catch","clone","instance","Error","getBoundary","tee","p1","p2","extractContentType","getTotalBytes","length","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","defineProperties","enumerable","obj","append","delete","getAll","has","set","sort","test","toStringTag","charset","res","str","exec","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst Minipass = require('minipass')\nconst MinipassSized = require('minipass-sized')\n\nconst Blob = require('./blob.js')\nconst {BUFFER} = Blob\nconst FetchError = require('./fetch-error.js')\n\n// optional dependency on 'encoding'\nlet convert\ntry {\n  convert = require('encoding').convert\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals')\nconst CONSUME_BODY = Symbol('consumeBody')\n\nclass Body {\n  constructor (bodyArg, options = {}) {\n    const { size = 0, timeout = 0 } = options\n    const body = bodyArg === undefined || bodyArg === null ? null\n      : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString())\n      : isBlob(bodyArg) ? bodyArg\n      : Buffer.isBuffer(bodyArg) ? bodyArg\n      : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]'\n        ? Buffer.from(bodyArg)\n      : ArrayBuffer.isView(bodyArg)\n        ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength)\n      : Minipass.isStream(bodyArg) ? bodyArg\n      : Buffer.from(String(bodyArg))\n\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null,\n    }\n\n    this.size = size\n    this.timeout = timeout\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er\n          : new FetchError(`Invalid response while trying to fetch ${\n            this.url}: ${er.message}`, 'system', er)\n        this[INTERNALS].error = error\n      })\n    }\n  }\n\n  get body () {\n    return this[INTERNALS].body\n  }\n\n  get bodyUsed () {\n    return this[INTERNALS].disturbed\n  }\n\n  arrayBuffer () {\n    return this[CONSUME_BODY]().then(buf =>\n      buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  }\n\n  blob () {\n    const ct = this.headers && this.headers.get('content-type') || ''\n    return this[CONSUME_BODY]().then(buf => Object.assign(\n      new Blob([], { type: ct.toLowerCase() }),\n      { [BUFFER]: buf }\n    ))\n  }\n\n  json () {\n    return this[CONSUME_BODY]().then(buf => {\n      try {\n        return JSON.parse(buf.toString())\n      } catch (er) {\n        return Promise.reject(new FetchError(\n          `invalid json response body at ${\n            this.url} reason: ${er.message}`, 'invalid-json'))\n      }\n    })\n  }\n\n  text () {\n    return this[CONSUME_BODY]().then(buf => buf.toString())\n  }\n\n  buffer () {\n    return this[CONSUME_BODY]()\n  }\n\n  textConverted () {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers))\n  }\n\n  [CONSUME_BODY] () {\n    if (this[INTERNALS].disturbed)\n      return Promise.reject(new TypeError(`body used already for: ${\n        this.url}`))\n\n    this[INTERNALS].disturbed = true\n\n    if (this[INTERNALS].error)\n      return Promise.reject(this[INTERNALS].error)\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    if (Buffer.isBuffer(this.body))\n      return Promise.resolve(this.body)\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream))\n      return Promise.resolve(Buffer.alloc(0))\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream\n      : !this.size && upstream instanceof Minipass &&\n        !(upstream instanceof MinipassSized) ? upstream\n      : this.size ? new MinipassSized({ size: this.size })\n      : new Minipass()\n\n    // allow timeout on slow response body\n    const resTimeout = this.timeout ? setTimeout(() => {\n      stream.emit('error', new FetchError(\n        `Response timeout while trying to fetch ${\n          this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n    }, this.timeout) : null\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout) {\n      resTimeout.unref()\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er))\n        upstream.pipe(stream)\n      }\n      resolve()\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout)\n      return buf\n    }).catch(er => {\n      clearTimeout(resTimeout)\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError')\n        throw er\n      else if (er.name === 'RangeError')\n        throw new FetchError(`Could not create Buffer from response body for ${\n          this.url}: ${er.message}`, 'system', er)\n      else\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${\n          this.url}: ${er.message}`, 'system', er)\n    })\n  }\n\n  static clone (instance) {\n    if (instance.bodyUsed)\n      throw new Error('cannot clone body after it is used')\n\n    const body = instance.body\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass()\n      const p1 = new Minipass()\n      const p2 = new Minipass()\n      tee.on('error', er => {\n        p1.emit('error', er)\n        p2.emit('error', er)\n      })\n      body.on('error', er => tee.emit('error', er))\n      tee.pipe(p1)\n      tee.pipe(p2)\n      body.pipe(tee)\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1\n      return p2\n    } else\n      return instance.body\n  }\n\n  static extractContentType (body) {\n    return body === null || body === undefined ? null\n      : typeof body === 'string' ? 'text/plain;charset=UTF-8'\n      : isURLSearchParams(body)\n        ? 'application/x-www-form-urlencoded;charset=UTF-8'\n      : isBlob(body) ? body.type || null\n      : Buffer.isBuffer(body) ? null\n      : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null\n      : ArrayBuffer.isView(body) ? null\n      : typeof body.getBoundary === 'function'\n        ? `multipart/form-data;boundary=${body.getBoundary()}`\n      : Minipass.isStream(body) ? null\n      : 'text/plain;charset=UTF-8'\n  }\n\n  static getTotalBytes (instance) {\n    const {body} = instance\n    return (body === null || body === undefined) ? 0\n    : isBlob(body) ? body.size\n    : Buffer.isBuffer(body) ? body.length\n    : body && typeof body.getLengthSync === 'function' && (\n        // detect form data input from form-data module\n        body._lengthRetrievers &&\n        /* istanbul ignore next */ body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) // 2.x\n      ? body.getLengthSync()\n    : null\n  }\n\n  static writeToStream (dest, instance) {\n    const {body} = instance\n\n    if (body === null || body === undefined)\n      dest.end()\n    else if (Buffer.isBuffer(body) || typeof body === 'string')\n      dest.end(body)\n    else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body\n      stream.on('error', er => dest.emit('error', er)).pipe(dest)\n    }\n\n    return dest\n  }\n}\n\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true }\n})\n\n\nconst isURLSearchParams = obj =>\n  // Duck-typing as a necessary condition.\n  (typeof obj !== 'object' ||\n    typeof obj.append !== 'function' ||\n    typeof obj.delete !== 'function' ||\n    typeof obj.get !== 'function' ||\n    typeof obj.getAll !== 'function' ||\n    typeof obj.has !== 'function' ||\n    typeof obj.set !== 'function') ? false\n  // Brand-checking and more duck-typing as optional condition.\n  : obj.constructor.name === 'URLSearchParams' ||\n    Object.prototype.toString.call(obj) === '[object URLSearchParams]' ||\n    typeof obj.sort === 'function'\n\nconst isBlob = obj =>\n  typeof obj === 'object' &&\n  typeof obj.arrayBuffer === 'function' &&\n  typeof obj.type === 'string' &&\n  typeof obj.stream === 'function' &&\n  typeof obj.constructor === 'function' &&\n  typeof obj.constructor.name === 'string' &&\n  /^(Blob|File)$/.test(obj.constructor.name) &&\n  /^(Blob|File)$/.test(obj[Symbol.toStringTag])\n\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function')\n    throw new Error('The package `encoding` must be installed to use the textConverted() function')\n\n  const ct = headers && headers.get('content-type')\n  let charset = 'utf-8'\n  let res, str\n\n  // header\n  if (ct)\n    res = /charset=([^;]*)/i.exec(ct)\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str)\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str)\n      if (res)\n        res.pop() // drop last quote\n    }\n\n    if (res)\n      res = /charset=(.*)/i.exec(res.pop())\n  }\n\n  // xml\n  if (!res && str)\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk')\n      charset = 'gb18030'\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer,\n    'UTF-8',\n    charset\n  ).toString()\n}\n\nmodule.exports = Body\n"]},"metadata":{},"sourceType":"script"}