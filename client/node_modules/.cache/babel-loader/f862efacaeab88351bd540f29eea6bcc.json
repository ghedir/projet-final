{"ast":null,"code":"const {\n  depth\n} = require('treeverse');\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false;\n    tree.optional = false;\n    tree.devOptional = false;\n    tree.peer = false;\n  }\n\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) => [...tree.edgesOut.values()].map(edge => edge.to)\n  });\n  return ret;\n};\n\nconst calcDepFlagsStep = node => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false;\n  resetParents(node, 'extraneous');\n  resetParents(node, 'dev');\n  resetParents(node, 'peer');\n  resetParents(node, 'devOptional');\n  resetParents(node, 'optional'); // for links, map their hierarchy appropriately\n\n  if (node.isLink) {\n    node.target.dev = node.dev;\n    node.target.optional = node.optional;\n    node.target.devOptional = node.devOptional;\n    node.target.peer = node.peer;\n    return calcDepFlagsStep(node.target);\n  }\n\n  node.edgesOut.forEach(({\n    peer,\n    optional,\n    dev,\n    to\n  }) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) {\n      return;\n    } // everything with any kind of edge into it is not extraneous\n\n\n    to.extraneous = false; // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional && !dev && !optional; // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n\n    const unsetDev = unsetDevOpt || !node.dev && !dev;\n    const unsetOpt = unsetDevOpt || !node.optional && !optional;\n    const unsetPeer = !node.peer && !peer;\n\n    if (unsetPeer) {\n      unsetFlag(to, 'peer');\n    }\n\n    if (unsetDevOpt) {\n      unsetFlag(to, 'devOptional');\n    }\n\n    if (unsetDev) {\n      unsetFlag(to, 'dev');\n    }\n\n    if (unsetOpt) {\n      unsetFlag(to, 'optional');\n    }\n  });\n  return node;\n};\n\nconst resetParents = (node, flag) => {\n  if (node[flag]) {\n    return;\n  }\n\n  for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {\n    p[flag] = false;\n  }\n}; // typically a short walk, since it only traverses deps that\n// have the flag set.\n\n\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false;\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false;\n\n        if (node.isLink) {\n          node.target.extraneous = node.target[flag] = false;\n        }\n      },\n      getChildren: node => [...node.target.edgesOut.values()].filter(edge => edge.to && edge.to[flag] && (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod')).map(edge => edge.to)\n    });\n  }\n};\n\nmodule.exports = calcDepFlags;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/calc-dep-flags.js"],"names":["depth","require","calcDepFlags","tree","resetRoot","dev","optional","devOptional","peer","ret","visit","node","calcDepFlagsStep","filter","getChildren","edgesOut","values","map","edge","to","extraneous","resetParents","isLink","target","forEach","unsetDevOpt","unsetDev","unsetOpt","unsetPeer","unsetFlag","flag","p","resolveParent","type","module","exports"],"mappings":"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","sourcesContent":["const { depth } = require('treeverse')\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false\n    tree.optional = false\n    tree.devOptional = false\n    tree.peer = false\n  }\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) =>\n      [...tree.edgesOut.values()].map(edge => edge.to),\n  })\n  return ret\n}\n\nconst calcDepFlagsStep = (node) => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false\n  resetParents(node, 'extraneous')\n  resetParents(node, 'dev')\n  resetParents(node, 'peer')\n  resetParents(node, 'devOptional')\n  resetParents(node, 'optional')\n\n  // for links, map their hierarchy appropriately\n  if (node.isLink) {\n    node.target.dev = node.dev\n    node.target.optional = node.optional\n    node.target.devOptional = node.devOptional\n    node.target.peer = node.peer\n    return calcDepFlagsStep(node.target)\n  }\n\n  node.edgesOut.forEach(({peer, optional, dev, to}) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) {\n      return\n    }\n\n    // everything with any kind of edge into it is not extraneous\n    to.extraneous = false\n\n    // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional &&\n      !dev && !optional\n\n    // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n    const unsetDev = unsetDevOpt || !node.dev && !dev\n    const unsetOpt = unsetDevOpt ||\n      !node.optional && !optional\n    const unsetPeer = !node.peer && !peer\n\n    if (unsetPeer) {\n      unsetFlag(to, 'peer')\n    }\n\n    if (unsetDevOpt) {\n      unsetFlag(to, 'devOptional')\n    }\n\n    if (unsetDev) {\n      unsetFlag(to, 'dev')\n    }\n\n    if (unsetOpt) {\n      unsetFlag(to, 'optional')\n    }\n  })\n\n  return node\n}\n\nconst resetParents = (node, flag) => {\n  if (node[flag]) {\n    return\n  }\n\n  for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {\n    p[flag] = false\n  }\n}\n\n// typically a short walk, since it only traverses deps that\n// have the flag set.\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false\n        if (node.isLink) {\n          node.target.extraneous = node.target[flag] = false\n        }\n      },\n      getChildren: node => [...node.target.edgesOut.values()]\n        .filter(edge => edge.to && edge.to[flag] &&\n          (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod'))\n        .map(edge => edge.to),\n    })\n  }\n}\n\nmodule.exports = calcDepFlags\n"]},"metadata":{},"sourceType":"script"}