{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst ssri = require('ssri');\n\nconst Minipass = require('minipass'); // Corgis are cute. üêïüê∂\n\n\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\n\nconst fetch = require('npm-registry-fetch'); // TODO: memoize reg requests, so we don't even have to check cache\n\n\nconst _headers = Symbol('_headers');\n\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n\n    this.packumentCache = this.opts.packumentCache || null; // handle case when npm-package-arg guesses wrong.\n\n    if (this.spec.type === 'tag' && this.spec.rawSpec === '' && this.defaultTag !== 'latest') this.spec = npa(`${this.spec.name}@${this.defaultTag}`);\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = this.registry.replace(/\\/*$/, '/') + this.spec.escapedName; // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  resolve() {\n    if (this.resolved) return Promise.resolve(this.resolved); // fetching the manifest sets resolved and (usually) integrity\n\n    return this.manifest().then(() => {\n      if (this.resolved) return this.resolved;\n      throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n        package: this.spec.toString()\n      });\n    });\n  }\n\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n\n  async packument() {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) return this.packumentCache.get(this.packumentUrl); // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n\n    const p = fetch(this.packumentUrl, { ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      // never check integrity for packuments themselves\n      integrity: null\n    }).then(res => res.json().then(packument => {\n      packument._cached = res.headers.has('x-local-cache');\n      packument._contentLength = +res.headers.get('content-length');\n      if (this.packumentCache) this.packumentCache.set(this.packumentUrl, packument);\n      return packument;\n    })).catch(er => {\n      if (this.packumentCache) this.packumentCache.delete(this.packumentUrl);\n\n      if (er.code === 'E404' && !this.fullMetadata) {\n        // possible that corgis are not supported by this registry\n        this.fullMetadata = true;\n        return this.packument();\n      }\n\n      throw er;\n    });\n    if (this.packumentCache) this.packumentCache.set(this.packumentUrl, p);\n    return p;\n  }\n\n  manifest() {\n    if (this.package) return Promise.resolve(this.package);\n    return this.packument().then(packument => pickManifest(packument, this.spec.fetchSpec, { ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before\n    })\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n    ).then(mani => {\n      // add _resolved and _integrity from dist object\n      const {\n        dist\n      } = mani;\n\n      if (dist) {\n        this.resolved = mani._resolved = dist.tarball;\n        mani._from = this.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts\n        }) : null;\n\n        if (distIntegrity) {\n          if (!this.integrity) this.integrity = distIntegrity;else if (!this.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(this.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${this.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            } // made it this far, the integrity is worthwhile.  accept it.\n            // the setter here will take care of merging it into what we\n            // already had.\n\n\n            this.integrity = distIntegrity;\n          }\n        }\n      }\n\n      if (this.integrity) mani._integrity = String(this.integrity);\n      this.package = rpj.normalize(mani);\n      return this.package;\n    });\n  }\n\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, { ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n\n}\n\nmodule.exports = RegistryFetcher;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/pacote/lib/registry.js"],"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","npa","rpj","pickManifest","ssri","Minipass","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","type","rawSpec","defaultTag","name","registry","pickRegistry","packumentUrl","replace","escapedName","resolve","resolved","Promise","manifest","then","Object","assign","Error","package","toString","userAgent","process","headers","accept","fullMetadata","packument","has","get","p","integrity","res","json","_cached","_contentLength","set","catch","er","delete","code","fetchSpec","before","mani","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","normalize","pkgid","types","module","exports"],"mappings":"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","sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst Minipass = require('minipass')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\n// TODO: memoize reg requests, so we don't even have to check cache\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    // handle case when npm-package-arg guesses wrong.\n    if (this.spec.type === 'tag' &&\n        this.spec.rawSpec === '' &&\n        this.defaultTag !== 'latest')\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`)\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = this.registry.replace(/\\/*$/, '/') +\n      this.spec.escapedName\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  resolve () {\n    if (this.resolved)\n      return Promise.resolve(this.resolved)\n\n    // fetching the manifest sets resolved and (usually) integrity\n    return this.manifest().then(() => {\n      if (this.resolved)\n        return this.resolved\n\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    })\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl))\n      return this.packumentCache.get(this.packumentUrl)\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    const p = fetch(this.packumentUrl, {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      // never check integrity for packuments themselves\n      integrity: null,\n    }).then(res => res.json().then(packument => {\n      packument._cached = res.headers.has('x-local-cache')\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache)\n        this.packumentCache.set(this.packumentUrl, packument)\n      return packument\n    })).catch(er => {\n      if (this.packumentCache)\n        this.packumentCache.delete(this.packumentUrl)\n      if (er.code === 'E404' && !this.fullMetadata) {\n        // possible that corgis are not supported by this registry\n        this.fullMetadata = true\n        return this.packument()\n      }\n      throw er\n    })\n    if (this.packumentCache)\n      this.packumentCache.set(this.packumentUrl, p)\n    return p\n  }\n\n  manifest () {\n    if (this.package)\n      return Promise.resolve(this.package)\n\n    return this.packument()\n      .then(packument => pickManifest(packument, this.spec.fetchSpec, {\n        ...this.opts,\n        defaultTag: this.defaultTag,\n        before: this.before,\n      }) /* XXX add ETARGET and E403 revalidation of cached packuments here */)\n      .then(mani => {\n        // add _resolved and _integrity from dist object\n        const { dist } = mani\n        if (dist) {\n          this.resolved = mani._resolved = dist.tarball\n          mani._from = this.from\n          const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n            : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', {...this.opts})\n            : null\n          if (distIntegrity) {\n            if (!this.integrity)\n              this.integrity = distIntegrity\n            else if (!this.integrity.match(distIntegrity)) {\n              // only bork if they have algos in common.\n              // otherwise we end up breaking if we have saved a sha512\n              // previously for the tarball, but the manifest only\n              // provides a sha1, which is possible for older publishes.\n              // Otherwise, this is almost certainly a case of holding it\n              // wrong, and will result in weird or insecure behavior\n              // later on when building package tree.\n              for (const algo of Object.keys(this.integrity)) {\n                if (distIntegrity[algo]) {\n                  throw Object.assign(new Error(\n                    `Integrity checksum failed when using ${algo}: `+\n                    `wanted ${this.integrity} but got ${distIntegrity}.`\n                  ), { code: 'EINTEGRITY' })\n                }\n              }\n              // made it this far, the integrity is worthwhile.  accept it.\n              // the setter here will take care of merging it into what we\n              // already had.\n              this.integrity = distIntegrity\n            }\n          }\n        }\n        if (this.integrity)\n          mani._integrity = String(this.integrity)\n        this.package = rpj.normalize(mani)\n        return this.package\n      })\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"]},"metadata":{},"sourceType":"script"}