{"ast":null,"code":"// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\nconst semver = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  relative\n} = require('path');\n\nconst fromPath = require('./from-path.js');\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor));\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name;\n      er.requested = requested;\n      requestor.errors.push(er);\n      return false;\n    }\n  } // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n\n\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier');\n    er.dependency = child.name;\n    er.requested = requested;\n    requestor.errors.push(er);\n    return false;\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true;\n      }\n\n    // fallthrough\n\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true);\n\n    case 'directory':\n      // directory must be a link to the specified folder\n      return !!child.isLink && relative(child.realpath, requested.fetchSpec) === '';\n\n    case 'file':\n      return tarballValid(child, requested, requestor);\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor);\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote';\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec;\n\n    case 'git':\n      {\n        // if it's a git type, verify that they're the same repo\n        //\n        // if it specifies a definite commit, then it must have the\n        // same commit to be considered the same repo\n        //\n        // if it has a #semver:<range> specifier, verify that the\n        // version in the package is in the semver range\n        const resRepo = npa(child.resolved || '');\n        const resHost = resRepo.hosted;\n        const reqHost = requested.hosted;\n        const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '');\n        const nc = {\n          noCommittish: !reqCommit\n        };\n        const sameRepo = resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc) : resRepo.fetchSpec === requested.fetchSpec;\n        return !sameRepo ? false : !requested.gitRange ? true : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true\n        });\n      }\n\n    default:\n      // unpossible, just being cautious\n      break;\n  }\n\n  const er = new Error('Unsupported dependency type');\n  er.dependency = child.name;\n  er.requested = requested;\n  requestor.errors.push(er);\n  return false;\n};\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false;\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`;\n  } // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n\n\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec;\n  } // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n\n\n  return false;\n};\n\nmodule.exports = (child, requested, accept, requestor) => depValid(child, requested, requestor) || (typeof accept === 'string' ? depValid(child, accept, requestor) : false);","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/dep-valid.js"],"names":["semver","require","npa","relative","fromPath","depValid","child","requested","requestor","resolve","name","er","dependency","errors","push","Error","type","fetchSpec","satisfies","version","isLink","realpath","tarballValid","subSpec","resolved","resRepo","resHost","hosted","reqHost","reqCommit","test","gitCommittish","nc","noCommittish","sameRepo","ssh","gitRange","package","loose","replace","_requested","saveSpec","module","exports","accept"],"mappings":"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","sourcesContent":["// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\n\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst {relative} = require('path')\nconst fromPath = require('./from-path.js')\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor))\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name\n      er.requested = requested\n      requestor.errors.push(er)\n      return false\n    }\n  }\n\n  // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier')\n    er.dependency = child.name\n    er.requested = requested\n    requestor.errors.push(er)\n    return false\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true\n      }\n      // fallthrough\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true)\n\n    case 'directory':\n      // directory must be a link to the specified folder\n      return !!child.isLink &&\n        relative(child.realpath, requested.fetchSpec) === ''\n\n    case 'file':\n      return tarballValid(child, requested, requestor)\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor)\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote'\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec\n\n    case 'git': {\n      // if it's a git type, verify that they're the same repo\n      //\n      // if it specifies a definite commit, then it must have the\n      // same commit to be considered the same repo\n      //\n      // if it has a #semver:<range> specifier, verify that the\n      // version in the package is in the semver range\n      const resRepo = npa(child.resolved || '')\n      const resHost = resRepo.hosted\n      const reqHost = requested.hosted\n      const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '')\n      const nc = { noCommittish: !reqCommit }\n      const sameRepo =\n        resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc)\n        : resRepo.fetchSpec === requested.fetchSpec\n\n      return !sameRepo ? false\n        : !requested.gitRange ? true\n        : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true,\n        })\n    }\n\n    default: // unpossible, just being cautious\n      break\n  }\n\n  const er = new Error('Unsupported dependency type')\n  er.dependency = child.name\n  er.requested = requested\n  requestor.errors.push(er)\n  return false\n}\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`\n  }\n\n  // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec\n  }\n\n  // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n  return false\n}\n\nmodule.exports = (child, requested, accept, requestor) =>\n  depValid(child, requested, requestor) ||\n  (typeof accept === 'string' ? depValid(child, accept, requestor) : false)\n"]},"metadata":{},"sourceType":"script"}