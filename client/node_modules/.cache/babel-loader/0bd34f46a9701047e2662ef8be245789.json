{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst path = require('path');\n\nconst getName = require('@npmcli/name-from-folder');\n\nconst minimatch = require('minimatch');\n\nconst rpj = require('read-package-json-fast');\n\nconst glob = require('glob');\n\nconst pGlob = promisify(glob);\n\nfunction appendNegatedPatterns(patterns) {\n  const results = [];\n\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/);\n\n    if (excl) {\n      pattern = pattern.substr(excl[0].length);\n    } // strip off any / from the start of the pattern.  /foo => foo\n\n\n    pattern = pattern.replace(/^\\/+/, ''); // an odd number of ! means a negated pattern.  !!foo ==> foo\n\n    const negate = excl && excl[0].length % 2 === 1;\n    results.push({\n      pattern,\n      negate\n    });\n  }\n\n  return results;\n}\n\nfunction getPatterns(workspaces) {\n  const workspacesDeclaration = Array.isArray(workspaces.packages) ? workspaces.packages : workspaces;\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG'\n    });\n  }\n\n  return [...appendNegatedPatterns(workspacesDeclaration), {\n    pattern: '**/node_modules/**',\n    negate: true\n  }];\n}\n\nfunction isEmpty(patterns) {\n  return patterns.length < 2;\n}\n\nfunction getPackageName(pkg, pathname) {\n  const {\n    name\n  } = pkg;\n  return name || getName(pathname);\n}\n\nfunction pkgPathmame(opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd();\n    return path.join.apply(null, [cwd, ...args]);\n  };\n} // make sure glob pattern only matches folders\n\n\nfunction getGlobPattern(pattern) {\n  return pattern.endsWith('/') ? pattern : `${pattern}/`;\n}\n\nfunction getError({\n  Type = TypeError,\n  message,\n  code\n}) {\n  return Object.assign(new Type(message), {\n    code\n  });\n}\n\nfunction reverseResultMap(map) {\n  return new Map(Array.from(map, item => item.reverse()));\n}\n\nasync function mapWorkspaces(opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG'\n    });\n  }\n\n  const {\n    workspaces = []\n  } = opts.pkg;\n  const patterns = getPatterns(workspaces);\n  const results = new Map();\n  const seen = new Map();\n\n  if (isEmpty(patterns)) {\n    return results;\n  }\n\n  const getGlobOpts = () => ({ ...opts,\n    ignore: [...(opts.ignore || []), ...['**/node_modules/**']]\n  });\n\n  const getPackagePathname = pkgPathmame(opts);\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts());\n\n    for (const match of matches) {\n      let pkg;\n      const packageJsonPathname = getPackagePathname(match, 'package.json');\n      const packagePathname = path.dirname(packageJsonPathname);\n\n      try {\n        pkg = await rpj(packageJsonPathname);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname);\n\n      if (item.negate) {\n        results.delete(packagePathname, name);\n      } else {\n        if (seen.has(name) && seen.get(name) !== packagePathname) {\n          throw getError({\n            Type: Error,\n            message: ['must not have multiple workspaces with the same name', `package '${name}' has conflicts in the following paths:`, '    ' + seen.get(name), '    ' + packagePathname].join('\\n'),\n            code: 'EDUPLICATEWORKSPACE'\n          });\n        }\n\n        seen.set(name, packagePathname);\n        results.set(packagePathname, name);\n      }\n    }\n  }\n\n  return reverseResultMap(results);\n}\n\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE'\n    });\n  }\n\n  const {\n    packages = {}\n  } = opts.lockfile;\n  const {\n    workspaces = []\n  } = packages[''] || {};\n  const patterns = getPatterns(workspaces); // uses a pathname-keyed map in order to negate the exact items\n\n  const results = new Map();\n\n  if (isEmpty(patterns)) {\n    return results;\n  }\n\n  const getPackagePathname = pkgPathmame(opts);\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue;\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey);\n        const name = getPackageName(packages[packageKey], packagePathname);\n\n        if (item.negate) {\n          results.delete(packagePathname);\n        } else {\n          results.set(packagePathname, name);\n        }\n      }\n    }\n  } // Invert pathname-keyed to a proper name-to-pathnames Map\n\n\n  return reverseResultMap(results);\n};\n\nmodule.exports = mapWorkspaces;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/map-workspaces/index.js"],"names":["promisify","require","path","getName","minimatch","rpj","glob","pGlob","appendNegatedPatterns","patterns","results","pattern","excl","match","substr","length","replace","negate","push","getPatterns","workspaces","workspacesDeclaration","Array","isArray","packages","getError","message","code","isEmpty","getPackageName","pkg","pathname","name","pkgPathmame","opts","args","cwd","process","join","apply","getGlobPattern","endsWith","Type","TypeError","Object","assign","reverseResultMap","map","Map","from","item","reverse","mapWorkspaces","seen","getGlobOpts","ignore","getPackagePathname","matches","packageJsonPathname","packagePathname","dirname","err","delete","has","get","Error","set","virtual","lockfile","packageKey","keys","module","exports"],"mappings":"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","sourcesContent":["const { promisify } = require('util')\nconst path = require('path')\n\nconst getName = require('@npmcli/name-from-folder')\nconst minimatch = require('minimatch')\nconst rpj = require('read-package-json-fast')\nconst glob = require('glob')\nconst pGlob = promisify(glob)\n\nfunction appendNegatedPatterns (patterns) {\n  const results = []\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/)\n    if (excl) {\n      pattern = pattern.substr(excl[0].length)\n    }\n\n    // strip off any / from the start of the pattern.  /foo => foo\n    pattern = pattern.replace(/^\\/+/, '')\n\n    // an odd number of ! means a negated pattern.  !!foo ==> foo\n    const negate = excl && excl[0].length % 2 === 1\n    results.push({ pattern, negate })\n  }\n\n  return results\n}\n\nfunction getPatterns (workspaces) {\n  const workspacesDeclaration =\n    Array.isArray(workspaces.packages)\n      ? workspaces.packages\n      : workspaces\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG'\n    })\n  }\n\n  return [\n    ...appendNegatedPatterns(workspacesDeclaration),\n    { pattern: '**/node_modules/**', negate: true }\n  ]\n}\n\nfunction isEmpty (patterns) {\n  return patterns.length < 2\n}\n\nfunction getPackageName (pkg, pathname) {\n  const { name } = pkg\n  return name || getName(pathname)\n}\n\nfunction pkgPathmame (opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd()\n    return path.join.apply(null, [cwd, ...args])\n  }\n}\n\n// make sure glob pattern only matches folders\nfunction getGlobPattern (pattern) {\n  return pattern.endsWith('/')\n    ? pattern\n    : `${pattern}/`\n}\n\nfunction getError ({ Type = TypeError, message, code }) {\n  return Object.assign(new Type(message), { code })\n}\n\nfunction reverseResultMap (map) {\n  return new Map(Array.from(map, item => item.reverse()))\n}\n\nasync function mapWorkspaces (opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG'\n    })\n  }\n\n  const { workspaces = [] } = opts.pkg\n  const patterns = getPatterns(workspaces)\n  const results = new Map()\n  const seen = new Map()\n\n  if (isEmpty(patterns)) {\n    return results\n  }\n\n  const getGlobOpts = () => ({\n    ...opts,\n    ignore: [\n      ...opts.ignore || [],\n      ...['**/node_modules/**']\n    ]\n  })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts())\n\n    for (const match of matches) {\n      let pkg\n      const packageJsonPathname = getPackagePathname(match, 'package.json')\n      const packagePathname = path.dirname(packageJsonPathname)\n\n      try {\n        pkg = await rpj(packageJsonPathname)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue\n        } else {\n          throw err\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname)\n\n      if (item.negate) {\n        results.delete(packagePathname, name)\n      } else {\n        if (seen.has(name) && seen.get(name) !== packagePathname) {\n          throw getError({\n            Type: Error,\n            message: [\n              'must not have multiple workspaces with the same name',\n              `package '${name}' has conflicts in the following paths:`,\n              '    ' + seen.get(name),\n              '    ' + packagePathname\n            ].join('\\n'),\n            code: 'EDUPLICATEWORKSPACE'\n          })\n        }\n\n        seen.set(name, packagePathname)\n        results.set(packagePathname, name)\n      }\n    }\n  }\n\n  return reverseResultMap(results)\n}\n\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE'\n    })\n  }\n\n  const { packages = {} } = opts.lockfile\n  const { workspaces = [] } = packages[''] || {}\n  const patterns = getPatterns(workspaces)\n\n  // uses a pathname-keyed map in order to negate the exact items\n  const results = new Map()\n\n  if (isEmpty(patterns)) {\n    return results\n  }\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey)\n        const name = getPackageName(packages[packageKey], packagePathname)\n\n        if (item.negate) {\n          results.delete(packagePathname)\n        } else {\n          results.set(packagePathname, name)\n        }\n      }\n    }\n  }\n\n  // Invert pathname-keyed to a proper name-to-pathnames Map\n  return reverseResultMap(results)\n}\n\nmodule.exports = mapWorkspaces\n"]},"metadata":{},"sourceType":"script"}