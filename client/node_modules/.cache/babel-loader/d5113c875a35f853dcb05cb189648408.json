{"ast":null,"code":"// add and remove dependency specs to/from pkg manifest\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst add = ({\n  pkg,\n  add,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  for (const spec of add) {\n    addSingle({\n      pkg,\n      spec,\n      saveBundle,\n      saveType,\n      log\n    });\n  }\n\n  return pkg;\n}; // Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\n\n\nconst saveTypeMap = new Map([['dev', 'devDependencies'], ['optional', 'optionalDependencies'], ['prod', 'dependencies'], ['peerOptional', 'peerDependencies'], ['peer', 'peerDependencies']]);\n\nconst addSingle = ({\n  pkg,\n  spec,\n  saveBundle,\n  saveType,\n  log\n}) => {\n  const {\n    name,\n    rawSpec\n  } = spec; // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name);\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log);\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log);\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log);\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log);\n  } else {\n    // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log);\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log);\n  }\n\n  const depType = saveTypeMap.get(saveType);\n  pkg[depType] = pkg[depType] || {};\n\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*';\n  }\n\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {};\n    pkg.dependencies[name] = pkg.optionalDependencies[name];\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {};\n\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false;\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {};\n      pdm[name].optional = true;\n      pkg.peerDependenciesMeta = pdm;\n    } // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n\n\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name];\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || []);\n    bd.add(spec.name);\n    pkg.bundleDependencies = [...bd].sort(localeCompare);\n  }\n}; // Finds where the package is already in the spec and infers saveType from that\n\n\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (saveType === 'peerOptional' && (!hasSubKey(pkg, 'peerDependenciesMeta', name) || !pkg.peerDependenciesMeta[name].optional)) {\n        return 'peer';\n      }\n\n      return saveType;\n    }\n  }\n\n  return 'prod';\n};\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\n\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name);\n}; // Removes a subkey and warns about it if it's being replaced\n\n\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`);\n    }\n\n    delete pkg[depType][name]; // clean up peerDepsMeta if we are removing something from peerDependencies\n\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name];\n\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta;\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType];\n    }\n  }\n};\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name);\n    }\n  }\n\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies.filter(name => !rm.includes(name));\n\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies;\n    }\n  }\n\n  return pkg;\n};\n\nmodule.exports = {\n  add,\n  rm,\n  saveTypeMap,\n  hasSubKey\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"],"names":["localeCompare","require","add","pkg","saveBundle","saveType","log","spec","addSingle","saveTypeMap","Map","name","rawSpec","inferSaveType","deleteSubKey","depType","get","undefined","dependencies","optionalDependencies","pdm","peerDependenciesMeta","optional","devDependencies","peerDependencies","bd","Set","bundleDependencies","sort","keys","hasSubKey","hasOwnProperty","Object","prototype","call","replacedBy","warn","length","rm","values","filter","includes","module","exports"],"mappings":"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","sourcesContent":["// add and remove dependency specs to/from pkg manifest\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst add = ({pkg, add, saveBundle, saveType, log}) => {\n  for (const spec of add) {\n    addSingle({pkg, spec, saveBundle, saveType, log})\n  }\n\n  return pkg\n}\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([\n  ['dev', 'devDependencies'],\n  ['optional', 'optionalDependencies'],\n  ['prod', 'dependencies'],\n  ['peerOptional', 'peerDependencies'],\n  ['peer', 'peerDependencies'],\n])\n\nconst addSingle = ({pkg, spec, saveBundle, saveType, log}) => {\n  const { name, rawSpec } = spec\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name)\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies', log)\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies', log)\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies', log)\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies', log)\n  } else { // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies', log)\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies', log)\n  }\n\n  const depType = saveTypeMap.get(saveType)\n\n  pkg[depType] = pkg[depType] || {}\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*'\n  }\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {}\n    pkg.dependencies[name] = pkg.optionalDependencies[name]\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort(localeCompare)\n  }\n}\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (\n        saveType === 'peerOptional' &&\n        (!hasSubKey(pkg, 'peerDependenciesMeta', name) ||\n        !pkg.peerDependenciesMeta[name].optional)\n      ) {\n        return 'peer'\n      }\n      return saveType\n    }\n  }\n  return 'prod'\n}\n\nconst { hasOwnProperty } = Object.prototype\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name)\n}\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy, log) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy && log) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`)\n    }\n    delete pkg[depType][name]\n\n    // clean up peerDepsMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name]\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType]\n    }\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name)\n    }\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies\n    }\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm, saveTypeMap, hasSubKey }\n"]},"metadata":{},"sourceType":"script"}