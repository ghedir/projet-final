{"ast":null,"code":"// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en');\n\nconst rpj = require('read-package-json-fast');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst cacache = require('cacache');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst realpath = require('../../lib/realpath.js');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst treeCheck = require('../tree-check.js');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst fs = require('fs');\n\nconst lstat = promisify(fs.lstat);\nconst readlink = promisify(fs.readlink);\n\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT\n} = require('../can-place-dep.js');\n\nconst PlaceDep = require('../place-dep.js');\n\nconst debug = require('../debug.js');\n\nconst fromPath = require('../from-path.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js');\n\nconst optionalSet = require('../optional-set.js');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst relpath = require('../relpath.js'); // note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\n\n\nconst _complete = Symbol('complete');\n\nconst _depsSeen = Symbol('depsSeen');\n\nconst _depsQueue = Symbol('depsQueue');\n\nconst _currentDep = Symbol('currentDep');\n\nconst _updateAll = Symbol('updateAll');\n\nconst _mutateTree = Symbol('mutateTree');\n\nconst _flagsSuspect = Symbol.for('flagsSuspect');\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _prune = Symbol('prune');\n\nconst _preferDedupe = Symbol('preferDedupe');\n\nconst _legacyBundling = Symbol('legacyBundling');\n\nconst _parseSettings = Symbol('parseSettings');\n\nconst _initTree = Symbol('initTree');\n\nconst _applyUserRequests = Symbol('applyUserRequests');\n\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode');\n\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile');\n\nconst _buildDeps = Symbol('buildDeps');\n\nconst _buildDepStep = Symbol('buildDepStep');\n\nconst _nodeFromEdge = Symbol('nodeFromEdge');\n\nconst _nodeFromSpec = Symbol('nodeFromSpec');\n\nconst _fetchManifest = Symbol('fetchManifest');\n\nconst _problemEdges = Symbol('problemEdges');\n\nconst _manifests = Symbol('manifests');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _linkFromSpec = Symbol('linkFromSpec');\n\nconst _loadPeerSet = Symbol('loadPeerSet');\n\nconst _updateNames = Symbol.for('updateNames');\n\nconst _fixDepFlags = Symbol('fixDepFlags');\n\nconst _resolveLinks = Symbol('resolveLinks');\n\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage');\n\nconst _add = Symbol('add');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _queueNamedUpdates = Symbol('queueNamedUpdates');\n\nconst _queueVulnDependents = Symbol('queueVulnDependents');\n\nconst _avoidRange = Symbol('avoidRange');\n\nconst _shouldUpdateNode = Symbol('shouldUpdateNode');\n\nconst resetDepFlags = require('../reset-dep-flags.js');\n\nconst _loadFailures = Symbol('loadFailures');\n\nconst _pruneFailedOptional = Symbol('pruneFailedOptional');\n\nconst _linkNodes = Symbol('linkNodes');\n\nconst _follow = Symbol('follow');\n\nconst _globalStyle = Symbol('globalStyle');\n\nconst _globalRootNode = Symbol('globalRootNode');\n\nconst _isVulnerable = Symbol.for('isVulnerable');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _updateFilePath = Symbol('updateFilePath');\n\nconst _followSymlinkPath = Symbol('followSymlinkPath');\n\nconst _getRelpathSpec = Symbol('getRelpathSpec');\n\nconst _retrieveSpecName = Symbol('retrieveSpecName');\n\nconst _strictPeerDeps = Symbol('strictPeerDeps');\n\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform');\n\nconst _checkEngine = Symbol('checkEngine');\n\nconst _checkPlatform = Symbol('checkPlatform');\n\nconst _virtualRoots = Symbol('virtualRoots');\n\nconst _virtualRoot = Symbol('virtualRoot');\n\nconst _failPeerConflict = Symbol('failPeerConflict');\n\nconst _explainPeerConflict = Symbol('explainPeerConflict');\n\nconst _edgesOverridden = Symbol('edgesOverridden'); // exposed symbol for unit testing the placeDep method directly\n\n\nconst _peerSetSource = Symbol.for('peerSetSource'); // used by Reify mixin\n\n\nconst _force = Symbol.for('force');\n\nconst _explicitRequests = Symbol('explicitRequests');\n\nconst _global = Symbol.for('global');\n\nconst _idealTreePrune = Symbol.for('idealTreePrune');\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor(options) {\n    super(options); // normalize trailing slash\n\n    const registry = options.registry || 'https://registry.npmjs.org';\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/';\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = []\n    } = options;\n    this[_workspaces] = workspaces || [];\n    this[_force] = !!force;\n    this[_strictPeerDeps] = !!strictPeerDeps;\n    this.idealTree = idealTree;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this[_usePackageLock] = packageLock;\n    this[_global] = !!global;\n    this[_globalStyle] = this[_global] || globalStyle;\n    this[_follow] = !!follow;\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode');\n    }\n\n    this[_explicitRequests] = new Set();\n    this[_preferDedupe] = false;\n    this[_legacyBundling] = false;\n    this[_depsSeen] = new Set();\n    this[_depsQueue] = [];\n    this[_currentDep] = null;\n    this[_updateNames] = [];\n    this[_updateAll] = false;\n    this[_mutateTree] = false;\n    this[_loadFailures] = new Set();\n    this[_linkNodes] = new Set();\n    this[_manifests] = new Map();\n    this[_edgesOverridden] = new Set();\n    this[_resolvedAdd] = []; // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n\n    this[_peerSetSource] = new WeakMap();\n    this[_virtualRoots] = new Map();\n  }\n\n  get explicitRequests() {\n    return new Set(this[_explicitRequests]);\n  } // public method\n\n\n  async buildIdealTree(options = {}) {\n    if (this.idealTree) {\n      return Promise.resolve(this.idealTree);\n    } // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n\n    options = { ...this.options,\n      ...options\n    }; // an empty array or any falsey value is the same as null\n\n    if (!options.add || options.add.length === 0) {\n      options.add = null;\n    }\n\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null;\n    }\n\n    process.emit('time', 'idealTree');\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option');\n      return Promise.reject(er);\n    } // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n\n    this[_parseSettings](options); // start tracker block\n\n\n    this.addTracker('idealTree');\n\n    try {\n      await this[_initTree]();\n      await this[_inflateAncientLockfile]();\n      await this[_applyUserRequests](options);\n      await this[_buildDeps]();\n      await this[_fixDepFlags]();\n      await this[_pruneFailedOptional]();\n      await this[_checkEngineAndPlatform]();\n    } finally {\n      process.emit('timeEnd', 'idealTree');\n      this.finishTracker('idealTree');\n    }\n\n    return treeCheck(this.idealTree);\n  }\n\n  async [_checkEngineAndPlatform]() {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node);\n\n        this[_checkPlatform](node);\n      }\n    }\n  }\n\n  [_checkPlatform](node) {\n    checkPlatform(node.package, this[_force]);\n  }\n\n  [_checkEngine](node) {\n    const {\n      engineStrict,\n      npmVersion,\n      nodeVersion\n    } = this.options;\n\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force]);\n\n    if (engineStrict) {\n      c();\n    } else {\n      try {\n        c();\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current\n        });\n      }\n    }\n  }\n\n  [_parseSettings](options) {\n    const update = options.update === true ? {\n      all: true\n    } : Array.isArray(options.update) ? {\n      names: options.update\n    } : options.update || {};\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = [];\n    }\n\n    this[_complete] = !!options.complete;\n    this[_preferDedupe] = !!options.preferDedupe;\n    this[_legacyBundling] = !!options.legacyBundling;\n    this[_updateNames] = update.names;\n    this[_updateAll] = update.all; // we prune by default unless explicitly set to boolean false\n\n    this[_prune] = options.prune !== false; // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n\n    this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);\n  } // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n\n\n  [_initTree]() {\n    process.emit('time', 'idealTree:init');\n    return (this[_global] ? this[_globalRootNode]() : rpj(this.path + '/package.json').then(pkg => this[_rootNodeFromPackage](pkg), er => {\n      if (er.code === 'EJSONPARSE') {\n        throw er;\n      }\n\n      return this[_rootNodeFromPackage]({});\n    })).then(root => this[_loadWorkspaces](root)) // ok to not have a virtual tree.  probably initial install.\n    // When updating all, we load the shrinkwrap, but don't bother\n    // to build out the full virtual tree from it, since we'll be\n    // reconstructing it anyway.\n    .then(root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({\n      path: this.path\n    }).then(meta => Object.assign(root, {\n      meta\n    })) : this.loadVirtual({\n      root\n    })) // if we don't have a lockfile to go from, then start with the\n    // actual tree, so we only make the minimum required changes.\n    // don't do this for global installs or updates, because in those\n    // cases we don't use a lockfile anyway.\n    // Load on a new Arborist object, so the Nodes aren't the same,\n    // or else it'll get super confusing when we change them!\n    .then(async root => {\n      if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n        await new this.constructor(this.options).loadActual({\n          root\n        });\n        const tree = root.target; // even though we didn't load it from a package-lock.json FILE,\n        // we still loaded it \"from disk\", meaning we have to reset\n        // dep flags before assuming that any mutations were reflected.\n\n        if (tree.children.size) {\n          root.meta.loadedFromDisk = true;\n        }\n      }\n\n      return root;\n    }).then(tree => {\n      // null the virtual tree, because we're about to hack away at it\n      // if you want another one, load another copy.\n      this.idealTree = tree;\n      this.virtualTree = null;\n      process.emit('timeEnd', 'idealTree:init');\n    });\n  }\n\n  async [_globalRootNode]() {\n    const root = await this[_rootNodeFromPackage]({\n      dependencies: {}\n    }); // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n\n    const meta = new Shrinkwrap({\n      path: this.path\n    });\n    meta.reset();\n    root.meta = meta;\n    return root;\n  }\n\n  async [_rootNodeFromPackage](pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n    const Cls = real === this.path ? Node : Link;\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps\n    });\n\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root\n      });\n    }\n\n    return root;\n  } // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n\n\n  async [_applyUserRequests](options) {\n    process.emit('time', 'idealTree:userRequests');\n    const tree = this.idealTree.target;\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options);\n    } else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces]).map(node => this[_applyUserRequestsToNode](node, options)));\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests');\n  }\n\n  async [_applyUserRequestsToNode](tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]();\n    } // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n\n\n    const globalExplicitUpdateNames = [];\n\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules');\n\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {};\n\n        const updateName = this[_updateNames].includes(name);\n\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name);\n          }\n\n          const dir = resolve(nm, name);\n          const st = await lstat(dir).catch(\n          /* istanbul ignore next */\n          er => null);\n\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir);\n            const real = resolve(dirname(dir), target);\n            tree.package.dependencies[name] = `file:${real}`;\n          } else {\n            tree.package.dependencies[name] = '*';\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options);\n    }\n\n    const {\n      add,\n      rm\n    } = options;\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm);\n\n      for (const name of rm) {\n        this[_explicitRequests].add({\n          from: tree,\n          name,\n          action: 'DELETE'\n        });\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options);\n    } // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n\n\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package;\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name));\n      }\n    }\n\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name));\n    }\n\n    this[_depsQueue].push(tree);\n  } // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n\n\n  [_add](tree, {\n    add,\n    saveType = null,\n    saveBundle = false\n  }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec)).then(spec => this[_updateFilePath](spec)).then(spec => this[_followSymlinkPath](spec));\n      spec.tree = tree;\n      return spec;\n    })).then(add => {\n      this[_resolvedAdd].push(...add); // now add is a list of spec objects with names.\n      // find a home for each of them!\n\n\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log\n      });\n    });\n  }\n\n  async [_retrieveSpecName](spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag';\n\n    if (spec.name && !isTag) {\n      return spec;\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options\n    }); // if it's a tag type, then we need to run it down to an actual version\n\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`);\n    }\n\n    spec.name = mani.name;\n    return spec;\n  }\n\n  async [_updateFilePath](spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec);\n    }\n\n    return spec;\n  }\n\n  async [_followSymlinkPath](spec) {\n    if (spec.type === 'directory') {\n      const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]) // TODO: create synthetic test case to simulate realpath failure\n      .catch(\n      /* istanbul ignore next */\n      () => null);\n      return this[_getRelpathSpec](spec, real);\n    }\n\n    return spec;\n  }\n\n  [_getRelpathSpec](spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const {\n        name\n      } = spec;\n      const tree = this.idealTree.target;\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path);\n      spec.name = name;\n    }\n\n    return spec;\n  } // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n\n\n  async [_queueVulnDependents](options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler(); // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\\nis a bundled dependency of\\n${bundler.name}@${bundler.version} at ${bundler.location}\\n` + 'It cannot be fixed automatically.\\n' + `Check for updates to the ${bundler.name} package.`);\n          continue;\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n          this[_depsQueue].push(edge.from);\n        }\n      }\n    } // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n\n\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || [];\n      options.rm = options.rm || [];\n      const nodesTouched = new Set();\n\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable\n        } = topVuln;\n\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' + `at ./${node.location} for ${name}@${simpleRange}.\\n` + `'cd ./${node.location}' and run 'npm audit' for details.`);\n            continue;\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`);\n            continue;\n          }\n\n          const {\n            isSemVerMajor,\n            version\n          } = fixAvailable;\n          const breakingMessage = isSemVerMajor ? 'a SemVer major change' : 'outside your stated dependency range';\n          this.log.warn('audit', `Updating ${name} to ${version},` + `which is ${breakingMessage}.`);\n          await this[_add](node, {\n            add: [`${name}@${version}`]\n          });\n          nodesTouched.add(node);\n        }\n      }\n\n      for (const node of nodesTouched) {\n        node.package = node.package;\n      }\n    }\n  }\n\n  [_isVulnerable](node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  [_avoidRange](name) {\n    if (!this.auditReport) {\n      return null;\n    }\n\n    const vuln = this.auditReport.get(name);\n\n    if (!vuln) {\n      return null;\n    }\n\n    return vuln.range;\n  }\n\n  [_queueNamedUpdates]() {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory.filter(n => this[_shouldUpdateNode](n));\n\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n        this[_depsQueue].push(edge.from);\n      }\n    }\n  }\n\n  [_shouldUpdateNode](node) {\n    return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;\n  }\n\n  async [_inflateAncientLockfile]() {\n    const {\n      meta,\n      inventory\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return;\n    } // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n\n\n    process.emit('time', 'idealTree:inflate');\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile';\n    this.log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`);\n    this.addTracker('idealTree:inflate');\n    const queue = [];\n\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue;\n      }\n\n      queue.push(async () => {\n        this.log.silly('inflate', node.location);\n        const {\n          resolved,\n          version,\n          path,\n          name,\n          location,\n          integrity\n        } = node; // don't try to hit the registry for linked deps\n\n        const useResolved = resolved && (!version || resolved.startsWith('file:'));\n        const id = useResolved ? resolved : version || `file:${node.path}`;\n        const spec = npa.resolve(name, id, dirname(path));\n        const sloc = location.substr('node_modules/'.length);\n        const t = `idealTree:inflate:${sloc}`;\n        this.addTracker(t);\n        await pacote.manifest(spec, { ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false\n        }).then(mani => {\n          node.package = { ...mani,\n            _id: `${mani.name}@${mani.version}`\n          };\n        }).catch(er => {\n          const warning = `Could not fetch metadata for ${name}@${id}`;\n          this.log.warn(heading, warning, er);\n        });\n        this.finishTracker(t);\n      });\n    }\n\n    await promiseCallLimit(queue); // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n\n    calcDepFlags(this.idealTree); // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n\n    meta.originalLockfileVersion = 2;\n    this.finishTracker('idealTree:inflate');\n    process.emit('timeEnd', 'idealTree:inflate');\n  } // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n\n\n  [_buildDeps]() {\n    process.emit('time', 'idealTree:buildDeps');\n    const tree = this.idealTree.target;\n\n    this[_depsQueue].push(tree);\n\n    this.log.silly('idealTree', 'buildDeps');\n    this.addTracker('idealTree', tree.name, '');\n    return this[_buildDepStep]().then(() => process.emit('timeEnd', 'idealTree:buildDeps'));\n  }\n\n  async [_buildDepStep]() {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const {\n        location,\n        name\n      } = this[_currentDep];\n      process.emit('timeEnd', `idealTree:${location || '#root'}`);\n      this.finishTracker('idealTree', name, location);\n      this[_currentDep] = null;\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]();\n    } // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n\n\n    this[_depsQueue].sort((a, b) => a.depth - b.depth || localeCompare(a.path, b.path));\n\n    const node = this[_depsQueue].shift();\n\n    const bd = node.package.bundleDependencies;\n    const hasBundle = bd && Array.isArray(bd) && bd.length;\n    const {\n      hasShrinkwrap\n    } = node; // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n\n    if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]();\n    }\n\n    this[_depsSeen].add(node);\n\n    this[_currentDep] = node;\n    process.emit('time', `idealTree:${node.location || '#root'}`); // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n\n    const crackOpen = this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap);\n\n    if (crackOpen) {\n      const Arborist = this.constructor;\n      const opt = { ...this.options\n      };\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, { ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity\n        });\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadVirtual({\n            root: node\n          });\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadActual({\n            root: node,\n            ignoreMissing: true\n          });\n        }\n      });\n    } // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n\n    const tasks = [];\n    const peerSource = this[_peerSetSource].get(node) || node;\n\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.overridden) {\n        continue;\n      } // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n\n\n      const source = edge.peer ? peerSource : node;\n\n      const virtualRoot = this[_virtualRoot](source, true); // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n\n\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to; // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n\n      const required = new Set([edge.from]);\n      const parent = edge.peer ? virtualRoot : null;\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??');\n        }\n      });\n      tasks.push({\n        edge,\n        dep\n      });\n    }\n\n    const placeDeps = tasks.sort((a, b) => localeCompare(a.edge.name, b.edge.name)).map(({\n      edge,\n      dep\n    }) => new PlaceDep({\n      edge,\n      dep,\n      explicitRequest: this[_explicitRequests].has(edge),\n      updateNames: this[_updateNames],\n      auditReport: this.auditReport,\n      force: this[_force],\n      preferDedupe: this[_preferDedupe],\n      legacyBundling: this[_legacyBundling],\n      strictPeerDeps: this[_strictPeerDeps],\n      legacyPeerDeps: this.legacyPeerDeps,\n      globalStyle: this[_globalStyle]\n    }));\n    const promises = [];\n\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const {\n            placed,\n            edge,\n            canPlace: cpd\n          } = pd; // if we didn't place anything, nothing to do here\n\n          if (!placed) {\n            return;\n          } // we placed something, that means we changed the tree\n\n\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed);\n          }\n\n          this[_mutateTree] = true;\n\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue;\n              }\n\n              const {\n                from,\n                valid,\n                overridden\n              } = edgeIn;\n\n              if (!overridden && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location);\n\n                this[_depsQueue].push(edgeIn.from);\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue;\n                }\n\n                const {\n                  valid,\n                  overridden\n                } = edgeIn;\n\n                if (!valid && !overridden) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from);\n\n                  this[_depsQueue].push(edgeIn.from);\n                }\n              }\n            }\n          }\n          /* istanbul ignore if - should be impossible */\n\n\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT');\n              throw Object.assign(er, {\n                placeDep: pd\n              });\n            });\n            return;\n          } // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n\n\n          this[_depsQueue].push(placed);\n\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep);\n\n            this[_depsQueue].push(dep);\n          } // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n\n\n          const from = fromPath(placed);\n          promises.push(...this[_problemEdges](placed).map(e => this[_fetchManifest](npa.resolve(e.name, e.spec, from)).catch(er => null)));\n        }\n      });\n    }\n\n    for (const {\n      to\n    } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to);\n      }\n    }\n\n    await Promise.all(promises);\n    return this[_buildDepStep]();\n  } // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n\n\n  async [_nodeFromEdge](edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from);\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path);\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge); // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n\n    const spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path);\n    const second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null; // pick the second one if they're both happy with that, otherwise first\n\n    const node = second && edge.valid ? second : first; // ensure the one we want is the one that's placed\n\n    node.parent = parent;\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' || secondEdge && required.has(secondEdge.from) && secondEdge.type !== 'peerOptional') {\n      required.add(node);\n    } // keep track of the thing that caused this node to be included.\n\n\n    const src = parent.sourceReference;\n\n    this[_peerSetSource].set(node, src); // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n\n\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node;\n    } // otherwise, we have to make sure that our peers can go along with us.\n\n\n    return this[_loadPeerSet](node, required);\n  }\n\n  [_virtualRoot](node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node);\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps\n    }); // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr\n        });\n      }\n    }\n\n    this[_virtualRoots].set(node, vr);\n\n    return vr;\n  }\n\n  [_problemEdges](node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies;\n    const bundled = new Set(bd || []);\n    return [...node.edgesOut.values()].filter(edge => {\n      // If it's included in a bundle, we take whatever is specified.\n      if (bundled.has(edge.name)) {\n        return false;\n      } // If it's already been logged as a load failure, skip it.\n\n\n      if (edge.to && this[_loadFailures].has(edge.to)) {\n        return false;\n      } // If it's shrinkwrapped, we use what the shrinkwap wants.\n\n\n      if (edge.to && edge.to.inShrinkwrap) {\n        return false;\n      } // If the edge has no destination, that's a problem, unless\n      // if it's peerOptional and not explicitly requested.\n\n\n      if (!edge.to) {\n        return edge.type !== 'peerOptional' || this[_explicitRequests].has(edge);\n      } // If the edge has an error, there's a problem.\n\n\n      if (!edge.valid) {\n        return true;\n      } // user explicitly asked to update this package by name, problem\n\n\n      if (this[_updateNames].includes(edge.name)) {\n        return true;\n      } // fixing a security vulnerability with this package, problem\n\n\n      if (this[_isVulnerable](edge.to)) {\n        return true;\n      } // user has explicitly asked to install this package, problem\n\n\n      if (this[_explicitRequests].has(edge)) {\n        return true;\n      } // No problems!\n\n\n      return false;\n    });\n  }\n\n  async [_fetchManifest](spec) {\n    const options = { ...this.options,\n      avoid: this[_avoidRange](spec.name)\n    }; // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n\n    spec = this.idealTree.meta.checkYarnLock(spec, options);\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw);\n    } else {\n      this.log.silly('fetch manifest', spec.raw);\n      const p = pacote.manifest(spec, options).then(mani => {\n        this[_manifests].set(spec.raw, mani);\n\n        return mani;\n      });\n\n      this[_manifests].set(spec.raw, p);\n\n      return p;\n    }\n  }\n\n  [_nodeFromSpec](name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const {\n      legacyPeerDeps\n    } = this;\n    return spec.type === 'directory' ? this[_linkFromSpec](name, spec, parent, edge) : this[_fetchManifest](spec).then(pkg => new Node({\n      name,\n      pkg,\n      parent,\n      legacyPeerDeps\n    }), error => {\n      error.requiredBy = edge.from.location || '.'; // failed to load the spec, either because of enotarget or\n      // fetch failure of some other sort.  save it so we can verify\n      // later that it's optional, otherwise the error is fatal.\n\n      const n = new Node({\n        name,\n        parent,\n        error,\n        legacyPeerDeps\n      });\n\n      this[_loadFailures].add(n);\n\n      return n;\n    });\n  }\n\n  [_linkFromSpec](name, spec, parent, edge) {\n    const realpath = spec.fetchSpec;\n    const {\n      legacyPeerDeps\n    } = this;\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({\n        name,\n        parent,\n        realpath,\n        pkg,\n        legacyPeerDeps\n      });\n\n      this[_linkNodes].add(link);\n\n      return link;\n    });\n  } // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n\n\n  async [_loadPeerSet](node, required) {\n    const peerEdges = [...node.edgesOut.values()] // we typically only install non-optional peers, but we have to\n    // factor them into the peerSet so that we can avoid conflicts\n    .filter(e => e.peer && !(e.valid && e.to)).sort(({\n      name: a\n    }, {\n      name: b\n    }) => localeCompare(a, b));\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue;\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name);\n      const {\n        isProjectRoot,\n        isWorkspace\n      } = node.parent.sourceReference;\n      const isMine = isProjectRoot || isWorkspace;\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required);\n          continue;\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required); // hooray! that worked!\n\n          if (edge.valid) {\n            continue;\n          } // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n\n\n          if (conflictOK || !required.has(dep)) {\n            edge.overridden = true;\n            continue;\n          } // problem\n\n\n          this[_failPeerConflict](edge, parentEdge);\n        }\n      } // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n\n\n      const current = edge.to;\n      const dep = await this[_nodeFromEdge](edge, null, null, required);\n\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required);\n        continue;\n      } // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n\n\n      if (conflictOK || !required.has(edge.from)) {\n        continue;\n      } // ok, it's the root, or we're in unforced strict mode, so this is bad\n\n\n      this[_failPeerConflict](edge, parentEdge);\n    }\n\n    return node;\n  }\n\n  [_failPeerConflict](edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge);\n\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl);\n  }\n\n  [_explainPeerConflict](edge, currentEdge) {\n    const node = edge.from;\n    const curNode = node.resolve(edge.name);\n    const current = curNode.explain();\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force]\n    };\n  } // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n\n\n  [_resolveLinks]() {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link); // link we never ended up placing, skip it\n\n\n      if (link.root !== this.idealTree) {\n        continue;\n      }\n\n      const tree = this.idealTree.target;\n      const external = !link.target.isDescendantOf(tree); // outside the root, somebody else's problem, ignore it\n\n      if (external && !this[_follow]) {\n        continue;\n      } // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n\n\n      const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);\n\n      if (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location);\n\n        this[_depsQueue].push(link.target);\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]();\n    }\n  }\n\n  [_fixDepFlags]() {\n    process.emit('time', 'idealTree:fixDepFlags');\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk;\n    const flagsSuspect = this[_flagsSuspect];\n    const mutateTree = this[_mutateTree]; // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree);\n    } // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n\n\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree);\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false;\n      this.idealTree.dev = false;\n      this.idealTree.optional = false;\n      this.idealTree.devOptional = false;\n      this.idealTree.peer = false;\n    } // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n\n\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect);\n\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]();\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags');\n  }\n\n  [_idealTreePrune]() {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null;\n    }\n  }\n\n  [_pruneFailedOptional]() {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0];\n      }\n\n      const set = optionalSet(node);\n\n      for (const node of set) {\n        node.parent = null;\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"],"names":["localeCompare","require","rpj","npa","pacote","cacache","promiseCallLimit","realpath","resolve","dirname","promisify","treeCheck","readdir","fs","lstat","readlink","depth","OK","REPLACE","CONFLICT","PlaceDep","debug","fromPath","calcDepFlags","Shrinkwrap","Node","Link","addRmPkgDeps","optionalSet","checkEngine","checkPlatform","relpath","_complete","Symbol","_depsSeen","_depsQueue","_currentDep","_updateAll","_mutateTree","_flagsSuspect","for","_workspaces","_prune","_preferDedupe","_legacyBundling","_parseSettings","_initTree","_applyUserRequests","_applyUserRequestsToNode","_inflateAncientLockfile","_buildDeps","_buildDepStep","_nodeFromEdge","_nodeFromSpec","_fetchManifest","_problemEdges","_manifests","_loadWorkspaces","_linkFromSpec","_loadPeerSet","_updateNames","_fixDepFlags","_resolveLinks","_rootNodeFromPackage","_add","_resolvedAdd","_queueNamedUpdates","_queueVulnDependents","_avoidRange","_shouldUpdateNode","resetDepFlags","_loadFailures","_pruneFailedOptional","_linkNodes","_follow","_globalStyle","_globalRootNode","_isVulnerable","_usePackageLock","_rpcache","_stcache","_updateFilePath","_followSymlinkPath","_getRelpathSpec","_retrieveSpecName","_strictPeerDeps","_checkEngineAndPlatform","_checkEngine","_checkPlatform","_virtualRoots","_virtualRoot","_failPeerConflict","_explainPeerConflict","_edgesOverridden","_peerSetSource","_force","_explicitRequests","_global","_idealTreePrune","module","exports","cls","IdealTreeBuilder","constructor","options","registry","replace","idealTree","global","follow","globalStyle","legacyPeerDeps","force","packageLock","strictPeerDeps","workspaces","length","Error","Set","Map","WeakMap","explicitRequests","buildIdealTree","Promise","add","rm","process","emit","update","er","reject","addTracker","finishTracker","node","inventory","values","optional","package","engineStrict","npmVersion","nodeVersion","c","log","warn","code","message","pkgid","required","current","all","Array","isArray","names","complete","preferDedupe","legacyBundling","prune","path","then","pkg","root","reset","meta","Object","assign","loadVirtual","loadedFromDisk","loadActual","tree","target","children","size","virtualTree","dependencies","real","Cls","extraneous","dev","devOptional","peer","isLink","workspaceNodes","map","globalExplicitUpdateNames","nm","name","catch","updateName","includes","push","dir","st","isSymbolicLink","auditReport","from","action","spec","edgesOut","get","saveType","saveBundle","rawSpec","isTag","type","mani","manifest","version","fetchSpec","filepath","vuln","nodes","bundler","getBundler","location","edge","edgesIn","topVulns","nodesTouched","topVuln","entries","simpleRange","topNodes","fixAvailable","isProjectRoot","isWorkspace","isSemVerMajor","breakingMessage","isVulnerable","range","set","filter","n","isTop","inDepBundle","inShrinkwrap","ancient","ancientLockfile","old","originalLockfileVersion","heading","queue","silly","resolved","integrity","useResolved","startsWith","id","sloc","substr","t","fullMetadata","_id","warning","sort","a","b","shift","bd","bundleDependencies","hasBundle","hasShrinkwrap","has","crackOpen","Arborist","opt","tmp","withTmp","cache","extract","ignoreMissing","tasks","peerSource","overridden","source","virtualRoot","vrEdge","vrDep","valid","to","parent","dep","satisfies","placeDeps","explicitRequest","updateNames","promises","pd","getChildren","visit","placed","canPlace","cpd","errors","canPlaceSelf","edgeIn","delete","placeDep","needEvaluation","e","parent_","secondEdge","first","spec2","second","src","sourceReference","reuse","vr","child","bundled","avoid","checkYarnLock","raw","p","error","requiredBy","link","peerEdges","parentEdge","isMine","conflictOK","canReplace","currentEdge","expl","curNode","explain","external","isDescendantOf","unseenLink","fsParent","metaFromDisk","flagsSuspect","mutateTree","needPrune"],"mappings":"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","sourcesContent":["// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst promiseCallLimit = require('promise-call-limit')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve, dirname } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst readlink = promisify(fs.readlink)\nconst { depth } = require('treeverse')\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT,\n} = require('../can-place-dep.js')\nconst PlaceDep = require('../place-dep.js')\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst optionalSet = require('../optional-set.js')\nconst {checkEngine, checkPlatform} = require('npm-install-checks')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode')\n    }\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree) {\n      return Promise.resolve(this.idealTree)\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0) {\n      options.add = null\n    }\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null\n    }\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option')\n      return Promise.reject(er)\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  async [_checkEngineAndPlatform] () {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node)\n        this[_checkPlatform](node)\n      }\n    }\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () =>\n      checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict) {\n      c()\n    } else {\n      try {\n        c()\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = []\n    }\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE') {\n            throw er\n          }\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({ path: this.path })\n          .then(meta => Object.assign(root, {meta}))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size) {\n            root.meta.loadedFromDisk = true\n          }\n        }\n        return root\n      })\n\n      .then(tree => {\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({ path: this.path })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options)\n    } else {\n      await Promise.all(this.workspaceNodes(tree, this[_workspaces])\n        .map(node => this[_applyUserRequestsToNode](node, options)))\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests')\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]()\n    }\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name)\n          }\n          const dir = resolve(nm, name)\n          const st = await lstat(dir)\n            .catch(/* istanbul ignore next */ er => null)\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir)\n            const real = resolve(dirname(dir), target)\n            tree.package.dependencies[name] = `file:${real}`\n          } else {\n            tree.package.dependencies[name] = '*'\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options)\n    }\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm) {\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options)\n    }\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n      }\n    }\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n    }\n\n    this[_depsQueue].push(tree)\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, {add, saveType = null, saveBundle = false}) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec))\n        .then(spec => this[_updateFilePath](spec))\n        .then(spec => this[_followSymlinkPath](spec))\n      spec.tree = tree\n      return spec\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n        log: this.log,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag) {\n      return spec\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`)\n    }\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec)\n    }\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      return this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents] (options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      const nodesTouched = new Set()\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          this.log.warn('audit', `Updating ${name} to ${version},` +\n            `which is ${breakingMessage}.`)\n\n          await this[_add](node, { add: [`${name}@${version}`] })\n          nodesTouched.add(node)\n        }\n      }\n      for (const node of nodesTouched) {\n        node.package = node.package\n      }\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport) {\n      return null\n    }\n    const vuln = this.auditReport.get(name)\n    if (!vuln) {\n      return null\n    }\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return\n    }\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    this.log.warn(heading,\n      `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue\n      }\n\n      queue.push(async () => {\n        this.log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (\n          !version || resolved.startsWith('file:')\n        )\n        const id = useResolved ? resolved\n          : version || `file:${node.path}`\n        const spec = npa.resolve(name, id, dirname(path))\n        const sloc = location.substr('node_modules/'.length)\n        const t = `idealTree:inflate:${sloc}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          this.log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = 2\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target\n    this[_depsQueue].push(tree)\n    this.log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]()\n    }\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || localeCompare(a.path, b.path))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]()\n    }\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity,\n        })\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.overridden) {\n        continue\n      }\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??')\n        }\n      })\n\n      tasks.push({edge, dep})\n    }\n\n    const placeDeps = tasks\n      .sort((a, b) => localeCompare(a.edge.name, b.edge.name))\n      .map(({ edge, dep }) => new PlaceDep({\n        edge,\n        dep,\n\n        explicitRequest: this[_explicitRequests].has(edge),\n        updateNames: this[_updateNames],\n        auditReport: this.auditReport,\n        force: this[_force],\n        preferDedupe: this[_preferDedupe],\n        legacyBundling: this[_legacyBundling],\n        strictPeerDeps: this[_strictPeerDeps],\n        legacyPeerDeps: this.legacyPeerDeps,\n        globalStyle: this[_globalStyle],\n      }))\n\n    const promises = []\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const { placed, edge, canPlace: cpd } = pd\n          // if we didn't place anything, nothing to do here\n          if (!placed) {\n            return\n          }\n\n          // we placed something, that means we changed the tree\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed)\n          }\n          this[_mutateTree] = true\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue\n              }\n              const { from, valid, overridden } = edgeIn\n              if (!overridden && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location)\n                this[_depsQueue].push(edgeIn.from)\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue\n                }\n\n                const { valid, overridden } = edgeIn\n                if (!valid && !overridden) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from)\n                  this[_depsQueue].push(edgeIn.from)\n                }\n              }\n            }\n          }\n\n          /* istanbul ignore if - should be impossible */\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT')\n              throw Object.assign(er, { placeDep: pd })\n            })\n            return\n          }\n\n          // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n          this[_depsQueue].push(placed)\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep)\n            this[_depsQueue].push(dep)\n          }\n\n          // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n          const from = fromPath(placed)\n          promises.push(...this[_problemEdges](placed).map(e =>\n            this[_fetchManifest](npa.resolve(e.name, e.spec, from))\n              .catch(er => null)))\n        },\n      })\n    }\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to)\n      }\n    }\n\n    await Promise.all(promises)\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional')) {\n      required.add(node)\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n\n    // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node\n    }\n\n    // otherwise, we have to make sure that our peers can go along with us.\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node)\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null\n      : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name)) {\n          return false\n        }\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to)) {\n          return false\n        }\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap) {\n          return false\n        }\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid) {\n          return true\n        }\n\n        // user explicitly asked to update this package by name, problem\n        if (this[_updateNames].includes(edge.name)) {\n          return true\n        }\n\n        // fixing a security vulnerability with this package, problem\n        if (this[_isVulnerable](edge.to)) {\n          return true\n        }\n\n        // user has explicitly asked to install this package, problem\n        if (this[_explicitRequests].has(edge)) {\n          return true\n        }\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw)\n    } else {\n      this.log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { legacyPeerDeps } = this\n    return spec.type === 'directory'\n      ? this[_linkFromSpec](name, spec, parent, edge)\n      : this[_fetchManifest](spec)\n        .then(pkg => new Node({ name, pkg, parent, legacyPeerDeps }), error => {\n          error.requiredBy = edge.from.location || '.'\n\n          // failed to load the spec, either because of enotarget or\n          // fetch failure of some other sort.  save it so we can verify\n          // later that it's optional, otherwise the error is fatal.\n          const n = new Node({\n            name,\n            parent,\n            error,\n            legacyPeerDeps,\n          })\n          this[_loadFailures].add(n)\n          return n\n        })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({name: a}, {name: b}) => localeCompare(a, b))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const {isProjectRoot, isWorkspace} = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](\n            parentEdge,\n            node.parent,\n            edge,\n            required\n          )\n\n          // hooray! that worked!\n          if (edge.valid) {\n            continue\n          }\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep)) {\n            edge.overridden = true\n            continue\n          }\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to\n      const dep = await this[_nodeFromEdge](edge, null, null, required)\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required)\n        continue\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from)) {\n        continue\n      }\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const current = curNode.explain()\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree) {\n        continue\n      }\n\n      const tree = this.idealTree.target\n      const external = !link.target.isDescendantOf(tree)\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow]) {\n        continue\n      }\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]()\n    }\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree)\n    }\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree)\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]()\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null\n    }\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0]\n      }\n\n      const set = optionalSet(node)\n      for (const node of set) {\n        node.parent = null\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}