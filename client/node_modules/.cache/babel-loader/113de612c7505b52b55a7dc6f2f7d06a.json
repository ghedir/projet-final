{"ast":null,"code":"// An edge in the dependency graph\n// Represents a dependency relationship of some kind\nconst util = require('util');\n\nconst npa = require('npm-package-arg');\n\nconst depValid = require('./dep-valid.js');\n\nconst _from = Symbol('_from');\n\nconst _to = Symbol('_to');\n\nconst _type = Symbol('_type');\n\nconst _spec = Symbol('_spec');\n\nconst _accept = Symbol('_accept');\n\nconst _name = Symbol('_name');\n\nconst _error = Symbol('_error');\n\nconst _loadError = Symbol('_loadError');\n\nconst _setFrom = Symbol('_setFrom');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst types = new Set(['prod', 'dev', 'optional', 'peer', 'peerOptional', 'workspace']);\n\nclass ArboristEdge {}\n\nconst printableEdge = edge => {\n  const edgeFrom = edge.from && edge.from.location;\n  const edgeTo = edge.to && edge.to.location;\n  return Object.assign(new ArboristEdge(), {\n    name: edge.name,\n    spec: edge.spec,\n    type: edge.type,\n    ...(edgeFrom != null ? {\n      from: edgeFrom\n    } : {}),\n    ...(edgeTo ? {\n      to: edgeTo\n    } : {}),\n    ...(edge.error ? {\n      error: edge.error\n    } : {}),\n    ...(edge.overridden ? {\n      overridden: true\n    } : {})\n  });\n};\n\nclass Edge {\n  constructor(options) {\n    const {\n      type,\n      name,\n      spec,\n      accept,\n      from\n    } = options;\n\n    if (typeof spec !== 'string') {\n      throw new TypeError('must provide string spec');\n    }\n\n    if (type === 'workspace' && npa(spec).type !== 'directory') {\n      throw new TypeError('workspace edges must be a symlink');\n    }\n\n    this[_spec] = spec;\n\n    if (accept !== undefined) {\n      if (typeof accept !== 'string') {\n        throw new TypeError('accept field must be a string if provided');\n      }\n\n      this[_accept] = accept || '*';\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('must provide dependency name');\n    }\n\n    this[_name] = name;\n\n    if (!types.has(type)) {\n      throw new TypeError(`invalid type: ${type}\\n` + `(valid types are: ${Edge.types.join(', ')})`);\n    }\n\n    this[_type] = type;\n\n    if (!from) {\n      throw new TypeError('must provide \"from\" node');\n    }\n\n    this[_setFrom](from);\n\n    this[_error] = this[_loadError]();\n    this.overridden = false;\n  }\n\n  satisfiedBy(node) {\n    return node.name === this.name && depValid(node, this.spec, this.accept, this.from);\n  }\n\n  explain(seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation];\n    }\n\n    return this[_explanation] = this[_explain](seen);\n  } // return the edge data, and an explanation of how that edge came to be here\n\n\n  [_explain](seen) {\n    const {\n      error,\n      from,\n      bundled\n    } = this;\n    return {\n      type: this.type,\n      name: this.name,\n      spec: this.spec,\n      ...(bundled ? {\n        bundled\n      } : {}),\n      ...(error ? {\n        error\n      } : {}),\n      ...(from ? {\n        from: from.explain(null, seen)\n      } : {})\n    };\n  }\n\n  get bundled() {\n    if (!this.from) {\n      return false;\n    }\n\n    const {\n      package: {\n        bundleDependencies = []\n      }\n    } = this.from;\n    return bundleDependencies.includes(this.name);\n  }\n\n  get workspace() {\n    return this[_type] === 'workspace';\n  }\n\n  get prod() {\n    return this[_type] === 'prod';\n  }\n\n  get dev() {\n    return this[_type] === 'dev';\n  }\n\n  get optional() {\n    return this[_type] === 'optional' || this[_type] === 'peerOptional';\n  }\n\n  get peer() {\n    return this[_type] === 'peer' || this[_type] === 'peerOptional';\n  }\n\n  get type() {\n    return this[_type];\n  }\n\n  get name() {\n    return this[_name];\n  }\n\n  get spec() {\n    return this[_spec];\n  }\n\n  get accept() {\n    return this[_accept];\n  }\n\n  get valid() {\n    return !this.error;\n  }\n\n  get missing() {\n    return this.error === 'MISSING';\n  }\n\n  get invalid() {\n    return this.error === 'INVALID';\n  }\n\n  get peerLocal() {\n    return this.error === 'PEER LOCAL';\n  }\n\n  get error() {\n    this[_error] = this[_error] || this[_loadError]();\n    return this[_error] === 'OK' ? null : this[_error];\n  }\n\n  [_loadError]() {\n    return !this[_to] ? this.optional ? null : 'MISSING' : this.peer && this.from === this.to.parent && !this.from.isTop ? 'PEER LOCAL' : !this.satisfiedBy(this.to) ? 'INVALID' : 'OK';\n  }\n\n  reload(hard = false) {\n    this[_explanation] = null;\n\n    const newTo = this[_from].resolve(this.name);\n\n    if (newTo !== this[_to]) {\n      if (this[_to]) {\n        this[_to].edgesIn.delete(this);\n      }\n\n      this[_to] = newTo;\n      this[_error] = this[_loadError]();\n\n      if (this[_to]) {\n        this[_to].addEdgeIn(this);\n      }\n    } else if (hard) {\n      this[_error] = this[_loadError]();\n    }\n  }\n\n  detach() {\n    this[_explanation] = null;\n\n    if (this[_to]) {\n      this[_to].edgesIn.delete(this);\n    }\n\n    this[_from].edgesOut.delete(this.name);\n\n    this[_to] = null;\n    this[_error] = 'DETACHED';\n    this[_from] = null;\n  }\n\n  [_setFrom](node) {\n    this[_explanation] = null;\n    this[_from] = node;\n\n    if (node.edgesOut.has(this.name)) {\n      node.edgesOut.get(this.name).detach();\n    }\n\n    node.addEdgeOut(this);\n    this.reload();\n  }\n\n  get from() {\n    return this[_from];\n  }\n\n  get to() {\n    return this[_to];\n  }\n\n  toJSON() {\n    return printableEdge(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nEdge.types = [...types];\nEdge.errors = ['DETACHED', 'MISSING', 'PEER LOCAL', 'INVALID'];\nmodule.exports = Edge;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/@npmcli/arborist/lib/edge.js"],"names":["util","require","npa","depValid","_from","Symbol","_to","_type","_spec","_accept","_name","_error","_loadError","_setFrom","_explain","_explanation","types","Set","ArboristEdge","printableEdge","edge","edgeFrom","from","location","edgeTo","to","Object","assign","name","spec","type","error","overridden","Edge","constructor","options","accept","TypeError","undefined","has","join","satisfiedBy","node","explain","seen","bundled","package","bundleDependencies","includes","workspace","prod","dev","optional","peer","valid","missing","invalid","peerLocal","parent","isTop","reload","hard","newTo","resolve","edgesIn","delete","addEdgeIn","detach","edgesOut","get","addEdgeOut","toJSON","inspect","custom","errors","module","exports"],"mappings":"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","sourcesContent":["// An edge in the dependency graph\n// Represents a dependency relationship of some kind\n\nconst util = require('util')\nconst npa = require('npm-package-arg')\nconst depValid = require('./dep-valid.js')\nconst _from = Symbol('_from')\nconst _to = Symbol('_to')\nconst _type = Symbol('_type')\nconst _spec = Symbol('_spec')\nconst _accept = Symbol('_accept')\nconst _name = Symbol('_name')\nconst _error = Symbol('_error')\nconst _loadError = Symbol('_loadError')\nconst _setFrom = Symbol('_setFrom')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\n\nconst types = new Set([\n  'prod',\n  'dev',\n  'optional',\n  'peer',\n  'peerOptional',\n  'workspace',\n])\n\nclass ArboristEdge {}\nconst printableEdge = (edge) => {\n  const edgeFrom = edge.from && edge.from.location\n  const edgeTo = edge.to && edge.to.location\n\n  return Object.assign(new ArboristEdge(), {\n    name: edge.name,\n    spec: edge.spec,\n    type: edge.type,\n    ...(edgeFrom != null ? { from: edgeFrom } : {}),\n    ...(edgeTo ? { to: edgeTo } : {}),\n    ...(edge.error ? { error: edge.error } : {}),\n    ...(edge.overridden ? { overridden: true } : {}),\n  })\n}\n\nclass Edge {\n  constructor (options) {\n    const { type, name, spec, accept, from } = options\n\n    if (typeof spec !== 'string') {\n      throw new TypeError('must provide string spec')\n    }\n\n    if (type === 'workspace' && npa(spec).type !== 'directory') {\n      throw new TypeError('workspace edges must be a symlink')\n    }\n\n    this[_spec] = spec\n\n    if (accept !== undefined) {\n      if (typeof accept !== 'string') {\n        throw new TypeError('accept field must be a string if provided')\n      }\n      this[_accept] = accept || '*'\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('must provide dependency name')\n    }\n    this[_name] = name\n\n    if (!types.has(type)) {\n      throw new TypeError(\n        `invalid type: ${type}\\n` +\n        `(valid types are: ${Edge.types.join(', ')})`)\n    }\n    this[_type] = type\n    if (!from) {\n      throw new TypeError('must provide \"from\" node')\n    }\n    this[_setFrom](from)\n    this[_error] = this[_loadError]()\n    this.overridden = false\n  }\n\n  satisfiedBy (node) {\n    return node.name === this.name &&\n      depValid(node, this.spec, this.accept, this.from)\n  }\n\n  explain (seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](seen)\n  }\n\n  // return the edge data, and an explanation of how that edge came to be here\n  [_explain] (seen) {\n    const { error, from, bundled } = this\n    return {\n      type: this.type,\n      name: this.name,\n      spec: this.spec,\n      ...(bundled ? { bundled } : {}),\n      ...(error ? { error } : {}),\n      ...(from ? { from: from.explain(null, seen) } : {}),\n    }\n  }\n\n  get bundled () {\n    if (!this.from) {\n      return false\n    }\n    const { package: { bundleDependencies = [] } } = this.from\n    return bundleDependencies.includes(this.name)\n  }\n\n  get workspace () {\n    return this[_type] === 'workspace'\n  }\n\n  get prod () {\n    return this[_type] === 'prod'\n  }\n\n  get dev () {\n    return this[_type] === 'dev'\n  }\n\n  get optional () {\n    return this[_type] === 'optional' || this[_type] === 'peerOptional'\n  }\n\n  get peer () {\n    return this[_type] === 'peer' || this[_type] === 'peerOptional'\n  }\n\n  get type () {\n    return this[_type]\n  }\n\n  get name () {\n    return this[_name]\n  }\n\n  get spec () {\n    return this[_spec]\n  }\n\n  get accept () {\n    return this[_accept]\n  }\n\n  get valid () {\n    return !this.error\n  }\n\n  get missing () {\n    return this.error === 'MISSING'\n  }\n\n  get invalid () {\n    return this.error === 'INVALID'\n  }\n\n  get peerLocal () {\n    return this.error === 'PEER LOCAL'\n  }\n\n  get error () {\n    this[_error] = this[_error] || this[_loadError]()\n    return this[_error] === 'OK' ? null : this[_error]\n  }\n\n  [_loadError] () {\n    return !this[_to] ? (this.optional ? null : 'MISSING')\n      : this.peer && this.from === this.to.parent && !this.from.isTop ? 'PEER LOCAL'\n      : !this.satisfiedBy(this.to) ? 'INVALID'\n      : 'OK'\n  }\n\n  reload (hard = false) {\n    this[_explanation] = null\n    const newTo = this[_from].resolve(this.name)\n    if (newTo !== this[_to]) {\n      if (this[_to]) {\n        this[_to].edgesIn.delete(this)\n      }\n      this[_to] = newTo\n      this[_error] = this[_loadError]()\n      if (this[_to]) {\n        this[_to].addEdgeIn(this)\n      }\n    } else if (hard) {\n      this[_error] = this[_loadError]()\n    }\n  }\n\n  detach () {\n    this[_explanation] = null\n    if (this[_to]) {\n      this[_to].edgesIn.delete(this)\n    }\n    this[_from].edgesOut.delete(this.name)\n    this[_to] = null\n    this[_error] = 'DETACHED'\n    this[_from] = null\n  }\n\n  [_setFrom] (node) {\n    this[_explanation] = null\n    this[_from] = node\n    if (node.edgesOut.has(this.name)) {\n      node.edgesOut.get(this.name).detach()\n    }\n    node.addEdgeOut(this)\n    this.reload()\n  }\n\n  get from () {\n    return this[_from]\n  }\n\n  get to () {\n    return this[_to]\n  }\n\n  toJSON () {\n    return printableEdge(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nEdge.types = [...types]\nEdge.errors = [\n  'DETACHED',\n  'MISSING',\n  'PEER LOCAL',\n  'INVALID',\n]\n\nmodule.exports = Edge\n"]},"metadata":{},"sourceType":"script"}