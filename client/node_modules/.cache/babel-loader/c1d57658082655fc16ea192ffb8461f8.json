{"ast":null,"code":"const PackageJson = require('@npmcli/package-json');\n\nconst BaseCommand = require('./base-command.js');\n\nconst Queryable = require('./utils/queryable.js');\n\nclass Pkg extends BaseCommand {\n  static get description() {\n    return 'Manages your package.json';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'pkg';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['set <key>=<value> [<key>=<value> ...]', 'get [<key> [<key> ...]]', 'delete <key> [<key> ...]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['force', 'json', 'workspace', 'workspaces'];\n  }\n\n  exec(args, cb) {\n    this.prefix = this.npm.localPrefix;\n    this.pkg(args).then(() => cb()).catch(cb);\n  }\n\n  execWorkspaces(args, filters, cb) {\n    this.pkgWorkspaces(args, filters).then(() => cb()).catch(cb);\n  }\n\n  async pkg(args) {\n    if (this.npm.config.get('global')) {\n      throw Object.assign(new Error(`There's no package.json file to manage on global mode`), {\n        code: 'EPKGGLOBAL'\n      });\n    }\n\n    const [cmd, ..._args] = args;\n\n    switch (cmd) {\n      case 'get':\n        return this.get(_args);\n\n      case 'set':\n        return this.set(_args);\n\n      case 'delete':\n        return this.delete(_args);\n\n      default:\n        throw this.usageError();\n    }\n  }\n\n  async pkgWorkspaces(args, filters) {\n    await this.setWorkspaces(filters);\n    const result = {};\n\n    for (const [workspaceName, workspacePath] of this.workspaces.entries()) {\n      this.prefix = workspacePath;\n      result[workspaceName] = await this.pkg(args);\n    } // when running in workspaces names, make sure to key by workspace\n    // name the results of each value retrieved in each ws\n\n\n    this.npm.output(JSON.stringify(result, null, 2));\n  }\n\n  async get(args) {\n    const pkgJson = await PackageJson.load(this.prefix);\n    const {\n      content\n    } = pkgJson;\n    let result = !args.length && content;\n\n    if (!result) {\n      const q = new Queryable(content);\n      result = q.query(args); // in case there's only a single result from the query\n      // just prints that one element to stdout\n\n      if (Object.keys(result).length === 1) result = result[args];\n    } // only outputs if not running with workspaces config,\n    // in case you're retrieving info for workspaces the pkgWorkspaces\n    // will handle the output to make sure it get keyed by ws name\n\n\n    if (!this.workspaces) this.npm.output(JSON.stringify(result, null, 2));\n    return result;\n  }\n\n  async set(args) {\n    const setError = () => Object.assign(new TypeError('npm pkg set expects a key=value pair of args.'), {\n      code: 'EPKGSET'\n    });\n\n    if (!args.length) throw setError();\n    const force = this.npm.config.get('force');\n    const json = this.npm.config.get('json');\n    const pkgJson = await PackageJson.load(this.prefix);\n    const q = new Queryable(pkgJson.content);\n\n    for (const arg of args) {\n      const [key, ...rest] = arg.split('=');\n      const value = rest.join('=');\n      if (!key || !value) throw setError();\n      q.set(key, json ? JSON.parse(value) : value, {\n        force\n      });\n    }\n\n    pkgJson.update(q.toJSON());\n    await pkgJson.save();\n  }\n\n  async delete(args) {\n    const setError = () => Object.assign(new TypeError('npm pkg delete expects key args.'), {\n      code: 'EPKGDELETE'\n    });\n\n    if (!args.length) throw setError();\n    const pkgJson = await PackageJson.load(this.prefix);\n    const q = new Queryable(pkgJson.content);\n\n    for (const key of args) {\n      if (!key) throw setError();\n      q.delete(key);\n    }\n\n    pkgJson.update(q.toJSON());\n    await pkgJson.save();\n  }\n\n}\n\nmodule.exports = Pkg;","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/pkg.js"],"names":["PackageJson","require","BaseCommand","Queryable","Pkg","description","name","usage","params","exec","args","cb","prefix","npm","localPrefix","pkg","then","catch","execWorkspaces","filters","pkgWorkspaces","config","get","Object","assign","Error","code","cmd","_args","set","delete","usageError","setWorkspaces","result","workspaceName","workspacePath","workspaces","entries","output","JSON","stringify","pkgJson","load","content","length","q","query","keys","setError","TypeError","force","json","arg","key","rest","split","value","join","parse","update","toJSON","save","module","exports"],"mappings":"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","sourcesContent":["const PackageJson = require('@npmcli/package-json')\nconst BaseCommand = require('./base-command.js')\nconst Queryable = require('./utils/queryable.js')\n\nclass Pkg extends BaseCommand {\n  static get description () {\n    return 'Manages your package.json'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'pkg'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      'set <key>=<value> [<key>=<value> ...]',\n      'get [<key> [<key> ...]]',\n      'delete <key> [<key> ...]',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'force',\n      'json',\n      'workspace',\n      'workspaces',\n    ]\n  }\n\n  exec (args, cb) {\n    this.prefix = this.npm.localPrefix\n    this.pkg(args).then(() => cb()).catch(cb)\n  }\n\n  execWorkspaces (args, filters, cb) {\n    this.pkgWorkspaces(args, filters).then(() => cb()).catch(cb)\n  }\n\n  async pkg (args) {\n    if (this.npm.config.get('global')) {\n      throw Object.assign(\n        new Error(`There's no package.json file to manage on global mode`),\n        { code: 'EPKGGLOBAL' }\n      )\n    }\n\n    const [cmd, ..._args] = args\n    switch (cmd) {\n      case 'get':\n        return this.get(_args)\n      case 'set':\n        return this.set(_args)\n      case 'delete':\n        return this.delete(_args)\n      default:\n        throw this.usageError()\n    }\n  }\n\n  async pkgWorkspaces (args, filters) {\n    await this.setWorkspaces(filters)\n    const result = {}\n    for (const [workspaceName, workspacePath] of this.workspaces.entries()) {\n      this.prefix = workspacePath\n      result[workspaceName] = await this.pkg(args)\n    }\n    // when running in workspaces names, make sure to key by workspace\n    // name the results of each value retrieved in each ws\n    this.npm.output(JSON.stringify(result, null, 2))\n  }\n\n  async get (args) {\n    const pkgJson = await PackageJson.load(this.prefix)\n\n    const { content } = pkgJson\n    let result = !args.length && content\n\n    if (!result) {\n      const q = new Queryable(content)\n      result = q.query(args)\n\n      // in case there's only a single result from the query\n      // just prints that one element to stdout\n      if (Object.keys(result).length === 1)\n        result = result[args]\n    }\n\n    // only outputs if not running with workspaces config,\n    // in case you're retrieving info for workspaces the pkgWorkspaces\n    // will handle the output to make sure it get keyed by ws name\n    if (!this.workspaces)\n      this.npm.output(JSON.stringify(result, null, 2))\n\n    return result\n  }\n\n  async set (args) {\n    const setError = () =>\n      Object.assign(\n        new TypeError('npm pkg set expects a key=value pair of args.'),\n        { code: 'EPKGSET' }\n      )\n\n    if (!args.length)\n      throw setError()\n\n    const force = this.npm.config.get('force')\n    const json = this.npm.config.get('json')\n    const pkgJson = await PackageJson.load(this.prefix)\n    const q = new Queryable(pkgJson.content)\n    for (const arg of args) {\n      const [key, ...rest] = arg.split('=')\n      const value = rest.join('=')\n      if (!key || !value)\n        throw setError()\n\n      q.set(key, json ? JSON.parse(value) : value, { force })\n    }\n\n    pkgJson.update(q.toJSON())\n    await pkgJson.save()\n  }\n\n  async delete (args) {\n    const setError = () =>\n      Object.assign(\n        new TypeError('npm pkg delete expects key args.'),\n        { code: 'EPKGDELETE' }\n      )\n\n    if (!args.length)\n      throw setError()\n\n    const pkgJson = await PackageJson.load(this.prefix)\n    const q = new Queryable(pkgJson.content)\n    for (const key of args) {\n      if (!key)\n        throw setError()\n\n      q.delete(key)\n    }\n\n    pkgJson.update(q.toJSON())\n    await pkgJson.save()\n  }\n}\n\nmodule.exports = Pkg\n"]},"metadata":{},"sourceType":"script"}