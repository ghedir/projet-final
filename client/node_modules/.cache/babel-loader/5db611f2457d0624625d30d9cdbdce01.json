{"ast":null,"code":"const os = require('os');\n\nconst path = require('path');\n\nconst writeFileAtomic = require('write-file-atomic');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst fs = require('graceful-fs');\n\nconst errorMessage = require('./error-message.js');\n\nconst replaceInfo = require('./replace-info.js');\n\nlet exitHandlerCalled = false;\nlet logFileName;\nlet npm; // set by the cli\n\nlet wroteLogFile = false;\n\nconst getLogFile = () => {\n  // we call this multiple times, so we need to treat it as a singleton because\n  // the date is part of the name\n  if (!logFileName) logFileName = path.resolve(npm.config.get('cache'), '_logs', new Date().toISOString().replace(/[.:]/g, '_') + '-debug.log');\n  return logFileName;\n};\n\nprocess.on('exit', code => {\n  // process.emit is synchronous, so the timeEnd handler will run before the\n  // unfinished timer check below\n  process.emit('timeEnd', 'npm');\n  npm.log.disableProgress();\n\n  for (const [name, timers] of npm.timers) npm.log.verbose('unfinished npm timer', name, timers);\n\n  if (npm.config.loaded && npm.config.get('timing')) {\n    try {\n      const file = path.resolve(npm.config.get('cache'), '_timing.json');\n      const dir = path.dirname(npm.config.get('cache'));\n      mkdirp.sync(dir);\n      fs.appendFileSync(file, JSON.stringify({\n        command: process.argv.slice(2),\n        logfile: getLogFile(),\n        version: npm.version,\n        ...npm.timings\n      }) + '\\n');\n      const st = fs.lstatSync(path.dirname(npm.config.get('cache')));\n      fs.chownSync(dir, st.uid, st.gid);\n      fs.chownSync(file, st.uid, st.gid);\n    } catch (ex) {// ignore\n    }\n  }\n\n  if (!code) npm.log.info('ok');else npm.log.verbose('code', code);\n\n  if (!exitHandlerCalled) {\n    process.exitCode = code || 1;\n    npm.log.error('', 'Exit handler never called!');\n    console.error('');\n    npm.log.error('', 'This is an error with npm itself. Please report this error at:');\n    npm.log.error('', '    <https://github.com/npm/cli/issues>'); // TODO this doesn't have an npm.config.loaded guard\n\n    writeLogFile();\n  } // In timing mode we always write the log file\n\n\n  if (npm.config.loaded && npm.config.get('timing') && !wroteLogFile) writeLogFile();\n\n  if (wroteLogFile) {\n    // just a line break\n    if (npm.log.levels[npm.log.level] <= npm.log.levels.error) console.error('');\n    npm.log.error('', ['A complete log of this run can be found in:', '    ' + getLogFile()].join('\\n'));\n  } // these are needed for the tests to have a clean slate in each test case\n\n\n  exitHandlerCalled = false;\n  wroteLogFile = false;\n});\n\nconst exitHandler = err => {\n  npm.log.disableProgress();\n\n  if (!npm.config.loaded) {\n    err = err || new Error('Exit prior to config file resolving.');\n    console.error(err.stack || err.message);\n  } // only show the notification if it finished.\n\n\n  if (typeof npm.updateNotification === 'string') {\n    const {\n      level\n    } = npm.log;\n    npm.log.level = 'notice';\n    npm.log.notice('', npm.updateNotification);\n    npm.log.level = level;\n  }\n\n  exitHandlerCalled = true;\n  let exitCode;\n  let noLog;\n\n  if (err) {\n    exitCode = 1; // if we got a command that just shells out to something else, then it\n    // will presumably print its own errors and exit with a proper status\n    // code if there's a problem.  If we got an error with a code=0, then...\n    // something else went wrong along the way, so maybe an npm problem?\n\n    const isShellout = npm.shelloutCommands.includes(npm.command);\n    const quietShellout = isShellout && typeof err.code === 'number' && err.code;\n\n    if (quietShellout) {\n      exitCode = err.code;\n      noLog = true;\n    } else if (typeof err === 'string') {\n      noLog = true;\n      npm.log.error('', err);\n    } else if (!(err instanceof Error)) {\n      noLog = true;\n      npm.log.error('weird error', err);\n    } else {\n      if (!err.code) {\n        const matchErrorCode = err.message.match(/^(?:Error: )?(E[A-Z]+)/);\n        err.code = matchErrorCode && matchErrorCode[1];\n      }\n\n      for (const k of ['type', 'stack', 'statusCode', 'pkgid']) {\n        const v = err[k];\n        if (v) npm.log.verbose(k, replaceInfo(v));\n      }\n\n      npm.log.verbose('cwd', process.cwd());\n      const args = replaceInfo(process.argv);\n      npm.log.verbose('', os.type() + ' ' + os.release());\n      npm.log.verbose('argv', args.map(JSON.stringify).join(' '));\n      npm.log.verbose('node', process.version);\n      npm.log.verbose('npm ', 'v' + npm.version);\n\n      for (const k of ['code', 'syscall', 'file', 'path', 'dest', 'errno']) {\n        const v = err[k];\n        if (v) npm.log.error(k, v);\n      }\n\n      const msg = errorMessage(err, npm);\n\n      for (const errline of [...msg.summary, ...msg.detail]) npm.log.error(...errline);\n\n      if (npm.config.loaded && npm.config.get('json')) {\n        const error = {\n          error: {\n            code: err.code,\n            summary: messageText(msg.summary),\n            detail: messageText(msg.detail)\n          }\n        };\n        console.error(JSON.stringify(error, null, 2));\n      }\n\n      if (typeof err.errno === 'number') exitCode = err.errno;else if (typeof err.code === 'number') exitCode = err.code;\n    }\n  }\n\n  npm.log.verbose('exit', exitCode || 0);\n  if (npm.log.level === 'silent') noLog = true; // noLog is true if there was an error, including if config wasn't loaded, so\n  // this doesn't need a config.loaded guard\n\n  if (exitCode && !noLog) writeLogFile(); // explicitly call process.exit now so we don't hang on things like the\n  // update notifier, also flush stdout beforehand because process.exit doesn't\n  // wait for that to happen.\n\n  process.stdout.write('', () => process.exit(exitCode));\n};\n\nconst messageText = msg => msg.map(line => line.slice(1).join(' ')).join('\\n');\n\nconst writeLogFile = () => {\n  try {\n    let logOutput = '';\n    npm.log.record.forEach(m => {\n      const p = [m.id, m.level];\n      if (m.prefix) p.push(m.prefix);\n      const pref = p.join(' ');\n      m.message.trim().split(/\\r?\\n/).map(line => (pref + ' ' + line).trim()).forEach(line => {\n        logOutput += line + os.EOL;\n      });\n    });\n    const file = getLogFile();\n    const dir = path.dirname(file);\n    mkdirp.sync(dir);\n    writeFileAtomic.sync(file, logOutput);\n    const st = fs.lstatSync(path.dirname(npm.config.get('cache')));\n    fs.chownSync(dir, st.uid, st.gid);\n    fs.chownSync(file, st.uid, st.gid); // truncate once it's been written.\n\n    npm.log.record.length = 0;\n    wroteLogFile = true;\n  } catch (ex) {}\n};\n\nmodule.exports = exitHandler;\n\nmodule.exports.setNpm = n => {\n  npm = n;\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/lib/utils/exit-handler.js"],"names":["os","require","path","writeFileAtomic","mkdirp","fs","errorMessage","replaceInfo","exitHandlerCalled","logFileName","npm","wroteLogFile","getLogFile","resolve","config","get","Date","toISOString","replace","process","on","code","emit","log","disableProgress","name","timers","verbose","loaded","file","dir","dirname","sync","appendFileSync","JSON","stringify","command","argv","slice","logfile","version","timings","st","lstatSync","chownSync","uid","gid","ex","info","exitCode","error","console","writeLogFile","levels","level","join","exitHandler","err","Error","stack","message","updateNotification","notice","noLog","isShellout","shelloutCommands","includes","quietShellout","matchErrorCode","match","k","v","cwd","args","type","release","map","msg","errline","summary","detail","messageText","errno","stdout","write","exit","line","logOutput","record","forEach","m","p","id","prefix","push","pref","trim","split","EOL","length","module","exports","setNpm","n"],"mappings":"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","sourcesContent":["const os = require('os')\nconst path = require('path')\nconst writeFileAtomic = require('write-file-atomic')\nconst mkdirp = require('mkdirp-infer-owner')\nconst fs = require('graceful-fs')\n\nconst errorMessage = require('./error-message.js')\nconst replaceInfo = require('./replace-info.js')\n\nlet exitHandlerCalled = false\nlet logFileName\nlet npm // set by the cli\nlet wroteLogFile = false\n\nconst getLogFile = () => {\n  // we call this multiple times, so we need to treat it as a singleton because\n  // the date is part of the name\n  if (!logFileName)\n    logFileName = path.resolve(npm.config.get('cache'), '_logs', (new Date()).toISOString().replace(/[.:]/g, '_') + '-debug.log')\n\n  return logFileName\n}\n\nprocess.on('exit', code => {\n  // process.emit is synchronous, so the timeEnd handler will run before the\n  // unfinished timer check below\n  process.emit('timeEnd', 'npm')\n  npm.log.disableProgress()\n  for (const [name, timers] of npm.timers)\n    npm.log.verbose('unfinished npm timer', name, timers)\n\n  if (npm.config.loaded && npm.config.get('timing')) {\n    try {\n      const file = path.resolve(npm.config.get('cache'), '_timing.json')\n      const dir = path.dirname(npm.config.get('cache'))\n      mkdirp.sync(dir)\n\n      fs.appendFileSync(file, JSON.stringify({\n        command: process.argv.slice(2),\n        logfile: getLogFile(),\n        version: npm.version,\n        ...npm.timings,\n      }) + '\\n')\n\n      const st = fs.lstatSync(path.dirname(npm.config.get('cache')))\n      fs.chownSync(dir, st.uid, st.gid)\n      fs.chownSync(file, st.uid, st.gid)\n    } catch (ex) {\n      // ignore\n    }\n  }\n\n  if (!code)\n    npm.log.info('ok')\n  else\n    npm.log.verbose('code', code)\n\n  if (!exitHandlerCalled) {\n    process.exitCode = code || 1\n    npm.log.error('', 'Exit handler never called!')\n    console.error('')\n    npm.log.error('', 'This is an error with npm itself. Please report this error at:')\n    npm.log.error('', '    <https://github.com/npm/cli/issues>')\n    // TODO this doesn't have an npm.config.loaded guard\n    writeLogFile()\n  }\n  // In timing mode we always write the log file\n  if (npm.config.loaded && npm.config.get('timing') && !wroteLogFile)\n    writeLogFile()\n  if (wroteLogFile) {\n    // just a line break\n    if (npm.log.levels[npm.log.level] <= npm.log.levels.error)\n      console.error('')\n\n    npm.log.error(\n      '',\n      [\n        'A complete log of this run can be found in:',\n        '    ' + getLogFile(),\n      ].join('\\n')\n    )\n  }\n\n  // these are needed for the tests to have a clean slate in each test case\n  exitHandlerCalled = false\n  wroteLogFile = false\n})\n\nconst exitHandler = (err) => {\n  npm.log.disableProgress()\n  if (!npm.config.loaded) {\n    err = err || new Error('Exit prior to config file resolving.')\n    console.error(err.stack || err.message)\n  }\n\n  // only show the notification if it finished.\n  if (typeof npm.updateNotification === 'string') {\n    const { level } = npm.log\n    npm.log.level = 'notice'\n    npm.log.notice('', npm.updateNotification)\n    npm.log.level = level\n  }\n\n  exitHandlerCalled = true\n\n  let exitCode\n  let noLog\n\n  if (err) {\n    exitCode = 1\n    // if we got a command that just shells out to something else, then it\n    // will presumably print its own errors and exit with a proper status\n    // code if there's a problem.  If we got an error with a code=0, then...\n    // something else went wrong along the way, so maybe an npm problem?\n    const isShellout = npm.shelloutCommands.includes(npm.command)\n    const quietShellout = isShellout && typeof err.code === 'number' && err.code\n    if (quietShellout) {\n      exitCode = err.code\n      noLog = true\n    } else if (typeof err === 'string') {\n      noLog = true\n      npm.log.error('', err)\n    } else if (!(err instanceof Error)) {\n      noLog = true\n      npm.log.error('weird error', err)\n    } else {\n      if (!err.code) {\n        const matchErrorCode = err.message.match(/^(?:Error: )?(E[A-Z]+)/)\n        err.code = matchErrorCode && matchErrorCode[1]\n      }\n\n      for (const k of ['type', 'stack', 'statusCode', 'pkgid']) {\n        const v = err[k]\n        if (v)\n          npm.log.verbose(k, replaceInfo(v))\n      }\n\n      npm.log.verbose('cwd', process.cwd())\n\n      const args = replaceInfo(process.argv)\n      npm.log.verbose('', os.type() + ' ' + os.release())\n      npm.log.verbose('argv', args.map(JSON.stringify).join(' '))\n      npm.log.verbose('node', process.version)\n      npm.log.verbose('npm ', 'v' + npm.version)\n\n      for (const k of ['code', 'syscall', 'file', 'path', 'dest', 'errno']) {\n        const v = err[k]\n        if (v)\n          npm.log.error(k, v)\n      }\n\n      const msg = errorMessage(err, npm)\n      for (const errline of [...msg.summary, ...msg.detail])\n        npm.log.error(...errline)\n\n      if (npm.config.loaded && npm.config.get('json')) {\n        const error = {\n          error: {\n            code: err.code,\n            summary: messageText(msg.summary),\n            detail: messageText(msg.detail),\n          },\n        }\n        console.error(JSON.stringify(error, null, 2))\n      }\n\n      if (typeof err.errno === 'number')\n        exitCode = err.errno\n      else if (typeof err.code === 'number')\n        exitCode = err.code\n    }\n  }\n  npm.log.verbose('exit', exitCode || 0)\n\n  if (npm.log.level === 'silent')\n    noLog = true\n\n  // noLog is true if there was an error, including if config wasn't loaded, so\n  // this doesn't need a config.loaded guard\n  if (exitCode && !noLog)\n    writeLogFile()\n\n  // explicitly call process.exit now so we don't hang on things like the\n  // update notifier, also flush stdout beforehand because process.exit doesn't\n  // wait for that to happen.\n  process.stdout.write('', () => process.exit(exitCode))\n}\n\nconst messageText = msg => msg.map(line => line.slice(1).join(' ')).join('\\n')\n\nconst writeLogFile = () => {\n  try {\n    let logOutput = ''\n    npm.log.record.forEach(m => {\n      const p = [m.id, m.level]\n      if (m.prefix)\n        p.push(m.prefix)\n      const pref = p.join(' ')\n\n      m.message.trim().split(/\\r?\\n/)\n        .map(line => (pref + ' ' + line).trim())\n        .forEach(line => {\n          logOutput += line + os.EOL\n        })\n    })\n\n    const file = getLogFile()\n    const dir = path.dirname(file)\n    mkdirp.sync(dir)\n    writeFileAtomic.sync(file, logOutput)\n\n    const st = fs.lstatSync(path.dirname(npm.config.get('cache')))\n    fs.chownSync(dir, st.uid, st.gid)\n    fs.chownSync(file, st.uid, st.gid)\n\n    // truncate once it's been written.\n    npm.log.record.length = 0\n    wroteLogFile = true\n  } catch (ex) {\n\n  }\n}\n\nmodule.exports = exitHandler\nmodule.exports.setNpm = (n) => {\n  npm = n\n}\n"]},"metadata":{},"sourceType":"script"}