{"ast":null,"code":"// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\nconst npa = require('npm-package-arg');\n\nconst ssri = require('ssri');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  basename,\n  dirname\n} = require('path');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst tar = require('tar');\n\nconst procLog = require('./util/proc-log.js');\n\nconst retry = require('promise-retry');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst isPackageBin = require('./util/is-package-bin.js');\n\nconst getContents = require('@npmcli/installed-package-contents'); // we only change ownership on unix platforms, and only if uid is 0\n\n\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid()\n} : null;\nconst chownr = selfOwner ? promisify(require('chownr')) : null;\nconst inferOwner = selfOwner ? require('infer-owner') : null;\n\nconst mkdirp = require('mkdirp');\n\nconst cacheDir = require('./util/cache-dir.js'); // Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\n\n\nconst _chown = Symbol('_chown');\n\nconst _extract = Symbol('_extract');\n\nconst _mkdir = Symbol('_mkdir');\n\nconst _empty = Symbol('_empty');\n\nconst _toFile = Symbol('_toFile');\n\nconst _tarxOptions = Symbol('_tarxOptions');\n\nconst _entryMode = Symbol('_entryMode');\n\nconst _istream = Symbol('_istream');\n\nconst _assertType = Symbol('_assertType');\n\nconst _tarballFromCache = Symbol('_tarballFromCache');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\n\nclass FetcherBase {\n  constructor(spec, opts) {\n    if (!opts || typeof opts !== 'object') throw new TypeError('options object is required');\n    this.spec = npa(spec, opts.where);\n    this.allowGitIgnore = !!opts.allowGitIgnore; // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n\n    this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;\n\n    this[_assertType](); // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n\n\n    this.opts = { ...opts\n    };\n    this.cache = opts.cache || cacheDir();\n    this.resolved = opts.resolved || null; // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512';\n    if (typeof opts.integrity === 'string') this.opts.integrity = ssri.parse(opts.integrity);\n    this.package = null;\n    this.type = this.constructor.name;\n    this.fmode = opts.fmode || 0o666;\n    this.dmode = opts.dmode || 0o777; // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n\n    this.umask = opts.umask || 0;\n    this.log = opts.log || procLog;\n    this.preferOnline = !!opts.preferOnline;\n    this.preferOffline = !!opts.preferOffline;\n    this.offline = !!opts.offline;\n    this.before = opts.before;\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata;\n    this.defaultTag = opts.defaultTag || 'latest';\n    this.registry = (opts.registry || 'https://registry.npmjs.org').replace(/\\/+$/, ''); // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n\n    this.npmBin = opts.npmBin || 'npm'; // command to install deps for preparing\n\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force']; // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n\n    this.npmCliConfig = opts.npmCliConfig || [`--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...(this.before ? [`--before=${this.before.toISOString()}`] : []), '--no-progress', '--no-save', '--no-audit', // override any omit settings from the environment\n    '--include=dev', '--include=peer', '--include=optional', // we need the actual things, not just the lockfile\n    '--no-package-lock-only', '--no-dry-run'];\n  }\n\n  get integrity() {\n    return this.opts.integrity || null;\n  }\n\n  set integrity(i) {\n    if (!i) return;\n    i = ssri.parse(i);\n    const current = this.opts.integrity; // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n\n    if (current) current.merge(i);else this.opts.integrity = i;\n  }\n\n  get notImplementedError() {\n    return new Error('not implemented in this fetcher type: ' + this.type);\n  } // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n\n\n  resolve() {\n    return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);\n  }\n\n  packument() {\n    return Promise.reject(this.notImplementedError);\n  } // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n\n\n  manifest() {\n    return Promise.reject(this.notImplementedError);\n  } // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n\n\n  [_tarballFromResolved]() {\n    throw this.notImplementedError;\n  } // public, should not be overridden\n\n\n  tarball() {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity);\n      data.resolved = this.resolved;\n      data.from = this.from;\n      return data;\n    }));\n  } // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n\n\n  [_tarballFromCache]() {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);\n  }\n\n  get [_cacheFetches]() {\n    return true;\n  }\n\n  [_istream](stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts);\n    istream.on('integrity', i => this.integrity = i);\n    stream.on('error', er => istream.emit('error', er)); // if not caching this, just pipe through to the istream and return it\n\n    if (!this.opts.cache || !this[_cacheFetches]) return stream.pipe(istream); // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the istream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the istream end until the cache stream ends.\n\n    stream.pipe(istream, {\n      end: false\n    });\n    const cstream = cacache.put.stream(this.opts.cache, `pacote:tarball:${this.from}`, this.opts);\n    stream.pipe(cstream); // defer istream end until after cstream\n    // cache write errors should not crash the fetch, this is best-effort.\n\n    cstream.promise().catch(() => {}).then(() => istream.end());\n    return istream;\n  }\n\n  pickIntegrityAlgorithm() {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;\n  } // TODO: check error class, once those are rolled out to our deps\n\n\n  isDataCorruptionError(er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR';\n  } // override the types getter\n\n\n  get types() {}\n\n  [_assertType]() {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(', ')}`);\n    }\n  } // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n\n\n  isRetriableError(er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT' || er.code === 'EISDIR';\n  } // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n\n\n  tarballStream(streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n    const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);\n        return this.cleanupCached().then(() => {\n          throw er;\n        });\n      } else {\n        throw er;\n      }\n    }) : null;\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) throw er;\n        this.log.silly('tarball', `no local data for ${this.spec}. Extracting by manifest.`);\n      }\n\n      return this.resolve().then(() => retry(tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch(er => {\n        // Most likely data integrity.  A cache ENOENT error is unlikely\n        // here, since we're definitely not reading from the cache, but it\n        // IS possible that the fetch subsystem accessed the cache, and the\n        // entry got blown away or something.  Try one more time to be sure.\n        if (this.isRetriableError(er)) {\n          this.log.warn('tarball', `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);\n          return this.cleanupCached().then(() => tryAgain(er));\n        }\n\n        throw er;\n      }), {\n        retries: 1,\n        minTimeout: 0,\n        maxTimeout: 0\n      }));\n    };\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved();\n  }\n\n  cleanupCached() {\n    return cacache.rm.content(this.cache, this.integrity, this.opts);\n  }\n\n  async [_chown](path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid) ? chownr(path, uid, gid) :\n    /* istanbul ignore next - we don't test in root-owned folders */\n    null;\n  }\n\n  [_empty](path) {\n    return getContents({\n      path,\n      depth: 1\n    }).then(contents => Promise.all(contents.map(entry => rimraf(entry))));\n  }\n\n  [_mkdir](dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({})) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => this[_empty](dest).then(() => mkdirp(dest)).then(made => {\n      // ignore the || dest part in coverage.  It's there to handle\n      // race conditions where the dir may be made by someone else\n      // after being removed by us.\n      const dir = made ||\n      /* istanbul ignore next */\n      dest;\n      return this[_chown](dir, uid, gid);\n    }).then(() => ({\n      uid,\n      gid\n    })));\n  } // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n\n\n  extract(dest) {\n    return this[_mkdir](dest).then(({\n      uid,\n      gid\n    }) => this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)));\n  }\n\n  [_toFile](dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest);\n      str.on('error', er => writer.emit('error', er));\n      writer.on('error', er => rej(er));\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from\n      }));\n      str.pipe(writer);\n    }));\n  } // don't use this[_mkdir] because we don't want to rimraf anything\n\n\n  tarballFile(dest) {\n    const dir = dirname(dest);\n    return !inferOwner ? mkdirp(dir).then(() => this[_toFile](dest)) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => mkdirp(dir).then(made => this[_toFile](dest).then(res => this[_chown](made || dir, uid, gid).then(() => res))));\n  }\n\n  [_extract](dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({\n      cwd: dest,\n      uid,\n      gid\n    }));\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from\n        });\n      });\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message);\n        this.log.silly('tar', er);\n        reject(er);\n      });\n      tarball.on('error', er => reject(er));\n    });\n    tarball.pipe(extractor);\n    return p;\n  } // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n\n\n  [_entryMode](path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode :\n    /* istanbul ignore next - should never happen in a pkg */\n    0; // make sure package bins are executable\n\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0; // always ensure that files are read/writable by the owner\n\n    return (mode | m) & ~this.umask | exe | 0o600;\n  }\n\n  [_tarxOptions]({\n    cwd,\n    uid,\n    gid\n  }) {\n    const sawIgnores = new Set();\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) return false;\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type); // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path);\n          if (base === '.npmignore') sawIgnores.add(entry.path);else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore');\n            if (sawIgnores.has(ni)) return false;\n            entry.path = ni;\n          }\n          return true;\n        }\n      },\n      strip: 1,\n      onwarn:\n      /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg);\n        this.log.silly('tar', code, msg, data);\n      },\n      uid,\n      gid,\n      umask: this.umask\n    };\n  }\n\n}\n\nmodule.exports = FetcherBase; // Child classes\n\nconst GitFetcher = require('./git.js');\n\nconst RegistryFetcher = require('./registry.js');\n\nconst FileFetcher = require('./file.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst RemoteFetcher = require('./remote.js'); // Get an appropriate fetcher object from a spec and options\n\n\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where);\n\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts);\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts);\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts);\n\n    case 'file':\n      return new FileFetcher(spec, opts);\n\n    case 'directory':\n      return new DirFetcher(spec, opts);\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type);\n  }\n};","map":{"version":3,"sources":["C:/Users/ghedi/Documents/GhedBlog/node_modules/npm/node_modules/pacote/lib/fetcher.js"],"names":["npa","require","ssri","promisify","basename","dirname","rimraf","tar","procLog","retry","fsm","cacache","isPackageBin","getContents","selfOwner","process","getuid","uid","gid","getgid","chownr","inferOwner","mkdirp","cacheDir","_chown","Symbol","_extract","_mkdir","_empty","_toFile","_tarxOptions","_entryMode","_istream","_assertType","_tarballFromCache","_tarballFromResolved","for","_cacheFetches","FetcherBase","constructor","spec","opts","TypeError","where","allowGitIgnore","from","registry","name","rawSpec","saveSpec","cache","resolved","defaultIntegrityAlgorithm","integrity","parse","package","type","fmode","dmode","umask","log","preferOnline","preferOffline","offline","before","fullMetadata","defaultTag","replace","npmBin","npmInstallCmd","npmCliConfig","toISOString","i","current","merge","notImplementedError","Error","resolve","Promise","reject","packument","manifest","tarball","tarballStream","stream","concat","then","data","String","get","byDigest","istream","integrityStream","on","er","emit","pipe","end","cstream","put","promise","catch","pickIntegrityAlgorithm","pickAlgorithm","isDataCorruptionError","code","types","includes","join","isRetriableError","streamHandler","fromCache","warn","cleanupCached","fromResolved","silly","tryAgain","retries","minTimeout","maxTimeout","rm","content","path","depth","contents","all","map","entry","dest","made","dir","extract","str","res","rej","writer","WriteStream","tarballFile","extractor","x","cwd","p","message","mode","m","test","exe","sawIgnores","Set","noChmod","noMtime","filter","base","add","ni","has","strip","onwarn","msg","module","exports","GitFetcher","RegistryFetcher","FileFetcher","DirFetcher","RemoteFetcher","subSpec"],"mappings":"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","sourcesContent":["// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg')\nconst ssri = require('ssri')\nconst { promisify } = require('util')\nconst { basename, dirname } = require('path')\nconst rimraf = promisify(require('rimraf'))\nconst tar = require('tar')\nconst procLog = require('./util/proc-log.js')\nconst retry = require('promise-retry')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst isPackageBin = require('./util/is-package-bin.js')\nconst getContents = require('@npmcli/installed-package-contents')\n\n// we only change ownership on unix platforms, and only if uid is 0\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid(),\n} : null\nconst chownr = selfOwner ? promisify(require('chownr')) : null\nconst inferOwner = selfOwner ? require('infer-owner') : null\nconst mkdirp = require('mkdirp')\nconst cacheDir = require('./util/cache-dir.js')\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _chown = Symbol('_chown')\nconst _extract = Symbol('_extract')\nconst _mkdir = Symbol('_mkdir')\nconst _empty = Symbol('_empty')\nconst _toFile = Symbol('_toFile')\nconst _tarxOptions = Symbol('_tarxOptions')\nconst _entryMode = Symbol('_entryMode')\nconst _istream = Symbol('_istream')\nconst _assertType = Symbol('_assertType')\nconst _tarballFromCache = Symbol('_tarballFromCache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\n\nclass FetcherBase {\n  constructor (spec, opts) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('options object is required')\n    this.spec = npa(spec, opts.where)\n\n    this.allowGitIgnore = !!opts.allowGitIgnore\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry\n      ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec\n\n    this[_assertType]()\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = {...opts}\n\n    this.cache = opts.cache || cacheDir()\n    this.resolved = opts.resolved || null\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512'\n\n    if (typeof opts.integrity === 'string')\n      this.opts.integrity = ssri.parse(opts.integrity)\n\n    this.package = null\n    this.type = this.constructor.name\n    this.fmode = opts.fmode || 0o666\n    this.dmode = opts.dmode || 0o777\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0\n    this.log = opts.log || procLog\n\n    this.preferOnline = !!opts.preferOnline\n    this.preferOffline = !!opts.preferOffline\n    this.offline = !!opts.offline\n\n    this.before = opts.before\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata\n\n    this.defaultTag = opts.defaultTag || 'latest'\n    this.registry = (opts.registry || 'https://registry.npmjs.org')\n      .replace(/\\/+$/, '')\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm'\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || [ 'install', '--force' ]\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [\n      `--cache=${dirname(this.cache)}`,\n      `--prefer-offline=${!!this.preferOffline}`,\n      `--prefer-online=${!!this.preferOnline}`,\n      `--offline=${!!this.offline}`,\n      ...(this.before ? [`--before=${this.before.toISOString()}`] : []),\n      '--no-progress',\n      '--no-save',\n      '--no-audit',\n      // override any omit settings from the environment\n      '--include=dev',\n      '--include=peer',\n      '--include=optional',\n      // we need the actual things, not just the lockfile\n      '--no-package-lock-only',\n      '--no-dry-run',\n    ]\n  }\n\n  get integrity () {\n    return this.opts.integrity || null\n  }\n  set integrity (i) {\n    if (!i)\n      return\n\n    i = ssri.parse(i)\n    const current = this.opts.integrity\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current)\n      current.merge(i)\n    else\n      this.opts.integrity = i\n  }\n\n  get notImplementedError () {\n    return new Error('not implemented in this fetcher type: ' + this.type)\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve () {\n    return this.resolved ? Promise.resolve(this.resolved)\n      : Promise.reject(this.notImplementedError)\n  }\n\n  packument () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved] () {\n    throw this.notImplementedError\n  }\n\n  // public, should not be overridden\n  tarball () {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity)\n      data.resolved = this.resolved\n      data.from = this.from\n      return data\n    }))\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache] () {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts)\n  }\n\n  get [_cacheFetches] () {\n    return true\n  }\n\n  [_istream] (stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts)\n    istream.on('integrity', i => this.integrity = i)\n    stream.on('error', er => istream.emit('error', er))\n\n    // if not caching this, just pipe through to the istream and return it\n    if (!this.opts.cache || !this[_cacheFetches])\n      return stream.pipe(istream)\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the istream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the istream end until the cache stream ends.\n    stream.pipe(istream, { end: false })\n    const cstream = cacache.put.stream(\n      this.opts.cache,\n      `pacote:tarball:${this.from}`,\n      this.opts\n    )\n    stream.pipe(cstream)\n    // defer istream end until after cstream\n    // cache write errors should not crash the fetch, this is best-effort.\n    cstream.promise().catch(() => {}).then(() => istream.end())\n\n    return istream\n  }\n\n  pickIntegrityAlgorithm () {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts)\n      : this.defaultIntegrityAlgorithm\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError (er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR'\n  }\n\n  // override the types getter\n  get types () {}\n  [_assertType] () {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${\n        this.spec.type\n      }) for ${\n        this.constructor.name\n      }. Supported types: ${this.types.join(', ')}`)\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError (er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) ||\n      er.code === 'ENOENT' ||\n      er.code === 'EISDIR'\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream (streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = (\n      !this.preferOnline &&\n      this.integrity &&\n      this.resolved\n    ) ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${\n          this.spec\n        } (${this.integrity}) seems to be corrupted. Refreshing cache.`)\n        return this.cleanupCached().then(() => { throw er })\n      } else {\n        throw er\n      }\n    }) : null\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er))\n          throw er\n        this.log.silly('tarball', `no local data for ${\n          this.spec\n        }. Extracting by manifest.`)\n      }\n      return this.resolve().then(() => retry(tryAgain =>\n        streamHandler(this[_istream](this[_tarballFromResolved]()))\n        .catch(er => {\n          // Most likely data integrity.  A cache ENOENT error is unlikely\n          // here, since we're definitely not reading from the cache, but it\n          // IS possible that the fetch subsystem accessed the cache, and the\n          // entry got blown away or something.  Try one more time to be sure.\n          if (this.isRetriableError(er)) {\n            this.log.warn('tarball', `tarball data for ${\n              this.spec\n            } (${this.integrity}) seems to be corrupted. Trying again.`)\n            return this.cleanupCached().then(() => tryAgain(er))\n          }\n          throw er\n        }), { retries: 1, minTimeout: 0, maxTimeout: 0 }))\n    }\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved()\n  }\n\n  cleanupCached () {\n    return cacache.rm.content(this.cache, this.integrity, this.opts)\n  }\n\n  async [_chown] (path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid)\n      ? chownr(path, uid, gid)\n      : /* istanbul ignore next - we don't test in root-owned folders */ null\n  }\n\n  [_empty] (path) {\n    return getContents({path, depth: 1}).then(contents => Promise.all(\n      contents.map(entry => rimraf(entry))))\n  }\n\n  [_mkdir] (dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner\n      ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({}))\n      : inferOwner(dest).then(({uid, gid}) =>\n        this[_empty](dest)\n          .then(() => mkdirp(dest))\n          .then(made => {\n            // ignore the || dest part in coverage.  It's there to handle\n            // race conditions where the dir may be made by someone else\n            // after being removed by us.\n            const dir = made || /* istanbul ignore next */ dest\n            return this[_chown](dir, uid, gid)\n          })\n          .then(() => ({uid, gid})))\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract (dest) {\n    return this[_mkdir](dest).then(({uid, gid}) =>\n      this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)))\n  }\n\n  [_toFile] (dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest)\n      str.on('error', er => writer.emit('error', er))\n      writer.on('error', er => rej(er))\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from,\n      }))\n      str.pipe(writer)\n    }))\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile (dest) {\n    const dir = dirname(dest)\n    return !inferOwner\n      ? mkdirp(dir).then(() => this[_toFile](dest))\n      : inferOwner(dest).then(({uid, gid}) =>\n        mkdirp(dir).then(made => this[_toFile](dest)\n          .then(res => this[_chown](made || dir, uid, gid)\n            .then(() => res))))\n  }\n\n  [_extract] (dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({ cwd: dest, uid, gid }))\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from,\n        })\n      })\n\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message)\n        this.log.silly('tar', er)\n        reject(er)\n      })\n\n      tarball.on('error', er => reject(er))\n    })\n\n    tarball.pipe(extractor)\n    return p\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode] (path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode\n      : /File$/.test(type) ? this.fmode\n      : /* istanbul ignore next - should never happen in a pkg */ 0\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0\n    // always ensure that files are read/writable by the owner\n    return ((mode | m) & ~this.umask) | exe | 0o600\n  }\n\n  [_tarxOptions] ({ cwd, uid, gid }) {\n    const sawIgnores = new Set()\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type))\n          return false\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type)\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path)\n          if (base === '.npmignore')\n            sawIgnores.add(entry.path)\n          else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore')\n            if (sawIgnores.has(ni))\n              return false\n            entry.path = ni\n          }\n          return true\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg)\n        this.log.silly('tar', code, msg, data)\n      },\n      uid,\n      gid,\n      umask: this.umask,\n    }\n  }\n}\n\nmodule.exports = FetcherBase\n\n// Child classes\nconst GitFetcher = require('./git.js')\nconst RegistryFetcher = require('./registry.js')\nconst FileFetcher = require('./file.js')\nconst DirFetcher = require('./dir.js')\nconst RemoteFetcher = require('./remote.js')\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where)\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts)\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts)\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts)\n\n    case 'file':\n      return new FileFetcher(spec, opts)\n\n    case 'directory':\n      return new DirFetcher(spec, opts)\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}